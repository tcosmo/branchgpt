<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 946f9e3f-d3db-4cc8-8833-6d113a128b58 (2026-01-18 18:26Z) -->

# Highlighted text disappearance with popover (2026-01-18 18:26Z)

_**User (2026-01-18 15:24Z)**_

highlighted text disappear when I press shift and that part of the highlighted text is Bold, can you fix that

---

_**Agent (model gpt-5.2, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Fixing app bug**

I need to fix a bug in the app that seems related to selection highlights when using the shift key. It might be in the custom text editor, where pressing shift causes highlighted text to disappear if it's partially bold. This could be an issue with selection rendering or the DOM. I should inspect App.jsx around where selection rendering happens and check the CSS too. I'll search for key handlers using grep to help.</details></think>

---

Got it. I’m going to (1) locate the keyboard handler that runs on `Shift`, (2) reproduce the “selection highlight disappears” path specifically when the selection spans **bold** text, then (3) patch the selection/highlight rendering so it remains stable regardless of font weight.

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "onKeyDown|addEventListener\(['"]keydown|keydown\b|Shift" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 8 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `onKeyDown=\{(event) => \{` | L540 |
| `src/App.jsx` | `const onKeyDown = (event) => \{` | L794 |
| `src/App.jsx` | `if (event.key === "Shift") \{` | L795 |
| `src/App.jsx` | `window.addEventListener("keydown", onKeyDown);` | L836 |
| `src/App.jsx` | `return () => window.removeEventListener("keydown", onKeyDown);` | L837 |
| `src/App.jsx` | `onKeyDown=\{handleComposerKeyDown\}` | L1684 |
| `src/App.jsx` | `onKeyDown=\{handleComposerKeyDown\}` | L1800 |
| `src/App.jsx` | `onKeyDown=\{handleBranchKeyDown\}` | L1872 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "selection|highlight|range|caret|anchor|focus|getSelection\(|Range\(" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 85 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `highlightId,` | L100 |
| `src/App.jsx` | `if (!content \|\| !tempId \|\| !highlightId \|\| !branchNodeId) return content;` | L103 |
| `src/App.jsx` | `const branchStart = `$\{BRANCH_HL_START\}$\{highlightId\}:$\{branchNodeId\}]]]`;` | L105 |
| `src/App.jsx` | `highlightId,` | L114 |
| `src/App.jsx` | `const start = `$\{BRANCH_HL_START\}$\{highlightId\}:$\{branchNodeId\}]]]`;` | L118 |
| `src/App.jsx` | `const [highlightId, branchNodeId] = meta.split(":");` | L187 |
| `src/App.jsx` | `if (!highlightId \|\| !branchNodeId) break;` | L188 |
| `src/App.jsx` | `url: `branch-highlight:$\{highlightId\}:$\{branchNodeId\}`,` | L191 |
| `src/App.jsx` | `url: `temp-highlight:$\{tempId\}`,` | L199 |
| `src/App.jsx` | `lines.push(`Branch highlight excerpt:\n"""$\{truncateForContext(excerpt, 1200)\}"""`);` | L373 |
| `src/App.jsx` | `const [selectionPopover, setSelectionPopover] = useState(\{` | L424 |
| `src/App.jsx` | `if (typeof href === "string" && href.startsWith("temp-highlight:")) \{` | L482 |
| `src/App.jsx` | `className="branch-highlight is-temp"` | L488 |
| `src/App.jsx` | `if (typeof href === "string" && href.startsWith("branch-highlight:")) \{` | L497 |
| `src/App.jsx` | `const highlightId = parts[1];` | L499 |
| `src/App.jsx` | `const disableHoverEffects = selectionPopover.visible;` | L501 |
| `src/App.jsx` | `className=\{`branch-highlight $\{disableHoverEffects ? "no-hover" : ""\} $\{isHovered ? "is-hovered" : ""` | L507 |
| `src/App.jsx` | `data-highlight-id=\{highlightId\}` | L510 |
| `src/App.jsx` | `aria-label="Branch highlight"` | L514 |
| `src/App.jsx` | `// Avoid creating a new selection while clicking the highlight` | L532 |
| `src/App.jsx` | `[flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],` | L573 |
| `src/App.jsx` | `if (selectionPopover.visible) \{` | L766 |
| `src/App.jsx` | `window.getSelection()?.removeAllRanges?.();` | L812 |
| `src/App.jsx` | `if (selectionPopover.visible) \{` | L813 |
| `src/App.jsx` | `\}, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);` | L838 |
| `src/App.jsx` | `if (!selectionPopover.visible) return;` | L886 |
| `src/App.jsx` | `if (!selectionPopover.text?.trim()) return;` | L887 |
| `src/App.jsx` | `if (selectionPopover.messageIndex == null) return;` | L888 |
| `src/App.jsx` | `if (!selectionPopover.nodeId) return;` | L889 |
| `src/App.jsx` | `if (!selectionPopover.treeId) return;` | L890 |
| `src/App.jsx` | `const nodeId = selectionPopover.nodeId;` | L902 |
| `src/App.jsx` | `const msgIdx = selectionPopover.messageIndex;` | L903 |
| `src/App.jsx` | `updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =>` | L904 |
| `src/App.jsx` | `content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),` | L909 |
| `src/App.jsx` | `treeId: selectionPopover.treeId,` | L917 |
| `src/App.jsx` | `window.getSelection()?.removeAllRanges?.();` | L919 |
| `src/App.jsx` | `selectionPopover.visible,` | L921 |
| `src/App.jsx` | `selectionPopover.text,` | L922 |
| `src/App.jsx` | `selectionPopover.messageIndex,` | L923 |
| `src/App.jsx` | `selectionPopover.nodeId,` | L924 |
| `src/App.jsx` | `selectionPopover.treeId,` | L925 |
| `src/App.jsx` | `if (!selectionPopover.text.trim() \|\| !selectionPopover.draft.trim()) \{` | L1089 |
| `src/App.jsx` | `const treeId = selectionPopover.treeId \|\| activeTreeId;` | L1093 |
| `src/App.jsx` | `const sourceNodeId = selectionPopover.nodeId \|\| activeNodeId;` | L1095 |
| `src/App.jsx` | `const userMessage = selectionPopover.draft.trim();` | L1096 |
| `src/App.jsx` | `const branchExcerpt = selectionPopover.text.trim();` | L1098 |
| `src/App.jsx` | `const highlightId = crypto.randomUUID();` | L1115 |
| `src/App.jsx` | `highlightId,` | L1125 |
| `src/App.jsx` | `\} else if (selectionPopover.messageIndex != null) \{` | L1132 |
| `src/App.jsx` | `if (i !== selectionPopover.messageIndex \|\| typeof m?.content !== "string") return m;` | L1135 |
| `src/App.jsx` | `selectionPopover.text,` | L1140 |
| `src/App.jsx` | `highlightId,` | L1141 |
| `src/App.jsx` | `window.getSelection()?.removeAllRanges?.();` | L1158 |
| `src/App.jsx` | `const selection = window.getSelection();` | L1209 |
| `src/App.jsx` | `if (!selection \|\| selection.isCollapsed) return null;` | L1210 |
| `src/App.jsx` | `const anchorNode = selection.anchorNode;` | L1211 |
| `src/App.jsx` | `const focusNode = selection.focusNode;` | L1212 |
| `src/App.jsx` | `!chatAreaRef.current.contains(anchorNode) \|\|` | L1215 |
| `src/App.jsx` | `!chatAreaRef.current.contains(focusNode)` | L1216 |
| `src/App.jsx` | `const text = selection.toString().trim();` | L1220 |
| `src/App.jsx` | `const range = selection.getRangeAt(0);` | L1222 |
| `src/App.jsx` | `const rect = range.getBoundingClientRect();` | L1223 |
| `src/App.jsx` | `range.startContainer?.nodeType === Node.TEXT_NODE` | L1229 |
| `src/App.jsx` | `? range.startContainer.parentElement` | L1230 |
| `src/App.jsx` | `: range.startContainer;` | L1231 |
| `src/App.jsx` | `if (selectionPopover.visible) \{` | L1250 |
| `src/App.jsx` | `if (selectionPopover.visible) \{` | L1266 |
| `src/App.jsx` | `// Wait a frame so the parent node messages/highlights are in the DOM.` | L1378 |
| `src/App.jsx` | `const highlightEl = container.querySelector(selector);` | L1381 |
| `src/App.jsx` | `if (highlightEl) \{` | L1382 |
| `src/App.jsx` | `highlightEl.scrollIntoView(\{ behavior: "smooth", block: "center" \});` | L1383 |
| `src/App.jsx` | `title=\{`Jump back to the highlight in "$\{parentNode.title\}" that created this branch`\}` | L1717 |
| `src/App.jsx` | `aria-label="Jump to parent highlight"` | L1718 |
| `src/App.jsx` | `Jump to parent highlight` | L1721 |
| `src/App.jsx` | `\{selectionPopover.visible && selectionPopover.rect && (` | L1852 |
| `src/App.jsx` | `className="selection-popover"` | L1855 |
| `src/App.jsx` | `data-placement=\{selectionPopover.placement\}` | L1856 |
| `src/App.jsx` | `top: `$\{selectionPopover.rect.top\}px`,` | L1858 |
| `src/App.jsx` | `left: `$\{selectionPopover.rect.left\}px`,` | L1859 |
| `src/App.jsx` | `<div className="selection-title">New branch</div>` | L1862 |
| `src/App.jsx` | `placeholder="Ask anything about selection"` | L1864 |
| `src/App.jsx` | `value=\{selectionPopover.draft\}` | L1865 |
| `src/App.jsx` | `<div className="selection-actions">` | L1875 |
| `src/App.jsx` | `window.getSelection()?.removeAllRanges?.();` | L1901 |
| `src/App.jsx` | `disabled=\{!selectionPopover.draft.trim()\}` | L1910 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Interpreting a bug**

I need to figure out this bug where highlighted text disappears when I press shift, especially if that text is bold. In this app, a selection popover shows up when the shift key is held. I notice that the handleSelection checks for the event.shiftKey, and there's a keydown listener for Shift at around line 794. That listener seems to get some selection payload and makes the selection popover visible. I should read through that handler for more context.</details></think>

---

Nice, I found the exact spot: there’s a global `keydown` listener that fires when you press **Shift** and it immediately reads `window.getSelection()` and then later clears ranges. If the selection spans a bold node (separate DOM subtree), `getRangeAt(0)` / rect calculations can temporarily fail and we end up clearing the selection—so the highlight “disappears.” Next I’ll make the Shift handler non-destructive and resilient across mixed formatting.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "removeAllRanges\(\)" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "handleSelection\(" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Exploring highlight issues with bold text**

I'm grappling with how bold formatting affects text selection. If the selected text includes bold, it complicates matching the substring correctly, which can lead to highlight issues. When the selection is cleared, the user loses their highlight completely. I think the solution lies in not clearing the selection unless I successfully create a temporary highlight. Alternatively, it might be better to establish a reliable mapping between the selected range and the markdown positions, though that's a heavier task.
**Addressing selection highlight issues**

I'm considering a minimal fix for selection issues—clearing the selection only after successful wrapping or keeping the selection highlight even if wrapping fails. Users want the highlighted text to stay visible when they press shift, particularly with bold formatting involved. To improve the situation, I could create a better wrapping algorithm that ignores markdown formatting tokens. This would allow for fuzzy matching between the plain text and markdown content, which seems doable. I'll explore some functions related to this next.</details></think>

---

Aha: the selection/highlight pipeline is string-based against the **raw markdown** (`m.content`), but the user’s selection text comes from the rendered DOM (markdown stripped). That mismatch is exactly why selections spanning `**bold**` fail to wrap, and then we clear the native selection—so it looks like the highlight vanished. Next I’ll make the wrapper “markdown-aware” (ignore formatting tokens while matching) and only clear the selection once we successfully inserted the temp highlight.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "function\s+wrapFirstMatchWithTempHighlight|wrapFirstMatchWithTempHighlight\s*=|wrapFirstMatchWithBranchHighlight" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 3 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `const wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) => \{` | L55 |
| `src/App.jsx` | `const wrapFirstMatchWithBranchHighlight = (` | L111 |
| `src/App.jsx` | `content: wrapFirstMatchWithBranchHighlight(` | L1138 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "ReactMarkdown|remark|rehype|markdown" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 18 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `import ReactMarkdown from "react-markdown";` | L8 |
| `src/App.jsx` | `import remarkGfm from "remark-gfm";` | L9 |
| `src/App.jsx` | `import remarkMath from "remark-math";` | L10 |
| `src/App.jsx` | `import remarkBreaks from "remark-breaks";` | L11 |
| `src/App.jsx` | `import rehypeKatex from "rehype-katex";` | L12 |
| `src/App.jsx` | `const remarkBranchHighlights = () => \{` | L150 |
| `src/App.jsx` | `const remarkLatexDelimiters = () => \{` | L230 |
| `src/App.jsx` | `const markdownComponents = useMemo(` | L479 |
| `src/App.jsx` | `<ReactMarkdown` | L1763 |
| `src/App.jsx` | `remarkPlugins=\{[` | L1764 |
| `src/App.jsx` | `remarkBranchHighlights,` | L1765 |
| `src/App.jsx` | `remarkLatexDelimiters,` | L1766 |
| `src/App.jsx` | `remarkGfm,` | L1767 |
| `src/App.jsx` | `remarkMath,` | L1768 |
| `src/App.jsx` | `remarkBreaks,` | L1769 |
| `src/App.jsx` | `rehypePlugins=\{[rehypeKatex]\}` | L1771 |
| `src/App.jsx` | `components=\{markdownComponents\}` | L1773 |
| `src/App.jsx` | `</ReactMarkdown>` | L1776 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "onMouseUp|onSelectionChange|selectionchange|onPointerUp" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `onMouseUp=\{handleSelection\}` | L1751 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Considering selection handling**

The user’s screenshot suggests the phrase "Factor B" is partially bold. They pointed out that part is bold, implying the selection might include it. To address this, I’m thinking of wrapping multiple segments, but that sounds complicated. A simpler fix could be using wrapFirstMatch to find the plain selected text in markdown. I might match while ignoring markdown tokens but allow for highlighting across boundaries. Another idea could be implementing a highlight overlay using CSS instead.
**Updating remark plugin**

I'm considering whether we can modify the remark plugin to manage markers that span multiple text nodes. It might be possible to traverse the nodes while tracking the state. When I hit a start marker in one text node, I could create a link until I find the end marker in a subsequent node, merging them effectively. This design seems feasible, but I still need to ensure that start and end markers are placed correctly in the source string to handle cross-boundary selections.
**Enhancing the insertion algorithm**

I’m considering how the insertion algorithm may wrap `**` tokens, potentially putting the start marker inside strong text and the end marker in plain text. The plugin can stitch nodes together, but links can't cross blocks. A solution might be creating multiple links with the same metadata, which would allow highlight segments across boundaries and could appear visually contiguous, even if there are multiple span elements. Enhancing the plugin to detect start markers and accumulate nodes until the end marker could be useful. I wonder if I should just wait until the user presses Shift to maintain their selection without clearing it.
**Addressing highlight issues**

I want to ensure that highlights remain visible when users select text. However, if the selection includes bold text, they may not see the temporary highlight. The handleSelection function expects a shift key, which affects the selection popover. If the temporary highlight fails to create but the selection stays, the user can still see the selected text, which could work. The user mentioned highlights disappear when bold text is involved, so by avoiding clearing the selection on failure, the highlights won’t disappear, as long as bold text causes this issue.
**Refining highlight insertion logic**

I need to ensure we stop setting the tempHighlight state when an insertion fails. This prevents the clickOutside function from trying to remove elements unnecessarily. I'll modify `wrapFirstMatchWithTempHighlight` to return details about whether an insertion occurred. The same approach could apply to branch highlights, especially when bold text is involved, which may cause insertion failures. It's crucial to handle the selection popover to ensure content integrity. I plan to implement a regex-based solution that accommodates markdown formatting between words to prevent mismatches with bold selections.
**Improving highlight insertion across nodes**

I need to consider how to handle insertion positions, especially when the match includes markdown tokens. For example, when matching "activates **Factor B**," I see that the `**` tokens might cause the markers to cross formatting boundaries. Instead of wrapping these tokens, it seems better to insert a start marker before the first word and an end marker after the last word, excluding the formatting markers. 

To achieve this, I’ll create a mapping of visible text indices while removing markdown formatting markers. This way, I can find the start and end positions accurately without including formatting. It's crucial to ensure the plugin can handle cross-node markers effectively, so I'll enhance it to allow for this when creating highlights, accommodating adjacent text and formatting nodes, ensuring the markers remain within the same node.
**Developing a new highlighting plugin**

I’m thinking about how to maintain a buffer for new children and track the current link node while processing text. For each child, if it's text, I’ll scan for markers and handle both start and end markers, which may take multiple passes through the value. 

When a start marker is found, I'll create an open link node and keep processing. If an end marker is found, I'll finalize that open node. If no end marker is found, I'll continue with the next child. 

For non-text children, I will ensure I append them correctly without changing the original child objects. The new plugin, which I’ll rename to `remarkHighlights`, will need to support markers that span nodes, allowing highlights to wrap correctly around bolds and other formatting without nesting issues. I can now handle selection across bold text by inserting markers appropriately around matched substrings, keeping everything in the same text node context as needed. Overall, this approach should ensure that highlights work fluidly!
**Refining regex for highlights**

I’m focusing on edge cases with the regex if a match starts or ends within formatting tokens. I plan to build a matcher that effectively finds the best match. 

First, I’ll update the `wrapFirstMatchWithTempHighlight` by keeping the existing `stripAllTempHighlights`. My strategy includes an exact substring search followed by a whitespace-regex match. 

Then, I’ll implement a "markdown-tolerant" regex that normalizes selected text, splits it into tokens, and allows for optional formatting markers around those tokens. It’s important to ensure that when I wrap the match, it includes formatting markers while keeping the start and end markers at the correct locations. This way, the highlight will properly include formatted segments, preventing issues with markers being inside strong text nodes.
**Crafting regex for highlighting**

I’m designing a pattern to match the `selectedText` that allows for optional formatting markers around words. If included, these need to be properly accounted for in the match. 

First, my approach is to clean the content and normalize the selected text by collapsing whitespace to a single space. I'll build a regex that captures the words along with optional markers and joiners. The key is to ensure that the pattern matches without bleeding into other formatting. 

I’ll also implement a helper to wrap the text correctly, ensuring markers are inserted at the right levels in the document structure. This should enhance the plugin's capability to handle interactions seamlessly!
**Updating insertion logic**

I'm working on the insertion process using `match.index` and `match[0].length`, which is great for maintaining correct positions. Now, I need to adjust the call sites accordingly.

In the temp highlight logic, I'll set the `didInsert` variable based on whether the wrapping was successful. If `didInsert` is true, I'll clear the selection. However, I'll still show the popover even if `didInsert` is false to avoid disruption in user interaction.

Lastly, I need to address the behavior of selection highlights and adjust how shifts in key presses affect the popover visibility. I'll patch the file to reflect these changes.</details></think>

---

Cool, we can fix this cleanly without hacks: I’ll (1) upgrade the `remarkBranchHighlights` plugin so our `[[[sel:...]]]...[[[/sel]]]` markers can wrap across **bold/inline formatting nodes**, and (2) make temp-highlighting only clear the native selection after we *actually* inserted a temp highlight.

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Make highlight remark plugin support temp/branch markers spanning across non-text nodes (e.g., bold)
- [ ] Only clear native selection on Shift when temp highlight insertion succeeds; improve matching to tolerate markdown markers

</details>
</tool-use>

---

Cancelled

---



---

<think><details><summary>Thought Process</summary>
**Focusing on algorithm improvements**

I need to concentrate on improving the wrapFirstMatchWithTempHighlight algorithm. My goal is to make it match text while ignoring markdown formatting markers so that it can work seamlessly. I can create a function to find matches in the markdown content, skipping over formatting tokens like `*`, `_`, and backticks, while specifically addressing bold markers like `**` and `__`. I’ll build a mapping between rendered text and original markdown indices, which might be complex but necessary for correct highlighting.
**Developing a scanning algorithm**

I’m thinking we can create a scanning algorithm that goes through the original string and builds a "normalized" version by omitting markdown emphasis delimiters like `**`, `__`, `*`, and `_`. It’s tricky to differentiate between markup and literal use, but I can try skipping sequences of `**` and `__` as well as single `*` and `_`. Maybe I could refine it further by only skipping them when they appear in pairs? 

A simpler approach might involve searching for the selected text in the content directly, and if I can’t find it, I could match with optional markers around letters and spaces. Another option is to use regex to allow `**` or `__` between characters, which could help with matching variations.
**Creating a regex pattern**

I need to create a regex pattern from the selected text that allows for optional emphasis markers at word boundaries. The idea is to match each character in the selected text with the same character, while inserting possible emphasis markers like `(?:\*\*|__|\*|_)?` in between. Plus, I need to account for cases where the selected text spans across emphasis start and end markers, meaning they should be included in matches.

First, I’ll escape the selected text and replace whitespace with `\s+`. Then, to allow those emphasis delimiters at any position, I’ll modify the pattern to insert `(?:\*\*|__|\*|_)?` between tokens. It might be a bit costly to do this for each character, but it should be manageable. I could optimize it by inserting between word characters and whitespace groups, perhaps transforming the pattern to allow markers between tokens more effectively.
**Exploring a mapping approach**

I'm considering a mapping approach for handling emphasis markers: first, I can remove all the emphasis markers from the content to create a `renderedApprox`. Then, by finding the index of the selected text in this modified version, I can map back to the original string. 

While building the `renderedApprox`, I should keep track of each character's original index—skipping over the emphasis markers but preserving their indices. Once I find the starting index of a match, I'll look up the corresponding original indices and insert highlight markers accordingly. This should wrap any bold markers within the highlighted range, which is fine because my remark plugin can handle that. However, I need to be mindful that markers might wrap across the original markdown tokens.
**Addressing highlight wrapping for markdown**

I need to analyze how ReactMarkdown will parse the emphasis markers and ensure that my highlight doesn't interfere with the markdown's behavior. For instance, if I highlight "Factor B" from the original string `Factor **B**`, I need to be aware of the emphasis markers (`**`) that are adjacent. 

When determining the start and end indices for the highlight, I want to ensure that if the selected text is fully within bold formatting, I wrap the entire emphasis markup correctly. This means checking if the end index is followed by `**`, and if the start index is preceded by it as well. I should build a helper function, `expandToIncludeEmphasisDelimiters`, to manage this expansion logic effectively. 

It will involve counting occurrences of `**` and `__` within the selected substring. If they are oddly counted, then my selection might be crossing a bold boundary, and I should expand the indices accordingly to include any unmatched delimiters. This might help prevent issues like a disappearing highlight during shift selections, especially when it comes to overlapping with emphasis markers. I'll keep an eye on making sure that other highlight functions are consistent too!
**Refining highlight management**

I’m focusing on fixing the `useEffect` for handling selection highlights. Currently, it clears the selection and inserts a temporary highlight even if no changes occur. I need to avoid clearing the selection if no match is found or if the highlight insertion fails. Instead, I should retain the native selection, keeping the popover visible. 

To achieve this, I'll compare the old and new content, checking if an insertion was successful. If I can’t find a match in the existing text, I’ll fall back to a markdown-insensitive search

I’ll implement a function to find approximate matches, skipping emphasis markers for better accuracy. If no match is found, I’ll employ regex for matching as a last resort, ensuring the selection remains intact during processing.
**Implementing modifications**

I'm about to implement some modifications using `apply_patch`. I need to be careful with the grammar since it expects a diff style for the patch. First, I'll insert helper functions right after `escapeRegex`. After that, I’ll also adjust both `wrapFirstMatchWithTempHighlight` and `wrapFirstMatchWithBranchHighlight` to utilize the new helper function. Lastly, I’ll modify the `useEffect` so it only clears the selection if a highlight was successfully inserted. Now, it's time to craft the patch content efficiently!</details></think>

---

Plan: implement a markdown-aware match so selections that include **bold** text can still be wrapped in our `[[[sel:...]]]` markers, and then only clear the browser’s native selection once we successfully inserted that marker. Next I’ll patch `wrapFirstMatchWithTempHighlight` / `wrapFirstMatchWithBranchHighlight` plus the temp-highlight `useEffect` that currently clears selection unconditionally.

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "0b492ece-8ee9-42d0-9f99-6c2c4dbe8b56",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "0b492ece-8ee9-42d0-9f99-6c2c4dbe8b56",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst countBoldDelimiters = (value) =&gt; {\n  if (!value) return 0;\n  const matches = value.match(/(\\*\\*|__)/g);\n  return matches ? matches.length : 0;\n};\n\nconst findSelectedRangeInMarkdown = (markdown, selectedText) =&gt; {\n  if (!markdown || !selectedText) return null;\n  const needle = selectedText.trim();\n  if (!needle) return null;\n\n  // Build a normalized view of markdown that drops common emphasis delimiters.\n  // This lets DOM selections (which don't include '**') match the source markdown.\n  let norm = \"\";\n  const map = []; // norm index -&gt; markdown index\n  for (let i = 0; i &lt; markdown.length; i++) {\n    const ch = markdown[i];\n    const next = markdown[i + 1];\n    if ((ch === \"*\" &amp;&amp; next === \"*\") || (ch === \"_\" &amp;&amp; next === \"_\")) {\n      i += 1; // skip the pair\n      continue;\n    }\n    if (ch === \"*\" || ch === \"_\") continue;\n    norm += ch;\n    map.push(i);\n  }\n\n  // Try exact match first.\n  let startNorm = norm.indexOf(needle);\n  let matchLen = needle.length;\n\n  // Fallback: whitespace-flexible regex match against normalized string.\n  if (startNorm === -1) {\n    const pattern = escapeRegex(needle).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(norm);\n      if (!match || match.index == null) return null;\n      startNorm = match.index;\n      matchLen = match[0]?.length || needle.length;\n    } catch {\n      return null;\n    }\n  }\n\n  const startMd = map[startNorm];\n  const endMdExclusive = map[startNorm + matchLen - 1] != null ? map[startNorm + matchLen - 1] + 1 : null;\n  if (startMd == null || endMdExclusive == null) return null;\n\n  // Expand to keep bold delimiters balanced when the match intersects bold spans.\n  let start = startMd;\n  let end = endMdExclusive;\n  for (let iter = 0; iter &lt; 6; iter++) {\n    const segment = markdown.slice(start, end);\n    if (countBoldDelimiters(segment) % 2 === 0) break;\n    let changed = false;\n    const tail = markdown.slice(end, end + 2);\n    const head = start &gt;= 2 ? markdown.slice(start - 2, start) : \"\";\n    if (tail === \"**\" || tail === \"__\") {\n      end = Math.min(markdown.length, end + 2);\n      changed = true;\n    }\n    if (head === \"**\" || head === \"__\") {\n      start = Math.max(0, start - 2);\n      changed = true;\n    }\n    if (!changed) break;\n  }\n\n  if (start &gt;= end) return null;\n  return { start, end };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(cleaned, selectedText);\n  if (range) {\n    return (\n      cleaned.slice(0, range.start) +\n      start +\n      cleaned.slice(range.start, range.end) +\n      end +\n      cleaned.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(content, selectedText);\n  if (range) {\n    return (\n      content.slice(0, range.start) +\n      start +\n      content.slice(range.start, range.end) +\n      end +\n      content.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    // If the user deletes the last remaining tree, immediately replace it with a\n    // fresh \"New Tree\" and activate it (avoid a render where activeTreeId is null).\n    const isLastRemainingTree = Object.keys(treesById).length === 1;\n    if (isLastRemainingTree) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n      setGraphHasInteracted(false);\n      setGraphScale(1.4);\n      setGraphTranslate({ x: 0, y: 0 });\n      closeTreeMenu();\n      return;\n    }\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    let didInsert = false;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        const nextContent = wrapFirstMatchWithTempHighlight(\n          m.content,\n          selectionPopover.text,\n          tempId,\n        );\n        if (nextContent.includes(&#96;${TEMP_HL_START}${tempId}]]]&#96;)) {\n          didInsert = true;\n        }\n        return {\n          ...m,\n          content: nextContent,\n        };\n      }),\n    );\n    if (didInsert) {\n      setTempHighlight({\n        nodeId,\n        messageIndex: msgIdx,\n        tempId,\n        treeId: selectionPopover.treeId,\n      });\n      // Only clear the native selection once we've successfully inserted a temp highlight.\n      window.getSelection()?.removeAllRanges?.();\n    }\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const title = typeof node.title === \"string\" ? node.title : \"\";\n                  const words = title.split(\" \").filter(Boolean);\n                  const isPending = node.requestStatus === \"pending\";\n                  const isReady = node.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  \n  const escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n+ \n+ const countBoldDelimiters = (value) =&gt; {\n+   if (!value) return 0;\n+   const matches = value.match(/(\\*\\*|__)/g);\n+   return matches ? matches.length : 0;\n+ };\n+ \n+ const findSelectedRangeInMarkdown = (markdown, selectedText) =&gt; {\n+   if (!markdown || !selectedText) return null;\n+   const needle = selectedText.trim();\n+   if (!needle) return null;\n+ \n+   // Build a normalized view of markdown that drops common emphasis delimiters.\n+   // This lets DOM selections (which don't include '**') match the source markdown.\n+   let norm = \"\";\n+   const map = []; // norm index -&gt; markdown index\n+   for (let i = 0; i &lt; markdown.length; i++) {\n+     const ch = markdown[i];\n+     const next = markdown[i + 1];\n+     if ((ch === \"*\" &amp;&amp; next === \"*\") || (ch === \"_\" &amp;&amp; next === \"_\")) {\n+       i += 1; // skip the pair\n+       continue;\n+     }\n+     if (ch === \"*\" || ch === \"_\") continue;\n+     norm += ch;\n+     map.push(i);\n+   }\n+ \n+   // Try exact match first.\n+   let startNorm = norm.indexOf(needle);\n+   let matchLen = needle.length;\n+ \n+   // Fallback: whitespace-flexible regex match against normalized string.\n+   if (startNorm === -1) {\n+     const pattern = escapeRegex(needle).replace(/\\s+/g, \"\\\\s+\");\n+     try {\n+       const re = new RegExp(pattern, \"m\");\n+       const match = re.exec(norm);\n+       if (!match || match.index == null) return null;\n+       startNorm = match.index;\n+       matchLen = match[0]?.length || needle.length;\n+     } catch {\n+       return null;\n+     }\n+   }\n+ \n+   const startMd = map[startNorm];\n+   const endMdExclusive = map[startNorm + matchLen - 1] != null ? map[startNorm + matchLen - 1] + 1 : null;\n+   if (startMd == null || endMdExclusive == null) return null;\n+ \n+   // Expand to keep bold delimiters balanced when the match intersects bold spans.\n+   let start = startMd;\n+   let end = endMdExclusive;\n+   for (let iter = 0; iter &lt; 6; iter++) {\n+     const segment = markdown.slice(start, end);\n+     if (countBoldDelimiters(segment) % 2 === 0) break;\n+     let changed = false;\n+     const tail = markdown.slice(end, end + 2);\n+     const head = start &gt;= 2 ? markdown.slice(start - 2, start) : \"\";\n+     if (tail === \"**\" || tail === \"__\") {\n+       end = Math.min(markdown.length, end + 2);\n+       changed = true;\n+     }\n+     if (head === \"**\" || head === \"__\") {\n+       start = Math.max(0, start - 2);\n+       changed = true;\n+     }\n+     if (!changed) break;\n+   }\n+ \n+   if (start &gt;= end) return null;\n+   return { start, end };\n+ };\n  \n  const stripAllTempHighlights = (content) =&gt; {",
        "oldStart": 45,
        "newStart": 45,
        "oldLines": 4,
        "newLines": 77,
        "linesAdded": 73
      },
      {
        "diffString": "      );\n    }\n+ \n+   const range = findSelectedRangeInMarkdown(cleaned, selectedText);\n+   if (range) {\n+     return (\n+       cleaned.slice(0, range.start) +\n+       start +\n+       cleaned.slice(range.start, range.end) +\n+       end +\n+       cleaned.slice(range.end)\n+     );\n+   }\n  \n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");",
        "oldStart": 69,
        "newStart": 142,
        "oldLines": 4,
        "newLines": 15,
        "linesAdded": 11
      },
      {
        "diffString": "      );\n    }\n+ \n+   const range = findSelectedRangeInMarkdown(content, selectedText);\n+   if (range) {\n+     return (\n+       content.slice(0, range.start) +\n+       start +\n+       content.slice(range.start, range.end) +\n+       end +\n+       content.slice(range.end)\n+     );\n+   }\n  \n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");",
        "oldStart": 129,
        "newStart": 213,
        "oldLines": 4,
        "newLines": 15,
        "linesAdded": 11
      },
      {
        "diffString": "      const nodeId = selectionPopover.nodeId;\n      const msgIdx = selectionPopover.messageIndex;\n+     let didInsert = false;\n      updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n+         const nextContent = wrapFirstMatchWithTempHighlight(\n+           m.content,\n+           selectionPopover.text,\n+           tempId,\n+         );\n+         if (nextContent.includes(&#96;${TEMP_HL_START}${tempId}]]]&#96;)) {\n+           didInsert = true;\n+         }\n          return {\n            ...m,\n-           content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n+           content: nextContent,\n          };\n        }),\n      );\n-     setTempHighlight({\n-       nodeId,\n-       messageIndex: msgIdx,\n-       tempId,\n-       treeId: selectionPopover.treeId,\n-     });\n-     window.getSelection()?.removeAllRanges?.();\n+     if (didInsert) {\n+       setTempHighlight({\n+         nodeId,\n+         messageIndex: msgIdx,\n+         tempId,\n+         treeId: selectionPopover.treeId,\n+       });\n+       // Only clear the native selection once we've successfully inserted a temp highlight.\n+       window.getSelection()?.removeAllRanges?.();\n+     }\n    }, [\n      selectionPopover.visible,",
        "oldStart": 912,
        "newStart": 1007,
        "oldLines": 20,
        "newLines": 32,
        "linesRemoved": 8,
        "linesAdded": 20
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst countBoldDelimiters = (value) =&gt; {\n  if (!value) return 0;\n  const matches = value.match(/(\\*\\*|__)/g);\n  return matches ? matches.length : 0;\n};\n\nconst findSelectedRangeInMarkdown = (markdown, selectedText) =&gt; {\n  if (!markdown || !selectedText) return null;\n  const needle = selectedText.trim();\n  if (!needle) return null;\n\n  // Build a normalized view of markdown that drops common emphasis delimiters.\n  // This lets DOM selections (which don't include '**') match the source markdown.\n  let norm = \"\";\n  const map = []; // norm index -&gt; markdown index\n  for (let i = 0; i &lt; markdown.length; i++) {\n    const ch = markdown[i];\n    const next = markdown[i + 1];\n    if ((ch === \"*\" &amp;&amp; next === \"*\") || (ch === \"_\" &amp;&amp; next === \"_\")) {\n      i += 1; // skip the pair\n      continue;\n    }\n    if (ch === \"*\" || ch === \"_\") continue;\n    norm += ch;\n    map.push(i);\n  }\n\n  // Try exact match first.\n  let startNorm = norm.indexOf(needle);\n  let matchLen = needle.length;\n\n  // Fallback: whitespace-flexible regex match against normalized string.\n  if (startNorm === -1) {\n    const pattern = escapeRegex(needle).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(norm);\n      if (!match || match.index == null) return null;\n      startNorm = match.index;\n      matchLen = match[0]?.length || needle.length;\n    } catch {\n      return null;\n    }\n  }\n\n  const startMd = map[startNorm];\n  const endMdExclusive = map[startNorm + matchLen - 1] != null ? map[startNorm + matchLen - 1] + 1 : null;\n  if (startMd == null || endMdExclusive == null) return null;\n\n  // Expand to keep bold delimiters balanced when the match intersects bold spans.\n  let start = startMd;\n  let end = endMdExclusive;\n  for (let iter = 0; iter &lt; 6; iter++) {\n    const segment = markdown.slice(start, end);\n    if (countBoldDelimiters(segment) % 2 === 0) break;\n    let changed = false;\n    const tail = markdown.slice(end, end + 2);\n    const head = start &gt;= 2 ? markdown.slice(start - 2, start) : \"\";\n    if (tail === \"**\" || tail === \"__\") {\n      end = Math.min(markdown.length, end + 2);\n      changed = true;\n    }\n    if (head === \"**\" || head === \"__\") {\n      start = Math.max(0, start - 2);\n      changed = true;\n    }\n    if (!changed) break;\n  }\n\n  if (start &gt;= end) return null;\n  return { start, end };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(cleaned, selectedText);\n  if (range) {\n    return (\n      cleaned.slice(0, range.start) +\n      start +\n      cleaned.slice(range.start, range.end) +\n      end +\n      cleaned.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(content, selectedText);\n  if (range) {\n    return (\n      content.slice(0, range.start) +\n      start +\n      content.slice(range.start, range.end) +\n      end +\n      content.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    // If the user deletes the last remaining tree, immediately replace it with a\n    // fresh \"New Tree\" and activate it (avoid a render where activeTreeId is null).\n    const isLastRemainingTree = Object.keys(treesById).length === 1;\n    if (isLastRemainingTree) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n      setGraphHasInteracted(false);\n      setGraphScale(1.4);\n      setGraphTranslate({ x: 0, y: 0 });\n      closeTreeMenu();\n      return;\n    }\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    let didInsert = false;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        const nextContent = wrapFirstMatchWithTempHighlight(\n          m.content,\n          selectionPopover.text,\n          tempId,\n        );\n        if (nextContent.includes(&#96;${TEMP_HL_START}${tempId}]]]&#96;)) {\n          didInsert = true;\n        }\n        return {\n          ...m,\n          content: nextContent,\n        };\n      }),\n    );\n    if (didInsert) {\n      setTempHighlight({\n        nodeId,\n        messageIndex: msgIdx,\n        tempId,\n        treeId: selectionPopover.treeId,\n      });\n      // Only clear the native selection once we've successfully inserted a temp highlight.\n      window.getSelection()?.removeAllRanges?.();\n    }\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const title = typeof node.title === \"string\" ? node.title : \"\";\n                  const words = title.split(\" \").filter(Boolean);\n                  const isPending = node.requestStatus === \"pending\";\n                  const isReady = node.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

Nice — this fixes the root cause: we can now find the selected text inside markdown even when it’s wrapped in `**...**`, and we only clear the browser selection if we actually inserted a temp highlight marker. Next I’ll run lints for `src/App.jsx` and then do a quick manual check path to ensure Shift-selection stays visible across bold spans.

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Make highlight remark plugin support temp/branch markers spanning across non-text nodes (e.g., bold)
- [x] Only clear native selection on Shift when temp highlight insertion succeeds; improve matching to tolerate markdown markers

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/.cursor/projects/Users-cosmo-Documents-projects-trees/terminals/1.txt</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Debugging identifier error**

I noticed an error in the Vite server indicating that the identifier updateNodeMessages has already been declared at line 868. This suggests we’ve introduced a variable with that name, but our patch didn’t involve that section. There might be an existing const that’s conflicting. I'm wondering if defining new helper functions inside a component has caused a scope shift? This could lead to a redeclaration issue. I’ll check lines around 820 to 900 to understand what’s going on.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "const\s+updateNodeMessages\b" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `const updateNodeMessages = (treeId, nodeId, updater) => \{` | L730 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Searching for function parameters**

It's interesting that there's only one occurrence of the identifier now, so I doubt there'd be a redeclaration error. I should still check if there's also a function parameter named `updateNodeMessages`. Let me search for the `updateNodeMessages` identifier in other contexts to clarify its usage and ensure I'm not missing anything. This might help prevent any issues later on!</details></think>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "\bupdateNodeMessages\b" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 0 matches</summary>

Output mode: count



</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Troubleshooting server issues**

I need to figure out why there's a duplicate constant error. It could be that the dev server didn't reload after our patch and is showing cached information. Even though it says there’s an update for /src/App.jsx, the error persists. Maybe the Babel parser is still using the old file. I think the error should disappear once the server is reloaded, so I'll check the terminal output for the latest updates to investigate further.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/.cursor/projects/Users-cosmo-Documents-projects-trees/terminals/1.txt</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "setNodesById\b" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Running build command**

I can run `npm run build` in a separate terminal to catch any syntax errors. It's a safe approach and doesn't take a long time, which is great. However, I need to consider network issues — maybe I should double-check that. Anyway, running it separately sounds like the best plan to make sure everything is working smoothly without interruptions. Time to get going on that!</details></think>

---

I’m seeing a stale Vite error in the running dev server logs that doesn’t match the current `App.jsx` contents (it references `setNodesById`, which isn’t in the file anymore). Next I’ll run a fresh `npm run build` to force a clean compile and confirm the workspace is now error-free.

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: cd /Users/cosmo/Documents/projects/trees && npm run build</summary>

```bash
cd /Users/cosmo/Documents/projects/trees && npm run build
```

```

&gt; trees@0.1.0 build
&gt; vite build

error during build:
Error: EPERM: operation not permitted, open '/Users/cosmo/Documents/projects/trees/.env'
    at Object.openSync (node:fs:561:18)
    at Object.readFileSync (node:fs:445:35)
    at file:///Users/cosmo/Documents/projects/trees/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:34908:51
    at Array.flatMap (&lt;anonymous&gt;)
    at loadEnv (file:///Users/cosmo/Documents/projects/trees/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:34906:14)
    at resolveConfig (file:///Users/cosmo/Documents/projects/trees/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:66486:53)
    at async build (file:///Users/cosmo/Documents/projects/trees/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:65503:18)
    at async CAC.&lt;anonymous&gt; (file:///Users/cosmo/Documents/projects/trees/node_modules/vite/dist/node/cli.js:829:5)

```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Troubleshooting build issues**

The build failed because the sandbox can't access the .env file, which might be ignored by the cursor. Running `vite build --mode production --envDir` could verify the compile, but it attempts to access .env. One option could be to delete .env or try running `node -c`, but that might not apply to JSX. I could use `npm run lint` since it doesn’t require .env. The compilation seems fine, so I’ll ensure any runtime errors aren’t from recent changes.
**Verifying selection effect**

I need to ensure the selection effect works properly. In `useEffect`, the `didInsert` variable is mutated inside a map callback, and `updateNodeMessages` is synchronous, calling `updateTreeNodes` which sets state. This means `didInsert` will be updated in line with the new state. I also need to check that the Shift keydown popover doesn’t clear the selection if insertion fails; it should maintain the selection. Lastly, I’ll confirm the styling for `.branch-highlight` to ensure it’s not dependent on the selection.
**Checking plugin functionality**

I need to ensure the `remarkBranchHighlights` plugin works even when markers wrap around bold tokens. Our changes only modify wrappers, not the plugin itself. The markers should wrap the entire markdown segment, including bold text. During markdown parsing, the marker tokens will be represented as plain text nodes outside the bold sections. However, if the markers wrap around `**` tokens, it means the selection includes them, transforming `Factor **B**` into `[[[sel:id]]]Factor **B**[[[/sel]]]`, with careful attention to how text nodes are handled.
**Updating remark plugin functionality**

Currently, the remark plugin only detects markers within a single text node by using `indexOf` for start and end markers. This means if the start marker is in one text node and the end marker is in another, the plugin won't be able to find and replace them, preventing highlights from rendering. We really need to update `remarkBranchHighlights` to manage markers that span multiple nodes, just as we initially planned. I need to adjust it to scan through node children, treating markers as tokens across all descendant nodes and converting them into link nodes. This will be complex, but it’s manageable!
**Implementing marker extraction**

For each parent node with children, I want to flatten inline content while ensuring we wrap portions across nodes. The transformation should occur within paragraph, heading, or list item nodes. In the markdown AST, emphasis nodes have children, and markers might appear at their boundaries.

To handle `[[[sel:...]]]` and `[[[/sel]]]` tokens that may split across nodes, I’m thinking of a state machine approach while iterating over children. Markers need detection even in nested formatting nodes, but ideally, I’ll run `extractHighlightsFromChildren(node.children)` on each node to insert highlights. This function will detect markers in text nodes, and using regex, it’ll parse to separate pieces for processing.
**Patching the highlight extraction logic**

I need to refine how we push text nodes and manage token markers in our highlight extraction logic. If we find a start marker, I'll split the content appropriately and collect necessary parts into an active buffer. When looking for an end marker, if it's not found, I should include original markers instead of losing content. 

Additionally, I’ll ensure our markers wrap around strong nodes correctly. Since the markdown parser doesn’t hold `**` text when creating strong nodes, my markers should be placed properly to maintain structure. Finally, I'll patch the `remarkBranchHighlights` function, updating its logic to implement these changes effectively. Let's proceed with the adjustments!</details></think>

---

Good catch: even with the markdown-aware matching, the highlight markers can now sit *around* a `strong` node, which means our current `remarkBranchHighlights` (text-node-only) won’t detect `[[[sel...]]]...[[[/sel]]]` when it spans bold. Next I’ll upgrade that remark plugin to “stitch” markers across sibling nodes (including `strong`), then the temp highlight will render correctly and the selection won’t vanish.

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Make highlight remark plugin support temp/branch markers spanning across non-text nodes (e.g., bold)
- [x] Only clear native selection on Shift when temp highlight insertion succeeds; improve matching to tolerate markdown markers

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "738fed18-8c14-4a95-8872-7c5f040d1b6c",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "738fed18-8c14-4a95-8872-7c5f040d1b6c",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst countBoldDelimiters = (value) =&gt; {\n  if (!value) return 0;\n  const matches = value.match(/(\\*\\*|__)/g);\n  return matches ? matches.length : 0;\n};\n\nconst findSelectedRangeInMarkdown = (markdown, selectedText) =&gt; {\n  if (!markdown || !selectedText) return null;\n  const needle = selectedText.trim();\n  if (!needle) return null;\n\n  // Build a normalized view of markdown that drops common emphasis delimiters.\n  // This lets DOM selections (which don't include '**') match the source markdown.\n  let norm = \"\";\n  const map = []; // norm index -&gt; markdown index\n  for (let i = 0; i &lt; markdown.length; i++) {\n    const ch = markdown[i];\n    const next = markdown[i + 1];\n    if ((ch === \"*\" &amp;&amp; next === \"*\") || (ch === \"_\" &amp;&amp; next === \"_\")) {\n      i += 1; // skip the pair\n      continue;\n    }\n    if (ch === \"*\" || ch === \"_\") continue;\n    norm += ch;\n    map.push(i);\n  }\n\n  // Try exact match first.\n  let startNorm = norm.indexOf(needle);\n  let matchLen = needle.length;\n\n  // Fallback: whitespace-flexible regex match against normalized string.\n  if (startNorm === -1) {\n    const pattern = escapeRegex(needle).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(norm);\n      if (!match || match.index == null) return null;\n      startNorm = match.index;\n      matchLen = match[0]?.length || needle.length;\n    } catch {\n      return null;\n    }\n  }\n\n  const startMd = map[startNorm];\n  const endMdExclusive = map[startNorm + matchLen - 1] != null ? map[startNorm + matchLen - 1] + 1 : null;\n  if (startMd == null || endMdExclusive == null) return null;\n\n  // Expand to keep bold delimiters balanced when the match intersects bold spans.\n  let start = startMd;\n  let end = endMdExclusive;\n  for (let iter = 0; iter &lt; 6; iter++) {\n    const segment = markdown.slice(start, end);\n    if (countBoldDelimiters(segment) % 2 === 0) break;\n    let changed = false;\n    const tail = markdown.slice(end, end + 2);\n    const head = start &gt;= 2 ? markdown.slice(start - 2, start) : \"\";\n    if (tail === \"**\" || tail === \"__\") {\n      end = Math.min(markdown.length, end + 2);\n      changed = true;\n    }\n    if (head === \"**\" || head === \"__\") {\n      start = Math.max(0, start - 2);\n      changed = true;\n    }\n    if (!changed) break;\n  }\n\n  if (start &gt;= end) return null;\n  return { start, end };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(cleaned, selectedText);\n  if (range) {\n    return (\n      cleaned.slice(0, range.start) +\n      start +\n      cleaned.slice(range.start, range.end) +\n      end +\n      cleaned.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(content, selectedText);\n  if (range) {\n    return (\n      content.slice(0, range.start) +\n      start +\n      content.slice(range.start, range.end) +\n      end +\n      content.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const parseStartMarker = (value, startIdx) =&gt; {\n    const isBranch = value.startsWith(BRANCH_HL_START, startIdx);\n    const isTemp = value.startsWith(TEMP_HL_START, startIdx);\n    if (!isBranch &amp;&amp; !isTemp) return null;\n    const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n    if (metaEndIdx === -1) return null;\n    const meta = value.slice(\n      startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n      metaEndIdx,\n    );\n    if (!meta) return null;\n    return {\n      kind: isBranch ? \"branch\" : \"temp\",\n      meta,\n      tokenStart: startIdx,\n      tokenEndExclusive: metaEndIdx + 3,\n    };\n  };\n\n  const splitByHighlightMarkers = (children) =&gt; {\n    const out = [];\n    let active = null; // { kind, meta, startToken, parts: [] }\n\n    const pushPart = (part) =&gt; {\n      if (!part) return;\n      if (active) active.parts.push(part);\n      else out.push(part);\n    };\n\n    const closeActive = () =&gt; {\n      if (!active) return;\n      const { kind, meta, parts } = active;\n      if (kind === \"branch\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          out.push({\n            type: \"link\",\n            url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n            children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n          });\n          active = null;\n          return;\n        }\n      } else if (kind === \"temp\") {\n        out.push({\n          type: \"link\",\n          url: &#96;temp-highlight:${meta}&#96;,\n          children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n        });\n        active = null;\n        return;\n      }\n\n      // Fallback: keep content and marker as literal text if meta is malformed.\n      out.push({ type: \"text\", value: active.startToken });\n      out.push(...parts);\n      active = null;\n    };\n\n    const flushUnclosed = () =&gt; {\n      if (!active) return;\n      out.push({ type: \"text\", value: active.startToken });\n      out.push(...active.parts);\n      active = null;\n    };\n\n    const handleTextValue = (value) =&gt; {\n      let rest = value;\n      while (rest) {\n        if (!active) {\n          const branchIdx = rest.indexOf(BRANCH_HL_START);\n          const tempIdx = rest.indexOf(TEMP_HL_START);\n          const startIdx =\n            branchIdx === -1\n              ? tempIdx\n              : tempIdx === -1\n                ? branchIdx\n                : Math.min(branchIdx, tempIdx);\n          if (startIdx === -1) {\n            pushPart({ type: \"text\", value: rest });\n            rest = \"\";\n            break;\n          }\n\n          const before = rest.slice(0, startIdx);\n          if (before) pushPart({ type: \"text\", value: before });\n\n          const parsed = parseStartMarker(rest, startIdx);\n          if (!parsed) {\n            // Not a valid marker; treat as literal.\n            pushPart({ type: \"text\", value: rest.slice(startIdx) });\n            rest = \"\";\n            break;\n          }\n\n          const startToken = rest.slice(parsed.tokenStart, parsed.tokenEndExclusive);\n          active = { kind: parsed.kind, meta: parsed.meta, startToken, parts: [] };\n          rest = rest.slice(parsed.tokenEndExclusive);\n          continue;\n        }\n\n        const endToken = active.kind === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n        const endIdx = rest.indexOf(endToken);\n        if (endIdx === -1) {\n          pushPart({ type: \"text\", value: rest });\n          rest = \"\";\n          break;\n        }\n\n        const inside = rest.slice(0, endIdx);\n        if (inside) pushPart({ type: \"text\", value: inside });\n        rest = rest.slice(endIdx + endToken.length);\n        closeActive();\n      }\n    };\n\n    for (const child of children) {\n      if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n        handleTextValue(child.value);\n        continue;\n      }\n      // Non-text nodes can be part of a highlight span (e.g. strong/emphasis).\n      pushPart(child);\n    }\n\n    flushUnclosed();\n    return out;\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      // First recursively transform.\n      node.children.forEach((child) =&gt; transformNode(child));\n      // Then stitch markers across sibling nodes (including strong/emphasis).\n      node.children = splitByHighlightMarkers(node.children);\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst deriveRootTitleFromFirstMessage = (text) =&gt; {\n  if (typeof text !== \"string\") return \"Root\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return \"Root\";\n\n  const firstLine = cleaned.split(/\\n+/)[0].trim();\n  const firstSentence = firstLine.split(/[.?!]/)[0].trim() || firstLine;\n  const words = firstSentence.split(/\\s+/).filter(Boolean);\n  const maxWords = 6;\n  const base = words.slice(0, maxWords).join(\" \");\n  const needsEllipsis = words.length &gt; maxWords || base.length &lt; firstSentence.length;\n  const candidate = needsEllipsis ? &#96;${base}…&#96; : base;\n\n  // Clamp for UI readability in node chips/breadcrumbs.\n  return truncateForContext(candidate, 44) || \"Root\";\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    // If the user deletes the last remaining tree, immediately replace it with a\n    // fresh \"New Tree\" and activate it (avoid a render where activeTreeId is null).\n    const isLastRemainingTree = Object.keys(treesById).length === 1;\n    if (isLastRemainingTree) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n      setGraphHasInteracted(false);\n      setGraphScale(1.4);\n      setGraphTranslate({ x: 0, y: 0 });\n      closeTreeMenu();\n      return;\n    }\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    let didInsert = false;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        const nextContent = wrapFirstMatchWithTempHighlight(\n          m.content,\n          selectionPopover.text,\n          tempId,\n        );\n        if (nextContent.includes(&#96;${TEMP_HL_START}${tempId}]]]&#96;)) {\n          didInsert = true;\n        }\n        return {\n          ...m,\n          content: nextContent,\n        };\n      }),\n    );\n    if (didInsert) {\n      setTempHighlight({\n        nodeId,\n        messageIndex: msgIdx,\n        tempId,\n        treeId: selectionPopover.treeId,\n      });\n      // Only clear the native selection once we've successfully inserted a temp highlight.\n      window.getSelection()?.removeAllRanges?.();\n    }\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    if (isFirstRootTurn) {\n      const nextRootTitle = deriveRootTitleFromFirstMessage(trimmed);\n      updateNode(treeIdSnapshot, \"root\", (node) =&gt; {\n        // Don't override if the user already named it (or it was restored from storage).\n        if (node?.title &amp;&amp; node.title !== \"Root\") return node;\n        return { ...node, title: nextRootTitle };\n      });\n    }\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const title = typeof node.title === \"string\" ? node.title : \"\";\n                  const words = title.split(\" \").filter(Boolean);\n                  const isPending = node.requestStatus === \"pending\";\n                  const isReady = node.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  \n  const remarkBranchHighlights = () =&gt; {\n-   const transformNode = (node) =&gt; {\n-     if (!node || typeof node !== \"object\") return;\n-     if (Array.isArray(node.children)) {\n-       const nextChildren = [];\n-       node.children.forEach((child) =&gt; {\n-         if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n-           let value = child.value;\n-           while (true) {\n-             const branchIdx = value.indexOf(BRANCH_HL_START);\n-             const tempIdx = value.indexOf(TEMP_HL_START);\n-             const startIdx =\n-               branchIdx === -1\n-                 ? tempIdx\n-                 : tempIdx === -1\n-                   ? branchIdx\n-                   : Math.min(branchIdx, tempIdx);\n-             if (startIdx === -1) break;\n-             const isBranch = startIdx === branchIdx;\n-             const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n-             if (metaEndIdx === -1) break;\n-             const meta = value.slice(\n-               startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n-               metaEndIdx,\n-             );\n-             const contentStartIdx = metaEndIdx + 3;\n-             const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n-             if (endIdx === -1) break;\n- \n-             const before = value.slice(0, startIdx);\n-             const inside = value.slice(contentStartIdx, endIdx);\n-             const after = value.slice(\n-               endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n-             );\n- \n-             if (before) nextChildren.push({ type: \"text\", value: before });\n-             if (isBranch) {\n-               const [highlightId, branchNodeId] = meta.split(\":\");\n-               if (!highlightId || !branchNodeId) break;\n-               nextChildren.push({\n-                 type: \"link\",\n-                 url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n-                 children: [{ type: \"text\", value: inside }],\n-               });\n-             } else {\n-               const tempId = meta;\n-               if (!tempId) break;\n-               nextChildren.push({\n-                 type: \"link\",\n-                 url: &#96;temp-highlight:${tempId}&#96;,\n-                 children: [{ type: \"text\", value: inside }],\n-               });\n-             }\n- \n-             value = after;\n-           }\n- \n-           if (value) {\n-             nextChildren.push({ ...child, value });\n-           }\n-           return;\n+   const parseStartMarker = (value, startIdx) =&gt; {\n+     const isBranch = value.startsWith(BRANCH_HL_START, startIdx);\n+     const isTemp = value.startsWith(TEMP_HL_START, startIdx);\n+     if (!isBranch &amp;&amp; !isTemp) return null;\n+     const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n+     if (metaEndIdx === -1) return null;\n+     const meta = value.slice(\n+       startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n+       metaEndIdx,\n+     );\n+     if (!meta) return null;\n+     return {\n+       kind: isBranch ? \"branch\" : \"temp\",\n+       meta,\n+       tokenStart: startIdx,\n+       tokenEndExclusive: metaEndIdx + 3,\n+     };\n+   };\n+ \n+   const splitByHighlightMarkers = (children) =&gt; {\n+     const out = [];\n+     let active = null; // { kind, meta, startToken, parts: [] }\n+ \n+     const pushPart = (part) =&gt; {\n+       if (!part) return;\n+       if (active) active.parts.push(part);\n+       else out.push(part);\n+     };\n+ \n+     const closeActive = () =&gt; {\n+       if (!active) return;\n+       const { kind, meta, parts } = active;\n+       if (kind === \"branch\") {\n+         const [highlightId, branchNodeId] = meta.split(\":\");\n+         if (highlightId &amp;&amp; branchNodeId) {\n+           out.push({\n+             type: \"link\",\n+             url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n+             children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n+           });\n+           active = null;\n+           return;\n+         }\n+       } else if (kind === \"temp\") {\n+         out.push({\n+           type: \"link\",\n+           url: &#96;temp-highlight:${meta}&#96;,\n+           children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n+         });\n+         active = null;\n+         return;\n+       }\n+ \n+       // Fallback: keep content and marker as literal text if meta is malformed.\n+       out.push({ type: \"text\", value: active.startToken });\n+       out.push(...parts);\n+       active = null;\n+     };\n+ \n+     const flushUnclosed = () =&gt; {\n+       if (!active) return;\n+       out.push({ type: \"text\", value: active.startToken });\n+       out.push(...active.parts);\n+       active = null;\n+     };\n+ \n+     const handleTextValue = (value) =&gt; {\n+       let rest = value;\n+       while (rest) {\n+         if (!active) {\n+           const branchIdx = rest.indexOf(BRANCH_HL_START);\n+           const tempIdx = rest.indexOf(TEMP_HL_START);\n+           const startIdx =\n+             branchIdx === -1\n+               ? tempIdx\n+               : tempIdx === -1\n+                 ? branchIdx\n+                 : Math.min(branchIdx, tempIdx);\n+           if (startIdx === -1) {\n+             pushPart({ type: \"text\", value: rest });\n+             rest = \"\";\n+             break;\n+           }\n+ \n+           const before = rest.slice(0, startIdx);\n+           if (before) pushPart({ type: \"text\", value: before });\n+ \n+           const parsed = parseStartMarker(rest, startIdx);\n+           if (!parsed) {\n+             // Not a valid marker; treat as literal.\n+             pushPart({ type: \"text\", value: rest.slice(startIdx) });\n+             rest = \"\";\n+             break;\n+           }\n+ \n+           const startToken = rest.slice(parsed.tokenStart, parsed.tokenEndExclusive);\n+           active = { kind: parsed.kind, meta: parsed.meta, startToken, parts: [] };\n+           rest = rest.slice(parsed.tokenEndExclusive);\n+           continue;\n+         }\n+ \n+         const endToken = active.kind === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n+         const endIdx = rest.indexOf(endToken);\n+         if (endIdx === -1) {\n+           pushPart({ type: \"text\", value: rest });\n+           rest = \"\";\n+           break;\n          }\n  \n-         transformNode(child);\n-         nextChildren.push(child);\n-       });\n-       node.children = nextChildren;\n+         const inside = rest.slice(0, endIdx);\n+         if (inside) pushPart({ type: \"text\", value: inside });\n+         rest = rest.slice(endIdx + endToken.length);\n+         closeActive();\n+       }\n+     };\n+ \n+     for (const child of children) {\n+       if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n+         handleTextValue(child.value);\n+         continue;\n+       }\n+       // Non-text nodes can be part of a highlight span (e.g. strong/emphasis).\n+       pushPart(child);\n+     }\n+ \n+     flushUnclosed();\n+     return out;\n+   };\n+ \n+   const transformNode = (node) =&gt; {\n+     if (!node || typeof node !== \"object\") return;\n+     if (Array.isArray(node.children)) {\n+       // First recursively transform.\n+       node.children.forEach((child) =&gt; transformNode(child));\n+       // Then stitch markers across sibling nodes (including strong/emphasis).\n+       node.children = splitByHighlightMarkers(node.children);\n        return;\n      }",
        "oldStart": 244,
        "newStart": 244,
        "oldLines": 70,
        "newLines": 140,
        "linesRemoved": 64,
        "linesAdded": 134
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst countBoldDelimiters = (value) =&gt; {\n  if (!value) return 0;\n  const matches = value.match(/(\\*\\*|__)/g);\n  return matches ? matches.length : 0;\n};\n\nconst findSelectedRangeInMarkdown = (markdown, selectedText) =&gt; {\n  if (!markdown || !selectedText) return null;\n  const needle = selectedText.trim();\n  if (!needle) return null;\n\n  // Build a normalized view of markdown that drops common emphasis delimiters.\n  // This lets DOM selections (which don't include '**') match the source markdown.\n  let norm = \"\";\n  const map = []; // norm index -&gt; markdown index\n  for (let i = 0; i &lt; markdown.length; i++) {\n    const ch = markdown[i];\n    const next = markdown[i + 1];\n    if ((ch === \"*\" &amp;&amp; next === \"*\") || (ch === \"_\" &amp;&amp; next === \"_\")) {\n      i += 1; // skip the pair\n      continue;\n    }\n    if (ch === \"*\" || ch === \"_\") continue;\n    norm += ch;\n    map.push(i);\n  }\n\n  // Try exact match first.\n  let startNorm = norm.indexOf(needle);\n  let matchLen = needle.length;\n\n  // Fallback: whitespace-flexible regex match against normalized string.\n  if (startNorm === -1) {\n    const pattern = escapeRegex(needle).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(norm);\n      if (!match || match.index == null) return null;\n      startNorm = match.index;\n      matchLen = match[0]?.length || needle.length;\n    } catch {\n      return null;\n    }\n  }\n\n  const startMd = map[startNorm];\n  const endMdExclusive = map[startNorm + matchLen - 1] != null ? map[startNorm + matchLen - 1] + 1 : null;\n  if (startMd == null || endMdExclusive == null) return null;\n\n  // Expand to keep bold delimiters balanced when the match intersects bold spans.\n  let start = startMd;\n  let end = endMdExclusive;\n  for (let iter = 0; iter &lt; 6; iter++) {\n    const segment = markdown.slice(start, end);\n    if (countBoldDelimiters(segment) % 2 === 0) break;\n    let changed = false;\n    const tail = markdown.slice(end, end + 2);\n    const head = start &gt;= 2 ? markdown.slice(start - 2, start) : \"\";\n    if (tail === \"**\" || tail === \"__\") {\n      end = Math.min(markdown.length, end + 2);\n      changed = true;\n    }\n    if (head === \"**\" || head === \"__\") {\n      start = Math.max(0, start - 2);\n      changed = true;\n    }\n    if (!changed) break;\n  }\n\n  if (start &gt;= end) return null;\n  return { start, end };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(cleaned, selectedText);\n  if (range) {\n    return (\n      cleaned.slice(0, range.start) +\n      start +\n      cleaned.slice(range.start, range.end) +\n      end +\n      cleaned.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(content, selectedText);\n  if (range) {\n    return (\n      content.slice(0, range.start) +\n      start +\n      content.slice(range.start, range.end) +\n      end +\n      content.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const parseStartMarker = (value, startIdx) =&gt; {\n    const isBranch = value.startsWith(BRANCH_HL_START, startIdx);\n    const isTemp = value.startsWith(TEMP_HL_START, startIdx);\n    if (!isBranch &amp;&amp; !isTemp) return null;\n    const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n    if (metaEndIdx === -1) return null;\n    const meta = value.slice(\n      startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n      metaEndIdx,\n    );\n    if (!meta) return null;\n    return {\n      kind: isBranch ? \"branch\" : \"temp\",\n      meta,\n      tokenStart: startIdx,\n      tokenEndExclusive: metaEndIdx + 3,\n    };\n  };\n\n  const splitByHighlightMarkers = (children) =&gt; {\n    const out = [];\n    let active = null; // { kind, meta, startToken, parts: [] }\n\n    const pushPart = (part) =&gt; {\n      if (!part) return;\n      if (active) active.parts.push(part);\n      else out.push(part);\n    };\n\n    const closeActive = () =&gt; {\n      if (!active) return;\n      const { kind, meta, parts } = active;\n      if (kind === \"branch\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          out.push({\n            type: \"link\",\n            url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n            children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n          });\n          active = null;\n          return;\n        }\n      } else if (kind === \"temp\") {\n        out.push({\n          type: \"link\",\n          url: &#96;temp-highlight:${meta}&#96;,\n          children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n        });\n        active = null;\n        return;\n      }\n\n      // Fallback: keep content and marker as literal text if meta is malformed.\n      out.push({ type: \"text\", value: active.startToken });\n      out.push(...parts);\n      active = null;\n    };\n\n    const flushUnclosed = () =&gt; {\n      if (!active) return;\n      out.push({ type: \"text\", value: active.startToken });\n      out.push(...active.parts);\n      active = null;\n    };\n\n    const handleTextValue = (value) =&gt; {\n      let rest = value;\n      while (rest) {\n        if (!active) {\n          const branchIdx = rest.indexOf(BRANCH_HL_START);\n          const tempIdx = rest.indexOf(TEMP_HL_START);\n          const startIdx =\n            branchIdx === -1\n              ? tempIdx\n              : tempIdx === -1\n                ? branchIdx\n                : Math.min(branchIdx, tempIdx);\n          if (startIdx === -1) {\n            pushPart({ type: \"text\", value: rest });\n            rest = \"\";\n            break;\n          }\n\n          const before = rest.slice(0, startIdx);\n          if (before) pushPart({ type: \"text\", value: before });\n\n          const parsed = parseStartMarker(rest, startIdx);\n          if (!parsed) {\n            // Not a valid marker; treat as literal.\n            pushPart({ type: \"text\", value: rest.slice(startIdx) });\n            rest = \"\";\n            break;\n          }\n\n          const startToken = rest.slice(parsed.tokenStart, parsed.tokenEndExclusive);\n          active = { kind: parsed.kind, meta: parsed.meta, startToken, parts: [] };\n          rest = rest.slice(parsed.tokenEndExclusive);\n          continue;\n        }\n\n        const endToken = active.kind === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n        const endIdx = rest.indexOf(endToken);\n        if (endIdx === -1) {\n          pushPart({ type: \"text\", value: rest });\n          rest = \"\";\n          break;\n        }\n\n        const inside = rest.slice(0, endIdx);\n        if (inside) pushPart({ type: \"text\", value: inside });\n        rest = rest.slice(endIdx + endToken.length);\n        closeActive();\n      }\n    };\n\n    for (const child of children) {\n      if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n        handleTextValue(child.value);\n        continue;\n      }\n      // Non-text nodes can be part of a highlight span (e.g. strong/emphasis).\n      pushPart(child);\n    }\n\n    flushUnclosed();\n    return out;\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      // First recursively transform.\n      node.children.forEach((child) =&gt; transformNode(child));\n      // Then stitch markers across sibling nodes (including strong/emphasis).\n      node.children = splitByHighlightMarkers(node.children);\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst deriveRootTitleFromFirstMessage = (text) =&gt; {\n  if (typeof text !== \"string\") return \"Root\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return \"Root\";\n\n  const firstLine = cleaned.split(/\\n+/)[0].trim();\n  const firstSentence = firstLine.split(/[.?!]/)[0].trim() || firstLine;\n  const words = firstSentence.split(/\\s+/).filter(Boolean);\n  const maxWords = 6;\n  const base = words.slice(0, maxWords).join(\" \");\n  const needsEllipsis = words.length &gt; maxWords || base.length &lt; firstSentence.length;\n  const candidate = needsEllipsis ? &#96;${base}…&#96; : base;\n\n  // Clamp for UI readability in node chips/breadcrumbs.\n  return truncateForContext(candidate, 44) || \"Root\";\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    // If the user deletes the last remaining tree, immediately replace it with a\n    // fresh \"New Tree\" and activate it (avoid a render where activeTreeId is null).\n    const isLastRemainingTree = Object.keys(treesById).length === 1;\n    if (isLastRemainingTree) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n      setGraphHasInteracted(false);\n      setGraphScale(1.4);\n      setGraphTranslate({ x: 0, y: 0 });\n      closeTreeMenu();\n      return;\n    }\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    let didInsert = false;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        const nextContent = wrapFirstMatchWithTempHighlight(\n          m.content,\n          selectionPopover.text,\n          tempId,\n        );\n        if (nextContent.includes(&#96;${TEMP_HL_START}${tempId}]]]&#96;)) {\n          didInsert = true;\n        }\n        return {\n          ...m,\n          content: nextContent,\n        };\n      }),\n    );\n    if (didInsert) {\n      setTempHighlight({\n        nodeId,\n        messageIndex: msgIdx,\n        tempId,\n        treeId: selectionPopover.treeId,\n      });\n      // Only clear the native selection once we've successfully inserted a temp highlight.\n      window.getSelection()?.removeAllRanges?.();\n    }\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    if (isFirstRootTurn) {\n      const nextRootTitle = deriveRootTitleFromFirstMessage(trimmed);\n      updateNode(treeIdSnapshot, \"root\", (node) =&gt; {\n        // Don't override if the user already named it (or it was restored from storage).\n        if (node?.title &amp;&amp; node.title !== \"Root\") return node;\n        return { ...node, title: nextRootTitle };\n      });\n    }\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const title = typeof node.title === \"string\" ? node.title : \"\";\n                  const words = title.split(\" \").filter(Boolean);\n                  const isPending = node.requestStatus === \"pending\";\n                  const isReady = node.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Make highlight remark plugin support temp/branch markers spanning across non-text nodes (e.g., bold)
- [x] Only clear native selection on Shift when temp highlight insertion succeeds; improve matching to tolerate markdown markers

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "remarkBranchHighlights\s*=|const\s+remarkBranchHighlights" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `const remarkBranchHighlights = () => \{` | L245 |


</details>
</tool-use>

---

### Fixed
- **Shift selection no longer “disappears” when the selection includes bold text**.
- **Temp/branch highlights now render even when the highlighted span crosses formatting nodes** (like `**bold**` / `strong`).

### What changed (high-level)
- **Markdown-aware matching**: `wrapFirstMatchWithTempHighlight` / `wrapFirstMatchWithBranchHighlight` can now find a DOM selection inside markdown that contains `**...**`.
- **Non-destructive selection clearing**: we only call `window.getSelection()?.removeAllRanges()` after we *successfully* inserted a temp highlight marker.
- **Better remark plugin**: `remarkBranchHighlights` now “stitches” `[[[sel...]]]...[[[/sel]]]` and `[[[hl...]]]...[[[/hl]]]` markers across sibling nodes (so it works when the highlight spans a `strong` node).

### Files touched
- `src/App.jsx`

---

_**User (2026-01-18 16:02Z)**_

once I've done a highlight the markdown shows up which we dont want [[[hl:41325963-14a9-4851-b1d5-d69383905c0d:228912a9-7fbb-4682-9b60-69212d84b129]]]lipopolysaccharide (LPS)[[[/hl]]]

---

_**Agent (model gpt-5.2, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Reviewing ReactMarkdown Setup**

I need to check the section where ReactMarkdown is set up to make sure that the remarkPlugins array includes remarkBranchHighlights. I’ll focus on that specific configuration without invoking any changes just yet. It seems essential to have that properly included for the expected functionality. I'm curious about how the message content area interacts with this setup, so I'll pay attention to how everything is structured there. Let's make sure it's all correct!</details></think>

---

Got it — those `[[[hl:...]]]` markers should never be visible. That means our remark transform isn’t reliably converting them into the highlight span in some markdown shapes. Next I’ll inspect the markdown render pipeline (`ReactMarkdown` + `remarkBranchHighlights`) and patch the plugin to *always* consume the markers (even when nested), so the raw tokens can’t leak to the UI.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "remarkPlugins=\{|remarkPlugins=\[|remarkPlugins" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `remarkPlugins=\{[` | L1883 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "urlTransform=\(\)|urlTransform" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `urlTransform=\{(url) => url\}` | L1891 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating code issues**

I see that the `read_file` snippet shows an outdated version of `remarkBranchHighlights`, which is concerning since we applied a patch earlier. The code around line 245 indicates it hasn't been updated. It might be that the `read_file` function is grabbing old lines due to its offset. We previously detected a duplicate definition, which suggests the patch didn't stick. I need to check for potential merge conflicts or duplicate definitions by searching for `parseStartMarker` or `splitByHighlightMarkers`.</details></think>

---

Nice find: `src/App.jsx` currently contains the **old** `remarkBranchHighlights` implementation (text-node-only), which explains why your `[[[hl:...]]]` tokens are leaking into the rendered markdown. Next I’ll locate the duplicate/old definition and replace it with the new “stitching” version so the markers are always consumed.

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "parseStartMarker|splitByHighlightMarkers|stitch" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "const\s+remarkBranchHighlights\s*=\s*\(\)\s*=>" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `const remarkBranchHighlights = () => \{` | L245 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "\[\[\[hl:|\[\[\[/hl\]\]\]|\[\[\[sel:|\[\[\[/sel\]\]\]" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 0 matches</summary>

Output mode: count



</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating patch issues**

It seems that the patch for remarkBranchHighlights didn't persist as expected; it reverted to an old version. I wonder if the apply_patch command failed because the file might have changed afterward. Earlier, we saw success. Now, grep indicates no parseStartMarker, so it’s possible we edited the wrong file despite it saying it was updated. There might be merge conflicts resolved by the user, or an external process could have reverted the file. I should reapply the new plugin by replacing the existing remarkBranchHighlights with the stitching version and be careful to ensure it doesn’t break anything else.
**Implementing code transformations**

I'm planning to use the same code as before but make sure there are no undefined values this time. I’ll maintain transformations for both start and end markers across multiple nodes while ensuring we don't mistakenly treat markers inside code blocks, like inlineCode and code. The previous plugin may have improperly captured markers within code. I want to preserve the old behavior but avoid misrendering. So, I’ll add a guard to skip nodes of type 'code' or 'inlineCode.' Now, I’ll implement the function to parse markers as needed.
**Handling markers in text**

When I encounter a start marker in the text, I create an active state and push it to the active parts. If I find an end marker while active, I close that state, including any non-text nodes during that time. I’m thinking about how to handle a scenario where a start marker is in one text node but continues in the next. It’s likely not an issue since the marker shouldn't split across nodes, but it could happen with emphasis. Based on earlier range expansion, markers should stay within a single text node.
**Implementing text processing**

I’m working on the implementation details for processing text segments. First, if there are markers in the string, I check if I'm not active and look for the earliest occurrences of BRANCH_HL_START or TEMP_HL_START. If I find one, I push the preceding text and then try to parse the marker by finding "]]]" for metadata. If that’s missing, I push the rest of the string as text and break.

If I'm active, I check for the end token. If not found, I push the whole string to active.parts and break too. If I find it, I advance, close the active state, and push the link node to the output. Lastly, if the string is empty, I return.
**Iterating through children nodes**

For the children iteration, I'll check each child. If the child's type is 'text', I’ll call processTextSegments on its value. If it’s not a text node, I need to handle it based on whether I am active. If I am, I push the child to active.parts; otherwise, I just add it to the output.

I must also consider children of children since I want to allow active highlights to span nested nodes, such as strong nodes. I’ll transform each child recursively first. If the active highlight begins in a text node, goes through a strong node, and ends in another text node, I’ll push that strong node as part of the output. When creating a link node, its children will be the already transformed parts. 

In mdast, link children can include phrasingContent like strong, text, inlineCode, etc., and there's a possibility to include links too. I must be cautious about edge cases, like if closeActive is called but the metadata is invalid, as I would need to fall back to the output of the startToken plus parts. After processing, if the active state is still open, I’ll make sure to flush unclosed entries. 

Ultimately, my goal is to ensure no markers show up as users see well-formed tokens, especially after applying this patch. I'll go ahead and patch the code accordingly!</details></think>

---

Plan: replace the current `remarkBranchHighlights` (which only handles single text nodes) with the “stitching” version that consumes `[[[hl...]]]...[[[/hl]]]` even when the span includes `**bold**` nodes. Then I’ll re-run lints and sanity-check that a new highlight renders as the yellow pill without showing raw tokens.

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "04607722-592a-4320-8909-07b133ca067d",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "04607722-592a-4320-8909-07b133ca067d",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst countBoldDelimiters = (value) =&gt; {\n  if (!value) return 0;\n  const matches = value.match(/(\\*\\*|__)/g);\n  return matches ? matches.length : 0;\n};\n\nconst findSelectedRangeInMarkdown = (markdown, selectedText) =&gt; {\n  if (!markdown || !selectedText) return null;\n  const needle = selectedText.trim();\n  if (!needle) return null;\n\n  // Build a normalized view of markdown that drops common emphasis delimiters.\n  // This lets DOM selections (which don't include '**') match the source markdown.\n  let norm = \"\";\n  const map = []; // norm index -&gt; markdown index\n  for (let i = 0; i &lt; markdown.length; i++) {\n    const ch = markdown[i];\n    const next = markdown[i + 1];\n    if ((ch === \"*\" &amp;&amp; next === \"*\") || (ch === \"_\" &amp;&amp; next === \"_\")) {\n      i += 1; // skip the pair\n      continue;\n    }\n    if (ch === \"*\" || ch === \"_\") continue;\n    norm += ch;\n    map.push(i);\n  }\n\n  // Try exact match first.\n  let startNorm = norm.indexOf(needle);\n  let matchLen = needle.length;\n\n  // Fallback: whitespace-flexible regex match against normalized string.\n  if (startNorm === -1) {\n    const pattern = escapeRegex(needle).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(norm);\n      if (!match || match.index == null) return null;\n      startNorm = match.index;\n      matchLen = match[0]?.length || needle.length;\n    } catch {\n      return null;\n    }\n  }\n\n  const startMd = map[startNorm];\n  const endMdExclusive = map[startNorm + matchLen - 1] != null ? map[startNorm + matchLen - 1] + 1 : null;\n  if (startMd == null || endMdExclusive == null) return null;\n\n  // Expand to keep bold delimiters balanced when the match intersects bold spans.\n  let start = startMd;\n  let end = endMdExclusive;\n  for (let iter = 0; iter &lt; 6; iter++) {\n    const segment = markdown.slice(start, end);\n    if (countBoldDelimiters(segment) % 2 === 0) break;\n    let changed = false;\n    const tail = markdown.slice(end, end + 2);\n    const head = start &gt;= 2 ? markdown.slice(start - 2, start) : \"\";\n    if (tail === \"**\" || tail === \"__\") {\n      end = Math.min(markdown.length, end + 2);\n      changed = true;\n    }\n    if (head === \"**\" || head === \"__\") {\n      start = Math.max(0, start - 2);\n      changed = true;\n    }\n    if (!changed) break;\n  }\n\n  if (start &gt;= end) return null;\n  return { start, end };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(cleaned, selectedText);\n  if (range) {\n    return (\n      cleaned.slice(0, range.start) +\n      start +\n      cleaned.slice(range.start, range.end) +\n      end +\n      cleaned.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(content, selectedText);\n  if (range) {\n    return (\n      content.slice(0, range.start) +\n      start +\n      content.slice(range.start, range.end) +\n      end +\n      content.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const parseStartMarker = (value) =&gt; {\n    const branchIdx = value.indexOf(BRANCH_HL_START);\n    const tempIdx = value.indexOf(TEMP_HL_START);\n    const startIdx =\n      branchIdx === -1\n        ? tempIdx\n        : tempIdx === -1\n          ? branchIdx\n          : Math.min(branchIdx, tempIdx);\n    if (startIdx === -1) return null;\n\n    const isBranch = startIdx === branchIdx;\n    const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n    if (metaEndIdx === -1) return null;\n\n    const meta = value.slice(\n      startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n      metaEndIdx,\n    );\n    if (!meta) return null;\n\n    return {\n      kind: isBranch ? \"branch\" : \"temp\",\n      meta,\n      startIdx,\n      tokenEndExclusive: metaEndIdx + 3,\n    };\n  };\n\n  const splitByHighlightMarkers = (children) =&gt; {\n    const out = [];\n    let active = null; // { kind, meta, startToken, parts: [] }\n\n    const pushPart = (part) =&gt; {\n      if (!part) return;\n      if (active) active.parts.push(part);\n      else out.push(part);\n    };\n\n    const closeActive = () =&gt; {\n      if (!active) return;\n      const { kind, meta, parts, startToken } = active;\n      if (kind === \"branch\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          out.push({\n            type: \"link\",\n            url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n            children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n          });\n          active = null;\n          return;\n        }\n      } else {\n        out.push({\n          type: \"link\",\n          url: &#96;temp-highlight:${meta}&#96;,\n          children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n        });\n        active = null;\n        return;\n      }\n\n      // Malformed marker: keep literal content.\n      out.push({ type: \"text\", value: startToken });\n      out.push(...parts);\n      active = null;\n    };\n\n    const flushUnclosed = () =&gt; {\n      if (!active) return;\n      out.push({ type: \"text\", value: active.startToken });\n      out.push(...active.parts);\n      active = null;\n    };\n\n    const handleTextValue = (value) =&gt; {\n      let rest = value;\n      while (rest) {\n        if (!active) {\n          const parsed = parseStartMarker(rest);\n          if (!parsed) {\n            pushPart({ type: \"text\", value: rest });\n            rest = \"\";\n            break;\n          }\n\n          const before = rest.slice(0, parsed.startIdx);\n          if (before) pushPart({ type: \"text\", value: before });\n\n          const startToken = rest.slice(parsed.startIdx, parsed.tokenEndExclusive);\n          active = { kind: parsed.kind, meta: parsed.meta, startToken, parts: [] };\n          rest = rest.slice(parsed.tokenEndExclusive);\n          continue;\n        }\n\n        const endToken = active.kind === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n        const endIdx = rest.indexOf(endToken);\n        if (endIdx === -1) {\n          pushPart({ type: \"text\", value: rest });\n          rest = \"\";\n          break;\n        }\n\n        const inside = rest.slice(0, endIdx);\n        if (inside) pushPart({ type: \"text\", value: inside });\n        rest = rest.slice(endIdx + endToken.length);\n        closeActive();\n      }\n    };\n\n    for (const child of children) {\n      if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n        handleTextValue(child.value);\n        continue;\n      }\n      // Allow highlights to span across non-text nodes like strong/emphasis.\n      pushPart(child);\n    }\n\n    flushUnclosed();\n    return out;\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (node.type === \"code\" || node.type === \"inlineCode\") return;\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child));\n      node.children = splitByHighlightMarkers(node.children);\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  // &#96;hoveredBranchNodeId&#96; is used for both:\n  // - hovering a branch-highlight inside the message thread\n  // - hovering a node in the tree list / graph\n  // Fast pointer movement and/or DOM re-renders can sometimes skip &#96;mouseleave&#96; for the highlight,\n  // so we track the source and apply extra cleanup only for highlight-hover.\n  const [hoveredBranchNodeSource, setHoveredBranchNodeSource] = useState(null); // \"highlight\" | \"node\" | null\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n\n  useEffect(() =&gt; {\n    // If the selection popover opens while hovering a branch-highlight, we disable hover effects.\n    // Ensure we also clear the global hovered branch state so the \"extra\" hover highlight doesn't stick.\n    if (!selectionPopover.visible) return;\n    if (hoveredBranchNodeSource !== \"highlight\") return;\n    setHoveredBranchNodeId(null);\n    setHoveredBranchNodeSource(null);\n  }, [selectionPopover.visible, hoveredBranchNodeSource]);\n\n  useEffect(() =&gt; {\n    // Robust cleanup for highlight-hover: if we stop actually hovering/focusing the element\n    // (or it unmounts), clear the hover state.\n    if (!hoveredBranchNodeId) return;\n    if (hoveredBranchNodeSource !== \"highlight\") return;\n\n    const escapeAttrValue = (value) =&gt;\n      String(value).replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"');\n\n    let raf = null;\n    const check = () =&gt; {\n      raf = null;\n      const selector = &#96;.branch-highlight[data-branch-node-id=\"${escapeAttrValue(\n        hoveredBranchNodeId,\n      )}\"]&#96;;\n      const el = document.querySelector(selector);\n      if (!el) {\n        setHoveredBranchNodeId(null);\n        setHoveredBranchNodeSource(null);\n        return;\n      }\n      const isHovered = el.matches(\":hover\");\n      const isFocused = document.activeElement === el;\n      if (!isHovered &amp;&amp; !isFocused) {\n        setHoveredBranchNodeId(null);\n        setHoveredBranchNodeSource(null);\n      }\n    };\n\n    const schedule = () =&gt; {\n      if (raf != null) return;\n      raf = requestAnimationFrame(check);\n    };\n\n    // Run once (covers the unmount-without-mouseleave case immediately).\n    schedule();\n\n    window.addEventListener(\"pointermove\", schedule, { passive: true });\n    window.addEventListener(\"pointerdown\", schedule, { passive: true });\n    window.addEventListener(\"scroll\", schedule, true);\n    window.addEventListener(\"blur\", schedule);\n\n    return () =&gt; {\n      if (raf != null) cancelAnimationFrame(raf);\n      window.removeEventListener(\"pointermove\", schedule);\n      window.removeEventListener(\"pointerdown\", schedule);\n      window.removeEventListener(\"scroll\", schedule, true);\n      window.removeEventListener(\"blur\", schedule);\n    };\n  }, [hoveredBranchNodeId, hoveredBranchNodeSource]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeSource(\"highlight\");\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n                setHoveredBranchNodeSource(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeSource(\"highlight\");\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n                setHoveredBranchNodeSource(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    // If the user deletes the last remaining tree, immediately replace it with a\n    // fresh \"New Tree\" and activate it (avoid a render where activeTreeId is null).\n    const isLastRemainingTree = Object.keys(treesById).length === 1;\n    if (isLastRemainingTree) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n      setGraphHasInteracted(false);\n      setGraphScale(1.4);\n      setGraphTranslate({ x: 0, y: 0 });\n      closeTreeMenu();\n      return;\n    }\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setHoveredBranchNodeSource(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    let didInsert = false;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        const nextContent = wrapFirstMatchWithTempHighlight(\n          m.content,\n          selectionPopover.text,\n          tempId,\n        );\n        if (nextContent.includes(&#96;${TEMP_HL_START}${tempId}]]]&#96;)) {\n          didInsert = true;\n        }\n        return {\n          ...m,\n          content: nextContent,\n        };\n      }),\n    );\n    if (didInsert) {\n      setTempHighlight({\n        nodeId,\n        messageIndex: msgIdx,\n        tempId,\n        treeId: selectionPopover.treeId,\n      });\n      // Only clear the native selection once we've successfully inserted a temp highlight.\n      window.getSelection()?.removeAllRanges?.();\n    }\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; {\n            setHoveredBranchNodeSource(\"node\");\n            setHoveredBranchNodeId(nodeId);\n          }}\n          onMouseLeave={() =&gt; {\n            setHoveredBranchNodeId(null);\n            setHoveredBranchNodeSource(null);\n          }}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const title = typeof node.title === \"string\" ? node.title : \"\";\n                  const words = title.split(\" \").filter(Boolean);\n                  const isPending = node.requestStatus === \"pending\";\n                  const isReady = node.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; {\n                        setHoveredBranchNodeSource(\"node\");\n                        setHoveredBranchNodeId(nodeId);\n                      }}\n                      onMouseLeave={() =&gt; {\n                        setHoveredBranchNodeId(null);\n                        setHoveredBranchNodeSource(null);\n                      }}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  \n  const remarkBranchHighlights = () =&gt; {\n-   const transformNode = (node) =&gt; {\n-     if (!node || typeof node !== \"object\") return;\n-     if (Array.isArray(node.children)) {\n-       const nextChildren = [];\n-       node.children.forEach((child) =&gt; {\n-         if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n-           let value = child.value;\n-           while (true) {\n-             const branchIdx = value.indexOf(BRANCH_HL_START);\n-             const tempIdx = value.indexOf(TEMP_HL_START);\n-             const startIdx =\n-               branchIdx === -1\n-                 ? tempIdx\n-                 : tempIdx === -1\n-                   ? branchIdx\n-                   : Math.min(branchIdx, tempIdx);\n-             if (startIdx === -1) break;\n-             const isBranch = startIdx === branchIdx;\n-             const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n-             if (metaEndIdx === -1) break;\n-             const meta = value.slice(\n-               startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n-               metaEndIdx,\n-             );\n-             const contentStartIdx = metaEndIdx + 3;\n-             const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n-             if (endIdx === -1) break;\n- \n-             const before = value.slice(0, startIdx);\n-             const inside = value.slice(contentStartIdx, endIdx);\n-             const after = value.slice(\n-               endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n-             );\n- \n-             if (before) nextChildren.push({ type: \"text\", value: before });\n-             if (isBranch) {\n-               const [highlightId, branchNodeId] = meta.split(\":\");\n-               if (!highlightId || !branchNodeId) break;\n-               nextChildren.push({\n-                 type: \"link\",\n-                 url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n-                 children: [{ type: \"text\", value: inside }],\n-               });\n-             } else {\n-               const tempId = meta;\n-               if (!tempId) break;\n-               nextChildren.push({\n-                 type: \"link\",\n-                 url: &#96;temp-highlight:${tempId}&#96;,\n-                 children: [{ type: \"text\", value: inside }],\n-               });\n-             }\n+   const parseStartMarker = (value) =&gt; {\n+     const branchIdx = value.indexOf(BRANCH_HL_START);\n+     const tempIdx = value.indexOf(TEMP_HL_START);\n+     const startIdx =\n+       branchIdx === -1\n+         ? tempIdx\n+         : tempIdx === -1\n+           ? branchIdx\n+           : Math.min(branchIdx, tempIdx);\n+     if (startIdx === -1) return null;\n+ \n+     const isBranch = startIdx === branchIdx;\n+     const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n+     if (metaEndIdx === -1) return null;\n+ \n+     const meta = value.slice(\n+       startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n+       metaEndIdx,\n+     );\n+     if (!meta) return null;\n+ \n+     return {\n+       kind: isBranch ? \"branch\" : \"temp\",\n+       meta,\n+       startIdx,\n+       tokenEndExclusive: metaEndIdx + 3,\n+     };\n+   };\n+ \n+   const splitByHighlightMarkers = (children) =&gt; {\n+     const out = [];\n+     let active = null; // { kind, meta, startToken, parts: [] }\n+ \n+     const pushPart = (part) =&gt; {\n+       if (!part) return;\n+       if (active) active.parts.push(part);\n+       else out.push(part);\n+     };\n+ \n+     const closeActive = () =&gt; {\n+       if (!active) return;\n+       const { kind, meta, parts, startToken } = active;\n+       if (kind === \"branch\") {\n+         const [highlightId, branchNodeId] = meta.split(\":\");\n+         if (highlightId &amp;&amp; branchNodeId) {\n+           out.push({\n+             type: \"link\",\n+             url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n+             children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n+           });\n+           active = null;\n+           return;\n+         }\n+       } else {\n+         out.push({\n+           type: \"link\",\n+           url: &#96;temp-highlight:${meta}&#96;,\n+           children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n+         });\n+         active = null;\n+         return;\n+       }\n+ \n+       // Malformed marker: keep literal content.\n+       out.push({ type: \"text\", value: startToken });\n+       out.push(...parts);\n+       active = null;\n+     };\n+ \n+     const flushUnclosed = () =&gt; {\n+       if (!active) return;\n+       out.push({ type: \"text\", value: active.startToken });\n+       out.push(...active.parts);\n+       active = null;\n+     };\n  \n-             value = after;\n+     const handleTextValue = (value) =&gt; {\n+       let rest = value;\n+       while (rest) {\n+         if (!active) {\n+           const parsed = parseStartMarker(rest);\n+           if (!parsed) {\n+             pushPart({ type: \"text\", value: rest });\n+             rest = \"\";\n+             break;\n            }\n  \n-           if (value) {\n-             nextChildren.push({ ...child, value });\n-           }\n-           return;\n-         }\n- \n-         transformNode(child);\n-         nextChildren.push(child);\n-       });\n-       node.children = nextChildren;\n+           const before = rest.slice(0, parsed.startIdx);\n+           if (before) pushPart({ type: \"text\", value: before });\n+ \n+           const startToken = rest.slice(parsed.startIdx, parsed.tokenEndExclusive);\n+           active = { kind: parsed.kind, meta: parsed.meta, startToken, parts: [] };\n+           rest = rest.slice(parsed.tokenEndExclusive);\n+           continue;\n+         }\n+ \n+         const endToken = active.kind === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n+         const endIdx = rest.indexOf(endToken);\n+         if (endIdx === -1) {\n+           pushPart({ type: \"text\", value: rest });\n+           rest = \"\";\n+           break;\n+         }\n+ \n+         const inside = rest.slice(0, endIdx);\n+         if (inside) pushPart({ type: \"text\", value: inside });\n+         rest = rest.slice(endIdx + endToken.length);\n+         closeActive();\n+       }\n+     };\n+ \n+     for (const child of children) {\n+       if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n+         handleTextValue(child.value);\n+         continue;\n+       }\n+       // Allow highlights to span across non-text nodes like strong/emphasis.\n+       pushPart(child);\n+     }\n+ \n+     flushUnclosed();\n+     return out;\n+   };\n+ \n+   const transformNode = (node) =&gt; {\n+     if (!node || typeof node !== \"object\") return;\n+     if (node.type === \"code\" || node.type === \"inlineCode\") return;\n+     if (Array.isArray(node.children)) {\n+       node.children.forEach((child) =&gt; transformNode(child));\n+       node.children = splitByHighlightMarkers(node.children);\n        return;\n      }",
        "oldStart": 244,
        "newStart": 244,
        "oldLines": 70,
        "newLines": 134,
        "linesRemoved": 63,
        "linesAdded": 127
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst countBoldDelimiters = (value) =&gt; {\n  if (!value) return 0;\n  const matches = value.match(/(\\*\\*|__)/g);\n  return matches ? matches.length : 0;\n};\n\nconst findSelectedRangeInMarkdown = (markdown, selectedText) =&gt; {\n  if (!markdown || !selectedText) return null;\n  const needle = selectedText.trim();\n  if (!needle) return null;\n\n  // Build a normalized view of markdown that drops common emphasis delimiters.\n  // This lets DOM selections (which don't include '**') match the source markdown.\n  let norm = \"\";\n  const map = []; // norm index -&gt; markdown index\n  for (let i = 0; i &lt; markdown.length; i++) {\n    const ch = markdown[i];\n    const next = markdown[i + 1];\n    if ((ch === \"*\" &amp;&amp; next === \"*\") || (ch === \"_\" &amp;&amp; next === \"_\")) {\n      i += 1; // skip the pair\n      continue;\n    }\n    if (ch === \"*\" || ch === \"_\") continue;\n    norm += ch;\n    map.push(i);\n  }\n\n  // Try exact match first.\n  let startNorm = norm.indexOf(needle);\n  let matchLen = needle.length;\n\n  // Fallback: whitespace-flexible regex match against normalized string.\n  if (startNorm === -1) {\n    const pattern = escapeRegex(needle).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(norm);\n      if (!match || match.index == null) return null;\n      startNorm = match.index;\n      matchLen = match[0]?.length || needle.length;\n    } catch {\n      return null;\n    }\n  }\n\n  const startMd = map[startNorm];\n  const endMdExclusive = map[startNorm + matchLen - 1] != null ? map[startNorm + matchLen - 1] + 1 : null;\n  if (startMd == null || endMdExclusive == null) return null;\n\n  // Expand to keep bold delimiters balanced when the match intersects bold spans.\n  let start = startMd;\n  let end = endMdExclusive;\n  for (let iter = 0; iter &lt; 6; iter++) {\n    const segment = markdown.slice(start, end);\n    if (countBoldDelimiters(segment) % 2 === 0) break;\n    let changed = false;\n    const tail = markdown.slice(end, end + 2);\n    const head = start &gt;= 2 ? markdown.slice(start - 2, start) : \"\";\n    if (tail === \"**\" || tail === \"__\") {\n      end = Math.min(markdown.length, end + 2);\n      changed = true;\n    }\n    if (head === \"**\" || head === \"__\") {\n      start = Math.max(0, start - 2);\n      changed = true;\n    }\n    if (!changed) break;\n  }\n\n  if (start &gt;= end) return null;\n  return { start, end };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(cleaned, selectedText);\n  if (range) {\n    return (\n      cleaned.slice(0, range.start) +\n      start +\n      cleaned.slice(range.start, range.end) +\n      end +\n      cleaned.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const range = findSelectedRangeInMarkdown(content, selectedText);\n  if (range) {\n    return (\n      content.slice(0, range.start) +\n      start +\n      content.slice(range.start, range.end) +\n      end +\n      content.slice(range.end)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const parseStartMarker = (value) =&gt; {\n    const branchIdx = value.indexOf(BRANCH_HL_START);\n    const tempIdx = value.indexOf(TEMP_HL_START);\n    const startIdx =\n      branchIdx === -1\n        ? tempIdx\n        : tempIdx === -1\n          ? branchIdx\n          : Math.min(branchIdx, tempIdx);\n    if (startIdx === -1) return null;\n\n    const isBranch = startIdx === branchIdx;\n    const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n    if (metaEndIdx === -1) return null;\n\n    const meta = value.slice(\n      startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n      metaEndIdx,\n    );\n    if (!meta) return null;\n\n    return {\n      kind: isBranch ? \"branch\" : \"temp\",\n      meta,\n      startIdx,\n      tokenEndExclusive: metaEndIdx + 3,\n    };\n  };\n\n  const splitByHighlightMarkers = (children) =&gt; {\n    const out = [];\n    let active = null; // { kind, meta, startToken, parts: [] }\n\n    const pushPart = (part) =&gt; {\n      if (!part) return;\n      if (active) active.parts.push(part);\n      else out.push(part);\n    };\n\n    const closeActive = () =&gt; {\n      if (!active) return;\n      const { kind, meta, parts, startToken } = active;\n      if (kind === \"branch\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          out.push({\n            type: \"link\",\n            url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n            children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n          });\n          active = null;\n          return;\n        }\n      } else {\n        out.push({\n          type: \"link\",\n          url: &#96;temp-highlight:${meta}&#96;,\n          children: parts.length ? parts : [{ type: \"text\", value: \"\" }],\n        });\n        active = null;\n        return;\n      }\n\n      // Malformed marker: keep literal content.\n      out.push({ type: \"text\", value: startToken });\n      out.push(...parts);\n      active = null;\n    };\n\n    const flushUnclosed = () =&gt; {\n      if (!active) return;\n      out.push({ type: \"text\", value: active.startToken });\n      out.push(...active.parts);\n      active = null;\n    };\n\n    const handleTextValue = (value) =&gt; {\n      let rest = value;\n      while (rest) {\n        if (!active) {\n          const parsed = parseStartMarker(rest);\n          if (!parsed) {\n            pushPart({ type: \"text\", value: rest });\n            rest = \"\";\n            break;\n          }\n\n          const before = rest.slice(0, parsed.startIdx);\n          if (before) pushPart({ type: \"text\", value: before });\n\n          const startToken = rest.slice(parsed.startIdx, parsed.tokenEndExclusive);\n          active = { kind: parsed.kind, meta: parsed.meta, startToken, parts: [] };\n          rest = rest.slice(parsed.tokenEndExclusive);\n          continue;\n        }\n\n        const endToken = active.kind === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n        const endIdx = rest.indexOf(endToken);\n        if (endIdx === -1) {\n          pushPart({ type: \"text\", value: rest });\n          rest = \"\";\n          break;\n        }\n\n        const inside = rest.slice(0, endIdx);\n        if (inside) pushPart({ type: \"text\", value: inside });\n        rest = rest.slice(endIdx + endToken.length);\n        closeActive();\n      }\n    };\n\n    for (const child of children) {\n      if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n        handleTextValue(child.value);\n        continue;\n      }\n      // Allow highlights to span across non-text nodes like strong/emphasis.\n      pushPart(child);\n    }\n\n    flushUnclosed();\n    return out;\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (node.type === \"code\" || node.type === \"inlineCode\") return;\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child));\n      node.children = splitByHighlightMarkers(node.children);\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  // &#96;hoveredBranchNodeId&#96; is used for both:\n  // - hovering a branch-highlight inside the message thread\n  // - hovering a node in the tree list / graph\n  // Fast pointer movement and/or DOM re-renders can sometimes skip &#96;mouseleave&#96; for the highlight,\n  // so we track the source and apply extra cleanup only for highlight-hover.\n  const [hoveredBranchNodeSource, setHoveredBranchNodeSource] = useState(null); // \"highlight\" | \"node\" | null\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n\n  useEffect(() =&gt; {\n    // If the selection popover opens while hovering a branch-highlight, we disable hover effects.\n    // Ensure we also clear the global hovered branch state so the \"extra\" hover highlight doesn't stick.\n    if (!selectionPopover.visible) return;\n    if (hoveredBranchNodeSource !== \"highlight\") return;\n    setHoveredBranchNodeId(null);\n    setHoveredBranchNodeSource(null);\n  }, [selectionPopover.visible, hoveredBranchNodeSource]);\n\n  useEffect(() =&gt; {\n    // Robust cleanup for highlight-hover: if we stop actually hovering/focusing the element\n    // (or it unmounts), clear the hover state.\n    if (!hoveredBranchNodeId) return;\n    if (hoveredBranchNodeSource !== \"highlight\") return;\n\n    const escapeAttrValue = (value) =&gt;\n      String(value).replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"');\n\n    let raf = null;\n    const check = () =&gt; {\n      raf = null;\n      const selector = &#96;.branch-highlight[data-branch-node-id=\"${escapeAttrValue(\n        hoveredBranchNodeId,\n      )}\"]&#96;;\n      const el = document.querySelector(selector);\n      if (!el) {\n        setHoveredBranchNodeId(null);\n        setHoveredBranchNodeSource(null);\n        return;\n      }\n      const isHovered = el.matches(\":hover\");\n      const isFocused = document.activeElement === el;\n      if (!isHovered &amp;&amp; !isFocused) {\n        setHoveredBranchNodeId(null);\n        setHoveredBranchNodeSource(null);\n      }\n    };\n\n    const schedule = () =&gt; {\n      if (raf != null) return;\n      raf = requestAnimationFrame(check);\n    };\n\n    // Run once (covers the unmount-without-mouseleave case immediately).\n    schedule();\n\n    window.addEventListener(\"pointermove\", schedule, { passive: true });\n    window.addEventListener(\"pointerdown\", schedule, { passive: true });\n    window.addEventListener(\"scroll\", schedule, true);\n    window.addEventListener(\"blur\", schedule);\n\n    return () =&gt; {\n      if (raf != null) cancelAnimationFrame(raf);\n      window.removeEventListener(\"pointermove\", schedule);\n      window.removeEventListener(\"pointerdown\", schedule);\n      window.removeEventListener(\"scroll\", schedule, true);\n      window.removeEventListener(\"blur\", schedule);\n    };\n  }, [hoveredBranchNodeId, hoveredBranchNodeSource]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeSource(\"highlight\");\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n                setHoveredBranchNodeSource(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeSource(\"highlight\");\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n                setHoveredBranchNodeSource(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    // If the user deletes the last remaining tree, immediately replace it with a\n    // fresh \"New Tree\" and activate it (avoid a render where activeTreeId is null).\n    const isLastRemainingTree = Object.keys(treesById).length === 1;\n    if (isLastRemainingTree) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n      setGraphHasInteracted(false);\n      setGraphScale(1.4);\n      setGraphTranslate({ x: 0, y: 0 });\n      closeTreeMenu();\n      return;\n    }\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setHoveredBranchNodeSource(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    let didInsert = false;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        const nextContent = wrapFirstMatchWithTempHighlight(\n          m.content,\n          selectionPopover.text,\n          tempId,\n        );\n        if (nextContent.includes(&#96;${TEMP_HL_START}${tempId}]]]&#96;)) {\n          didInsert = true;\n        }\n        return {\n          ...m,\n          content: nextContent,\n        };\n      }),\n    );\n    if (didInsert) {\n      setTempHighlight({\n        nodeId,\n        messageIndex: msgIdx,\n        tempId,\n        treeId: selectionPopover.treeId,\n      });\n      // Only clear the native selection once we've successfully inserted a temp highlight.\n      window.getSelection()?.removeAllRanges?.();\n    }\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; {\n            setHoveredBranchNodeSource(\"node\");\n            setHoveredBranchNodeId(nodeId);\n          }}\n          onMouseLeave={() =&gt; {\n            setHoveredBranchNodeId(null);\n            setHoveredBranchNodeSource(null);\n          }}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const title = typeof node.title === \"string\" ? node.title : \"\";\n                  const words = title.split(\" \").filter(Boolean);\n                  const isPending = node.requestStatus === \"pending\";\n                  const isReady = node.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; {\n                        setHoveredBranchNodeSource(\"node\");\n                        setHoveredBranchNodeId(nodeId);\n                      }}\n                      onMouseLeave={() =&gt; {\n                        setHoveredBranchNodeId(null);\n                        setHoveredBranchNodeSource(null);\n                      }}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "parseStartMarker|splitByHighlightMarkers" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 4 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `const parseStartMarker = (value) => \{` | L246 |
| `src/App.jsx` | `const splitByHighlightMarkers = (children) => \{` | L275 |
| `src/App.jsx` | `const parsed = parseStartMarker(rest);` | L326 |
| `src/App.jsx` | `node.children = splitByHighlightMarkers(node.children);` | L375 |


</details>
</tool-use>

---

### Fixed: highlight tokens no longer show up as raw markdown
Your highlight markers like `[[[hl:...]]]...[[[/hl]]]` were leaking because `remarkBranchHighlights` was still the **old text-node-only parser**, so any highlight that spanned formatting nodes (like `**bold**`) wouldn’t get converted and the tokens would render as literal text.

I replaced `remarkBranchHighlights` in `src/App.jsx` with a **stitching parser** that:
- Consumes `[[[hl:...]]]...[[[/hl]]]` and `[[[sel:...]]]...[[[/sel]]]`
- Works even when the highlighted content includes non-text nodes (`strong`/`emphasis`, etc.)
- Skips `code` / `inlineCode` nodes so markers in code don’t get eaten unexpectedly

### Where
- `src/App.jsx`

---

_**User (2026-01-18 16:02Z)**_

bug still occurs, we should not see this markdown code

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Diagnosing visible token issue**

The markers are showing as visible tokens within highlighted text because the remark plugin didn't transform them into link nodes, likely due to token splitting across markdown nodes or plugin running order before remarkGfm; this causes ReactMarkdown to render them as plain text with CSS highlighting applied but leaves tokens visible.
**Verifying remark plugin definition**

I'm checking the current definition of the remarkBranchHighlights function to ensure the updated version is loaded and not an old duplicate causing the token rendering issue.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Diagnosing marker rendering issue**

Markers still appear inside highlights because the plugin creates link nodes with children that include marker tokens as text, likely due to unbalanced or embedded markers in the original content that prevent proper parsing and conversion by the plugin.
**Analyzing highlight and marker overlap**

The yellow highlight likely comes from CSS applying to a span wrapping both the selection text and leftover marker tokens, meaning the plugin wraps the raw marker text inside the highlight span instead of removing it. This suggests the marker tokens persist in the markdown content and ReactMarkdown mapping or remark plugin handling isn’t fully removing or isolating them.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "branch-highlight|temp-highlight",
  "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
  "outputMode": "content",
  "context": 2,
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "branch-highlight|temp-highlight",
    "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/styles.css",
              "matches": [
                {
                  "lineNumber": 800,
                  "content": "}",
                  "isContextLine": true
                },
                {
                  "lineNumber": 801,
                  "isContextLine": true
                },
                {
                  "lineNumber": 802,
                  "content": ".branch-highlight {"
                },
                {
                  "lineNumber": 803,
                  "content": "    background: rgba(255, 235, 59, 0.55);",
                  "isContextLine": true
                },
                {
                  "lineNumber": 804,
                  "content": "    color: inherit;",
                  "isContextLine": true
                },
                {
                  "lineNumber": 809,
                  "content": "}",
                  "isContextLine": true
                },
                {
                  "lineNumber": 810,
                  "isContextLine": true
                },
                {
                  "lineNumber": 811,
                  "content": ".branch-highlight.is-temp {"
                },
                {
                  "lineNumber": 812,
                  "content": "    cursor: default;",
                  "isContextLine": true
                },
                {
                  "lineNumber": 813,
                  "content": "    pointer-events: none;",
                  "isContextLine": true
                },
                {
                  "lineNumber": 814,
                  "content": "}",
                  "isContextLine": true
                },
                {
                  "lineNumber": 815,
                  "isContextLine": true
                },
                {
                  "lineNumber": 816,
                  "content": ".branch-highlight:hover,"
                },
                {
                  "lineNumber": 817,
                  "content": ".branch-highlight.is-hovered {"
                },
                {
                  "lineNumber": 818,
                  "content": "    background: rgba(255, 235, 59, 0.82);",
                  "isContextLine": true
                },
                {
                  "lineNumber": 819,
                  "content": "    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);",
                  "isContextLine": true
                },
                {
                  "lineNumber": 820,
                  "content": "}",
                  "isContextLine": true
                },
                {
                  "lineNumber": 821,
                  "isContextLine": true
                },
                {
                  "lineNumber": 822,
                  "content": ".branch-highlight.no-hover:hover {"
                },
                {
                  "lineNumber": 823,
                  "content": "    background: rgba(255, 235, 59, 0.55);",
                  "isContextLine": true
                },
                {
                  "lineNumber": 824,
                  "content": "    box-shadow: none;",
                  "isContextLine": true
                },
                {
                  "lineNumber": 825,
                  "content": "}",
                  "isContextLine": true
                },
                {
                  "lineNumber": 826,
                  "isContextLine": true
                },
                {
                  "lineNumber": 827,
                  "content": ".branch-highlight.teleport-flash {"
                },
                {
                  "lineNumber": 828,
                  "content": "    animation: teleportPulse 900ms ease-out 1;",
                  "isContextLine": true
                },
                {
                  "lineNumber": 829,
                  "content": "}",
                  "isContextLine": true
                }
              ]
            }
          ],
          "totalLines": 26,
          "totalMatchedLines": 6
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

