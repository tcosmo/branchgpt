<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 2eaf6de8-81bf-4169-a163-fe0364ea5acf (2026-01-18 17:35Z) -->

# Chat persistence and tree management (2026-01-18 17:35Z)

_**User (2026-01-18 15:24Z)**_

Can you make chats persistent and allow me to create new trees and see all my trees

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Planning exploration and task list**</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Inspect current tree/chat state management and UI
- [ ] Locate persistence layer and add chat/tree storage
- [ ] Add UI to create tree and list all trees

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/main.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/index.html</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Defining multi-tree state and persistence**

Planning to restructure state as multiple trees with IDs, titles, nodes, and timestamps, storing active tree and nodes within each tree; will implement load/save from localStorage under a versioned key and adapt existing node update functions to operate within the active tree in the new data model.
**Designing tree creation UI and title logic**

Planning a sidebar "Trees" section with a create button and a list of trees showing unique default titles like "Tree 1," updating titles from the root node’s first user message summary using an existing helper, while persisting trees and active IDs in localStorage with version handling and migration for backward compatibility.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "localStorage",
  "path": "/Users/cosmo/Documents/projects/trees",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "localStorage",
    "path": "/Users/cosmo/Documents/projects/trees",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Designing active tree update helpers**

I’m defining helper functions to update the active tree and its nodes, ensuring updates to nodesById, activeNodeId, and timestamps stay consistent. These helpers aim to centralize tree state mutations and clarify node updates within the active tree context.
**Extending tree management with persistence and multi-tree support**

I'm designing updates to track node updates by explicit treeId to handle async changes safely and to implement persistent multi-tree state with loading, saving, and UI tree switching. This includes restructuring state to store treesById with activeTreeId, updating relevant functions to accept treeId, and planning UI changes for a sidebar tree list with creation and switch handling.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "9da969c0-8d7d-4641-8c62-4e4b0ef0f364",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "9da969c0-8d7d-4641-8c62-4e4b0ef0f364",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const [nodesById, setNodesById] = useState(() =&gt; ({\n    root: createRootNode(),\n  }));\n  const [activeNodeId, setActiveNodeId] = useState(\"root\");\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n      });\n    }\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    ],\n  });\n+ \n+ const STORAGE_KEY = \"chat-trees:v1\";\n+ \n+ const createTree = (title) =&gt; {\n+   const now = Date.now();\n+   return {\n+     id: crypto.randomUUID(),\n+     title,\n+     nodesById: { root: createRootNode() },\n+     activeNodeId: \"root\",\n+     createdAt: now,\n+     updatedAt: now,\n+   };\n+ };\n+ \n+ const loadTreesFromStorage = () =&gt; {\n+   if (typeof window === \"undefined\") return null;\n+   try {\n+     const raw = window.localStorage.getItem(STORAGE_KEY);\n+     if (!raw) return null;\n+     const parsed = JSON.parse(raw);\n+     if (parsed?.version !== 1) return null;\n+     if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n+     const treeIds = Object.keys(parsed.treesById);\n+     if (!treeIds.length) return null;\n+     const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n+       ? parsed.activeTreeId\n+       : treeIds[0];\n+     return { treesById: parsed.treesById, activeTreeId };\n+   } catch {\n+     return null;\n+   }\n+ };\n+ \n+ const createInitialTreeState = () =&gt; {\n+   const loaded = loadTreesFromStorage();\n+   if (loaded) return loaded;\n+   const tree = createTree(\"New tree\");\n+   return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n+ };\n  \n  const getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {",
        "oldStart": 265,
        "newStart": 265,
        "oldLines": 4,
        "newLines": 44,
        "linesAdded": 40
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const [nodesById, setNodesById] = useState(() =&gt; ({\n    root: createRootNode(),\n  }));\n  const [activeNodeId, setActiveNodeId] = useState(\"root\");\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n      });\n    }\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Applying state initialization and persistence**

I'm adding initial state setup with useMemo and useState, plus derived variables for active tree and nodes. I'll also add useEffect to persist active tree ID and fix its correctness, patching around the App component start.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "83a93ad1-d037-414d-83f7-0916da883299",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "83a93ad1-d037-414d-83f7-0916da883299",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n      });\n    }\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  \n  const App = () =&gt; {\n-   const [nodesById, setNodesById] = useState(() =&gt; ({\n-     root: createRootNode(),\n-   }));\n-   const [activeNodeId, setActiveNodeId] = useState(\"root\");\n+   const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n+   const [treesById, setTreesById] = useState(initialTreeState.treesById);\n+   const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n    const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n    const [draft, setDraft] = useState(\"\");",
        "oldStart": 406,
        "newStart": 406,
        "oldLines": 8,
        "newLines": 7,
        "linesRemoved": 4,
        "linesAdded": 3
      },
      {
        "diffString": "      messageIndex: null,\n      nodeId: null,\n+     treeId: null,\n    });\n    const [tempHighlight, setTempHighlight] = useState(null);",
        "oldStart": 428,
        "newStart": 427,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "    });\n  \n+   const activeTree = treesById[activeTreeId];\n+   const nodesById = activeTree?.nodesById || {};\n+   const activeNodeId = activeTree?.activeNodeId || \"root\";\n    const activeNode = nodesById[activeNodeId];\n    const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;",
        "oldStart": 448,
        "newStart": 448,
        "oldLines": 4,
        "newLines": 7,
        "linesAdded": 3
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n      });\n    }\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning helper functions and effects**

I'm deciding to add helper functions related to active node and tree state after existing useEffects and before addNode, plus effects to initialize and persist active tree ID in localStorage, and to clear UI state when the active tree changes.
**Organizing helper functions and effects**

I'm planning to insert key helper functions just after derived data and before useLayoutEffect for best order and readability, ensuring functions used in effects are defined earlier, and to add an effect clearing temp highlights on active tree changes using these helpers.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "97e47424-4110-49af-b603-f06bc1937386",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "97e47424-4110-49af-b603-f06bc1937386",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n      });\n    }\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    const shouldShowContext = activeNodeId !== \"root\";\n    const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n+   const treeList = useMemo(\n+     () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n+     [treesById],\n+   );\n    const markdownComponents = useMemo(\n      () =&gt; ({",
        "oldStart": 455,
        "newStart": 455,
        "oldLines": 4,
        "newLines": 8,
        "linesAdded": 4
      },
      {
        "diffString": "      };\n    }, [childrenMap]);\n+ \n+   const updateTree = (treeId, updater) =&gt; {\n+     setTreesById((prev) =&gt; {\n+       const tree = prev[treeId];\n+       if (!tree) return prev;\n+       const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n+       if (next === tree) return prev;\n+       return { ...prev, [treeId]: next };\n+     });\n+   };\n+ \n+   const updateTreeNodes = (treeId, updater) =&gt; {\n+     setTreesById((prev) =&gt; {\n+       const tree = prev[treeId];\n+       if (!tree) return prev;\n+       const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n+       if (nextNodes === tree.nodesById) return prev;\n+       return {\n+         ...prev,\n+         [treeId]: {\n+           ...tree,\n+           nodesById: nextNodes,\n+           updatedAt: Date.now(),\n+         },\n+       };\n+     });\n+   };\n+ \n+   const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n+     updateTreeNodes(treeId, (prevNodes) =&gt; {\n+       const node = prevNodes[nodeId];\n+       if (!node) return prevNodes;\n+       return {\n+         ...prevNodes,\n+         [nodeId]: {\n+           ...node,\n+           messages: updater(node.messages),\n+         },\n+       };\n+     });\n+   };\n+ \n+   const updateNode = (treeId, nodeId, updater) =&gt; {\n+     updateTreeNodes(treeId, (prevNodes) =&gt; {\n+       const node = prevNodes[nodeId];\n+       if (!node) return prevNodes;\n+       const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n+       if (next === node) return prevNodes;\n+       return { ...prevNodes, [nodeId]: next };\n+     });\n+   };\n+ \n+   const setActiveNodeId = (nodeId) =&gt; {\n+     updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n+   };\n+ \n+   const createNewTree = () =&gt; {\n+     const nextIndex = treeList.length + 1;\n+     const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n+     setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n+     setActiveTreeId(tree.id);\n+     setTreeView(\"graph\");\n+   };\n  \n    useLayoutEffect(() =&gt; {",
        "oldStart": 581,
        "newStart": 585,
        "oldLines": 4,
        "newLines": 67,
        "linesAdded": 63
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n      });\n    }\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding useEffect hooks for state persistence and active tree changes**

Planning to insert multiple useEffect hooks near line 688, just after the existing keydown useEffect, to initialize active tree ID, persist state to localStorage, and clear temporary highlights on active tree changes. The updateNodeMessages function is accessible here for clearing highlights.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "ace96e93-46eb-46be-a429-b03e6c298f3a",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "ace96e93-46eb-46be-a429-b03e6c298f3a",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n      });\n    }\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n    }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n+ \n+   useEffect(() =&gt; {\n+     if (activeTreeId) return;\n+     if (!treeList.length) return;\n+     setActiveTreeId(treeList[0].id);\n+   }, [activeTreeId, treeList]);\n+ \n+   useEffect(() =&gt; {\n+     if (!activeTreeId) return;\n+     if (tempHighlight) {\n+       updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n+         messages.map((m, i) =&gt; {\n+           if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n+           return {\n+             ...m,\n+             content: removeTempHighlightById(m.content, tempHighlight.tempId),\n+           };\n+         }),\n+       );\n+     }\n+     setTempHighlight(null);\n+     setSelectionPopover({\n+       visible: false,\n+       text: \"\",\n+       rect: null,\n+       draft: \"\",\n+       placement: \"above\",\n+       messageIndex: null,\n+       nodeId: null,\n+       treeId: null,\n+     });\n+     setHoveredBranchNodeId(null);\n+     setDraft(\"\");\n+     setError(\"\");\n+   }, [activeTreeId]);\n+ \n+   useEffect(() =&gt; {\n+     if (typeof window === \"undefined\") return;\n+     const payload = {\n+       version: 1,\n+       treesById,\n+       activeTreeId,\n+     };\n+     window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n+   }, [treesById, activeTreeId]);\n  \n    useEffect(() =&gt; {",
        "oldStart": 746,
        "newStart": 746,
        "oldLines": 4,
        "newLines": 49,
        "linesAdded": 45
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n      });\n    }\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Refactoring node update calls**

Planning to replace all setNodesById usages, including in useClickOutside, with updateNodeMessages for consistent node message updates.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "setNodesById",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "setNodesById",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 686,
                  "content": "      setNodesById((prev) =&gt; {"
                },
                {
                  "lineNumber": 731,
                  "content": "        setNodesById((prev) =&gt; {"
                },
                {
                  "lineNumber": 801,
                  "content": "      setNodesById((prev) =&gt; {"
                },
                {
                  "lineNumber": 816,
                  "content": "    setNodesById((prev) =&gt; {"
                },
                {
                  "lineNumber": 857,
                  "content": "    setNodesById((prev) =&gt; ({"
                },
                {
                  "lineNumber": 874,
                  "content": "    setNodesById((prev) =&gt; {"
                },
                {
                  "lineNumber": 888,
                  "content": "    setNodesById((prev) =&gt; {"
                },
                {
                  "lineNumber": 1011,
                  "content": "      setNodesById((prev) =&gt; {"
                },
                {
                  "lineNumber": 1037,
                  "content": "      setNodesById((prev) =&gt; {"
                },
                {
                  "lineNumber": 1664,
                  "content": "                  setNodesById((prev) =&gt; {"
                }
              ]
            }
          ],
          "totalLines": 10,
          "totalMatchedLines": 10
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning updates to node-related functions**

I'm preparing to replace old updateNode, updateNodeMessages, and addNode definitions scattered around line 718 with new versions, and to revise all related function calls, starting by updating the TODO list.</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Inspect current tree/chat state management and UI
- [-] Locate persistence layer and add chat/tree storage
- [ ] Add UI to create tree and list all trees

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Inspecting setNodesById updates**

I'm focusing on the setNodesById areas to change each block for using updateNodeMessages/updateTreeNodes with treeId, starting with lines around 670-750.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning treeId integration**

I'm preparing to update state management calls across multiple effects and handlers to include treeId, replacing setNodesById with updateNodeMessages using treeId. I'll also add activeTreeId to keydown effect dependencies where needed and adjust relevant function signatures and state shapes accordingly.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "fd74221e-416c-42c3-80b5-ae4e249ce696",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "fd74221e-416c-42c3-80b5-ae4e249ce696",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "          messageIndex: null,\n          nodeId: null,\n+         treeId: null,\n        });\n      }\n      if (tempHighlight) {\n-       setNodesById((prev) =&gt; {\n-         const node = prev[tempHighlight.nodeId];\n-         if (!node) return prev;\n-         const idx = tempHighlight.messageIndex;\n-         const nextMessages = node.messages.map((m, i) =&gt; {\n-           if (i !== idx || typeof m?.content !== \"string\") return m;\n+       updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n+         messages.map((m, i) =&gt; {\n+           if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n-         });\n-         return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n-       });\n+         }),\n+       );\n        setTempHighlight(null);\n      }",
        "oldStart": 681,
        "newStart": 681,
        "oldLines": 17,
        "newLines": 14,
        "linesRemoved": 9,
        "linesAdded": 6
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      if (tempHighlight) {\n        setNodesById((prev) =&gt; {\n          const node = prev[tempHighlight.nodeId];\n          if (!node) return prev;\n          const idx = tempHighlight.messageIndex;\n          const nextMessages = node.messages.map((m, i) =&gt; {\n            if (i !== idx || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          });\n          return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n        });\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating keydown effect**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "20165ba7-bc2c-4553-820f-34d2d5a07ffd",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "20165ba7-bc2c-4553-820f-34d2d5a07ffd",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "              messageIndex: payload.messageIndex,\n              nodeId: activeNodeId,\n+             treeId: activeTreeId,\n            });\n          }",
        "oldStart": 708,
        "newStart": 708,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "            messageIndex: null,\n            nodeId: null,\n+           treeId: null,\n          });\n        }\n        if (tempHighlight) {\n-         setNodesById((prev) =&gt; {\n-           const node = prev[tempHighlight.nodeId];\n-           if (!node) return prev;\n-           const idx = tempHighlight.messageIndex;\n-           const nextMessages = node.messages.map((m, i) =&gt; {\n-             if (i !== idx || typeof m?.content !== \"string\") return m;\n+         updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n+           messages.map((m, i) =&gt; {\n+             if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n              return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n-           });\n-           return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n-         });\n+           }),\n+         );\n          setTempHighlight(null);\n        }",
        "oldStart": 723,
        "newStart": 724,
        "oldLines": 17,
        "newLines": 14,
        "linesRemoved": 9,
        "linesAdded": 6
      },
      {
        "diffString": "      window.addEventListener(\"keydown\", onKeyDown);\n      return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n-   }, [selectionPopover.visible, activeNodeId, tempHighlight]);\n+   }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n  \n    useEffect(() =&gt; {",
        "oldStart": 742,
        "newStart": 740,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n\n    if (tempHighlight) {\n      setNodesById((prev) =&gt; {\n        const node = prev[tempHighlight.nodeId];\n        if (!node) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = node.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        });\n        return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n      });\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const nextMessages = node.messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      });\n      return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n    });\n    setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating selection popover effect**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "f3f53181-12a1-4e46-b3b6-627d3ffd57ca",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "f3f53181-12a1-4e46-b3b6-627d3ffd57ca",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      if (selectionPopover.messageIndex == null) return;\n      if (!selectionPopover.nodeId) return;\n+     if (!selectionPopover.treeId) return;\n  \n      if (tempHighlight) {\n-       setNodesById((prev) =&gt; {\n-         const node = prev[tempHighlight.nodeId];\n-         if (!node) return prev;\n-         const idx = tempHighlight.messageIndex;\n-         const nextMessages = node.messages.map((m, i) =&gt; {\n-           if (i !== idx || typeof m?.content !== \"string\") return m;\n+       updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n+         messages.map((m, i) =&gt; {\n+           if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n-         });\n-         return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n-       });\n+         }),\n+       );\n      }\n  \n      const tempId = crypto.randomUUID();\n      const nodeId = selectionPopover.nodeId;\n      const msgIdx = selectionPopover.messageIndex;\n-     setNodesById((prev) =&gt; {\n-       const node = prev[nodeId];\n-       if (!node) return prev;\n-       const nextMessages = node.messages.map((m, i) =&gt; {\n+     updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n+       messages.map((m, i) =&gt; {\n          if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n          };\n-       });\n-       return { ...prev, [nodeId]: { ...node, messages: nextMessages } };\n-     });\n-     setTempHighlight({ nodeId, messageIndex: msgIdx, tempId });\n+       }),\n+     );\n+     setTempHighlight({\n+       nodeId,\n+       messageIndex: msgIdx,\n+       tempId,\n+       treeId: selectionPopover.treeId,\n+     });\n      window.getSelection()?.removeAllRanges?.();\n    }, [",
        "oldStart": 792,
        "newStart": 792,
        "oldLines": 34,
        "newLines": 33,
        "linesRemoved": 17,
        "linesAdded": 16
      },
      {
        "diffString": "      selectionPopover.messageIndex,\n      selectionPopover.nodeId,\n+     selectionPopover.treeId,\n    ]);\n  ",
        "oldStart": 828,
        "newStart": 827,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    updateNode(activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Patching useEffect to update activeTreeId**

I'm updating the useEffect logic for active unread to ensure it updates the activeTreeId in the node accordingly around line 843.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "e848dfd9-b6d1-4470-8c8b-df1f6a64eff9",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "e848dfd9-b6d1-4470-8c8b-df1f6a64eff9",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  \n    useEffect(() =&gt; {\n-     updateNode(activeNodeId, (node) =&gt; {\n+     if (!activeTreeId) return;\n+     updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n        if (!node?.hasUnread) return node;\n        return {",
        "oldStart": 837,
        "newStart": 837,
        "oldLines": 5,
        "newLines": 6,
        "linesRemoved": 1,
        "linesAdded": 2
      },
      {
        "diffString": "        };\n      });\n-   }, [activeNodeId]);\n+   }, [activeTreeId, activeNodeId]);\n  \n    const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {",
        "oldStart": 845,
        "newStart": 846,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    setNodesById((prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      setActiveNodeId(id);\n    }\n    return id;\n  };\n\n  const updateNodeMessages = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      return {\n        ...prev,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (nodeId, updater) =&gt; {\n    setNodesById((prev) =&gt; {\n      const node = prev[nodeId];\n      if (!node) return prev;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prev;\n      return { ...prev, [nodeId]: next };\n    });\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Identifying legacy node update functions**

I'm locating old updateNodeMessages and updateNode definitions around line 718 to plan their removal after updating addNode.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Refactoring node update functions**

Planning to remove legacy updateNodeMessages and updateNode and adjust addNode to accept treeId, updating related calls accordingly, including handleSend and handleBranchSend.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "9efbcacb-42df-4d8e-9606-af78a8cd07df",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "9efbcacb-42df-4d8e-9606-af78a8cd07df",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    }, [activeTreeId, activeNodeId]);\n  \n-   const addNode = (parentId, title, messages, extra = {}, options = {}) =&gt; {\n+   const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n      const id = crypto.randomUUID();\n      const shouldActivate = options.activate !== false;\n-     setNodesById((prev) =&gt; ({\n+     updateTreeNodes(treeId, (prev) =&gt; ({\n        ...prev,\n        [id]: {",
        "oldStart": 848,
        "newStart": 848,
        "oldLines": 8,
        "newLines": 8,
        "linesRemoved": 2,
        "linesAdded": 2
      },
      {
        "diffString": "      }));\n      if (shouldActivate) {\n-       setActiveNodeId(id);\n+       updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n      }\n      return id;\n    };\n- \n-   const updateNodeMessages = (nodeId, updater) =&gt; {\n-     setNodesById((prev) =&gt; {\n-       const node = prev[nodeId];\n-       if (!node) return prev;\n-       return {\n-         ...prev,\n-         [nodeId]: {\n-           ...node,\n-           messages: updater(node.messages),\n-         },\n-       };\n-     });\n-   };\n- \n-   const updateNode = (nodeId, updater) =&gt; {\n-     setNodesById((prev) =&gt; {\n-       const node = prev[nodeId];\n-       if (!node) return prev;\n-       const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n-       if (next === node) return prev;\n-       return { ...prev, [nodeId]: next };\n-     });\n-   };\n  \n    const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {",
        "oldStart": 862,
        "newStart": 862,
        "oldLines": 32,
        "newLines": 8,
        "linesRemoved": 25,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating send handler to use treeId and update tree title**

I'm modifying the send handler to use the current treeId and updating the tree title when the root node changes, guarding against missing activeTreeId, and adjusting node message updates accordingly.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "fb92d19a-7c0b-4de4-a67d-e539fa668c86",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "fb92d19a-7c0b-4de4-a67d-e539fa668c86",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    const handleSend = async (content) =&gt; {\n      if (!content.trim() || isLoading) return;\n+     if (!activeTreeId) return;\n      setError(\"\");\n      const trimmed = content.trim();",
        "oldStart": 913,
        "newStart": 913,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "        ? buildHiddenContextForNode(activeNodeId, nodesById)\n        : \"\";\n-     updateNodeMessages(activeNodeId, (messages) =&gt; [\n+     updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"user\", content: trimmed },\n      ]);\n+     if (activeNodeId === \"root\") {\n+       updateTree(activeTreeId, (tree) =&gt; {\n+         if (tree.title !== \"New tree\") return tree;\n+         return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n+       });\n+     }\n      setDraft(\"\");\n      setIsLoading(true);",
        "oldStart": 919,
        "newStart": 920,
        "oldLines": 8,
        "newLines": 14,
        "linesRemoved": 1,
        "linesAdded": 7
      },
      {
        "diffString": "          hiddenContext,\n        );\n-       updateNodeMessages(activeNodeId, (messages) =&gt; [\n+       updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n          ...messages,\n          { role: \"assistant\", content: reply || \"No response returned.\" },",
        "oldStart": 930,
        "newStart": 937,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating handleBranchSend to support treeId**

I'm refactoring handleBranchSend to consistently use treeId from selectionPopover or fallback to activeTreeId, updating node creation, highlight updates, and title changes accordingly to pass treeId, ensuring correct tree context throughout asynchronous operations.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing comprehensive function patch**

I'm locating the start of the target function to replace its initial block with a version that includes the new treeId parameter, planning a context-aware patch from line 974 through the start of handleBranchSend.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "fed64895-a6dd-4ff3-8c31-79429ce13e59",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "fed64895-a6dd-4ff3-8c31-79429ce13e59",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      }\n      setError(\"\");\n+     const treeId = selectionPopover.treeId || activeTreeId;\n+     if (!treeId) return;\n      const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n      const userMessage = selectionPopover.draft.trim();\n      const fallbackTitle = \"...\";\n      const branchExcerpt = selectionPopover.text.trim();\n      const newNodeId = addNode(\n+       treeId,\n        sourceNodeId,\n        fallbackTitle,",
        "oldStart": 967,
        "newStart": 967,
        "oldLines": 9,
        "newLines": 12,
        "linesAdded": 3
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = tempHighlight.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      setNodesById((prev) =&gt; {\n        const sourceNode = prev[sourceNodeId];\n        if (!sourceNode) return prev;\n        const idx = selectionPopover.messageIndex;\n        const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n          if (i !== idx || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        });\n        return {\n          ...prev,\n          [sourceNodeId]: {\n            ...sourceNode,\n            messages: nextMessages,\n          },\n        };\n      });\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Patching highlight update with tree ID check**

I'm updating the highlight handling by replacing setNodesById calls with updateTreeNodes and adding a condition to ensure tempHighlight's treeId matches the current treeId before applying updates, avoiding cross-tree effects.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "dc38d0ba-c477-416d-b7a7-3f55934a4628",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "dc38d0ba-c477-416d-b7a7-3f55934a4628",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      );\n      const highlightId = crypto.randomUUID();\n-     if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId) {\n-       setNodesById((prev) =&gt; {\n-         const sourceNode = prev[sourceNodeId];\n-         if (!sourceNode) return prev;\n-         const idx = tempHighlight.messageIndex;\n-         const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n-           if (i !== idx || typeof m?.content !== \"string\") return m;\n+     if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n+       updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n+         messages.map((m, i) =&gt; {\n+           if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return {\n              ...m,",
        "oldStart": 990,
        "newStart": 990,
        "oldLines": 11,
        "newLines": 8,
        "linesRemoved": 7,
        "linesAdded": 4
      },
      {
        "diffString": "              ),\n            };\n-         });\n-         return {\n-           ...prev,\n-           [sourceNodeId]: {\n-             ...sourceNode,\n-             messages: nextMessages,\n-           },\n-         };\n-       });\n+         }),\n+       );\n        setTempHighlight(null);\n      } else if (selectionPopover.messageIndex != null) {\n-       setNodesById((prev) =&gt; {\n-         const sourceNode = prev[sourceNodeId];\n-         if (!sourceNode) return prev;\n-         const idx = selectionPopover.messageIndex;\n-         const nextMessages = sourceNode.messages.map((m, i) =&gt; {\n-           if (i !== idx || typeof m?.content !== \"string\") return m;\n+       updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n+         messages.map((m, i) =&gt; {\n+           if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n            return {\n              ...m,",
        "oldStart": 1006,
        "newStart": 1003,
        "oldLines": 21,
        "newLines": 11,
        "linesRemoved": 15,
        "linesAdded": 5
      },
      {
        "diffString": "              ),\n            };\n-         });\n-         return {\n-           ...prev,\n-           [sourceNodeId]: {\n-             ...sourceNode,\n-             messages: nextMessages,\n-           },\n-         };\n-       });\n+         }),\n+       );\n      }\n      setSelectionPopover({",
        "oldStart": 1032,
        "newStart": 1019,
        "oldLines": 13,
        "newLines": 6,
        "linesRemoved": 9,
        "linesAdded": 2
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating treeId handling in selectionPopover and nodesWithNew**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "bb1285de-0d1a-41a2-93f3-65e61bf490c4",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "bb1285de-0d1a-41a2-93f3-65e61bf490c4",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "        messageIndex: null,\n        nodeId: null,\n+       treeId: null,\n      });\n      window.getSelection()?.removeAllRanges?.();\n      try {\n        // Build context against a snapshot that includes the new node (setState is async).\n+       const treeSnapshot = treesById[treeId];\n+       const baseNodes = treeSnapshot?.nodesById || nodesById;\n        const nodesWithNew = {\n-         ...nodesById,\n+         ...baseNodes,\n          [newNodeId]: {\n            id: newNodeId,",
        "oldStart": 1030,
        "newStart": 1030,
        "oldLines": 10,
        "newLines": 13,
        "linesRemoved": 1,
        "linesAdded": 4
      },
      {
        "diffString": "          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n-           updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n+           updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n          })\n          .catch(() =&gt; { });\n  \n        const reply = await replyPromise;\n-       updateNodeMessages(newNodeId, (messages) =&gt; [\n+       updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n          ...messages,\n          { role: \"assistant\", content: reply || \"No response returned.\" },\n        ]);\n-       updateNode(newNodeId, (node) =&gt; ({\n+       updateNode(treeId, newNodeId, (node) =&gt; ({\n          ...node,\n          requestStatus: \"ready\",",
        "oldStart": 1056,
        "newStart": 1059,
        "oldLines": 14,
        "newLines": 14,
        "linesRemoved": 3,
        "linesAdded": 3
      },
      {
        "diffString": "      } catch (err) {\n        setError(err.message || \"Failed to reach OpenAI.\");\n-       updateNode(newNodeId, (node) =&gt; ({\n+       updateNode(treeId, newNodeId, (node) =&gt; ({\n          ...node,\n          requestStatus: \"idle\",",
        "oldStart": 1072,
        "newStart": 1075,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  const handleSidebarWheel = (event) =&gt; {\n    if (!event.ctrlKey) return;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        onWheel={handleSidebarWheel}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating selection handling with treeId**

I'm modifying handleSelection and popover close to reset treeId to null and including activeTreeId when setting the selection popover to ensure correct tree context. Next, I'll patch handleSelection accordingly.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "eef851f4-5e37-4237-b7b9-a234e5dcde98",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "eef851f4-5e37-4237-b7b9-a234e5dcde98",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "            messageIndex: null,\n            nodeId: null,\n+           treeId: null,\n          });\n        }",
        "oldStart": 1131,
        "newStart": 1131,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "            messageIndex: null,\n            nodeId: null,\n+           treeId: null,\n          });\n        }",
        "oldStart": 1146,
        "newStart": 1147,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "        messageIndex: payload.messageIndex,\n        nodeId: activeNodeId,\n+       treeId: activeTreeId,\n      });\n    };",
        "oldStart": 1159,
        "newStart": 1161,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning updates for selection and node message methods**

I'm deciding not to update getSelectionPayload now and postponing setSelectionPopover changes tied to the cancel button. Next, I'll investigate updating updateNodeMessages and updateNode calls, starting by searching for updateNodeMessages usages to confirm the expected new signature and treeId parameter.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "updateNodeMessages\\(",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "updateNodeMessages\\(",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 688,
                  "content": "      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;"
                },
                {
                  "lineNumber": 731,
                  "content": "        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;"
                },
                {
                  "lineNumber": 754,
                  "content": "      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;"
                },
                {
                  "lineNumber": 798,
                  "content": "      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;"
                },
                {
                  "lineNumber": 809,
                  "content": "    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;"
                },
                {
                  "lineNumber": 923,
                  "content": "    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; ["
                },
                {
                  "lineNumber": 940,
                  "content": "      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; ["
                },
                {
                  "lineNumber": 994,
                  "content": "      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;"
                },
                {
                  "lineNumber": 1010,
                  "content": "      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;"
                },
                {
                  "lineNumber": 1064,
                  "content": "      updateNodeMessages(newNodeId, (messages) =&gt; ["
                }
              ]
            }
          ],
          "totalLines": 10,
          "totalMatchedLines": 10
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking updateNodeMessages for treeId**

I'm reviewing the code around line 1060 to ensure updateNodeMessages includes treeId, verifying if the prior patch missed updating this usage.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating patch to include tree identifier**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "f917607f-30d5-4eb6-841b-971a665a4aeb",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "f917607f-30d5-4eb6-841b-971a665a4aeb",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n-           updateNode(newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n+           updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n          })\n          .catch(() =&gt; { });\n  \n        const reply = await replyPromise;\n-       updateNodeMessages(newNodeId, (messages) =&gt; [\n+       updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n          ...messages,\n          { role: \"assistant\", content: reply || \"No response returned.\" },\n        ]);\n-       updateNode(newNodeId, (node) =&gt; ({\n+       updateNode(treeId, newNodeId, (node) =&gt; ({\n          ...node,\n          requestStatus: \"ready\",",
        "oldStart": 1057,
        "newStart": 1057,
        "oldLines": 14,
        "newLines": 14,
        "linesRemoved": 3,
        "linesAdded": 3
      },
      {
        "diffString": "      } catch (err) {\n        setError(err.message || \"Failed to reach OpenAI.\");\n-       updateNode(newNodeId, (node) =&gt; ({\n+       updateNode(treeId, newNodeId, (node) =&gt; ({\n          ...node,\n          requestStatus: \"idle\",",
        "oldStart": 1073,
        "newStart": 1073,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                });\n                if (tempHighlight) {\n                  setNodesById((prev) =&gt; {\n                    const node = prev[tempHighlight.nodeId];\n                    if (!node) return prev;\n                    const idx = tempHighlight.messageIndex;\n                    const nextMessages = node.messages.map((m, i) =&gt; {\n                      if (i !== idx || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    });\n                    return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n                  });\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating updateNode calls with treeId**

I'm searching for updateNode calls missing the treeId argument to ensure all usages include it consistently.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "updateNode\\(",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "updateNode\\(",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 841,
                  "content": "    updateNode(activeTreeId, activeNodeId, (node) =&gt; {"
                },
                {
                  "lineNumber": 1059,
                  "content": "          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));"
                },
                {
                  "lineNumber": 1068,
                  "content": "      updateNode(treeId, newNodeId, (node) =&gt; ({"
                },
                {
                  "lineNumber": 1075,
                  "content": "      updateNode(treeId, newNodeId, (node) =&gt; ({"
                }
              ]
            }
          ],
          "totalLines": 4,
          "totalMatchedLines": 4
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Confirming node removal with setNodesById**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "setNodesById",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "setNodesById",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 1636,
                  "content": "                  setNodesById((prev) =&gt; {"
                }
              ]
            }
          ],
          "totalLines": 1,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Reviewing selection popover cancel**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating cancel block to handle null treeId**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "384cc970-2d84-4ab9-9043-1002c9d3bf5c",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "384cc970-2d84-4ab9-9043-1002c9d3bf5c",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "                    messageIndex: null,\n                    nodeId: null,\n+                   treeId: null,\n                  });\n                  if (tempHighlight) {\n-                   setNodesById((prev) =&gt; {\n-                     const node = prev[tempHighlight.nodeId];\n-                     if (!node) return prev;\n-                     const idx = tempHighlight.messageIndex;\n-                     const nextMessages = node.messages.map((m, i) =&gt; {\n-                       if (i !== idx || typeof m?.content !== \"string\") return m;\n+                   updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n+                     messages.map((m, i) =&gt; {\n+                       if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                        return {\n                          ...m,\n                          content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                        };\n-                     });\n-                     return { ...prev, [tempHighlight.nodeId]: { ...node, messages: nextMessages } };\n-                   });\n+                     }),\n+                   );\n                    setTempHighlight(null);\n                  }",
        "oldStart": 1632,
        "newStart": 1632,
        "oldLines": 19,
        "newLines": 16,
        "linesRemoved": 9,
        "linesAdded": 6
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const nodesWithNew = {\n        ...nodesById,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking for missing treeId in resets**

I'm searching for instances where `nodeId` is set to null without accompanying `treeId` updates to ensure consistent default state handling.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "nodeId: null",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "nodeId: null",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 428,
                  "content": "    nodeId: null,"
                },
                {
                  "lineNumber": 683,
                  "content": "        nodeId: null,"
                },
                {
                  "lineNumber": 726,
                  "content": "          nodeId: null,"
                },
                {
                  "lineNumber": 772,
                  "content": "      nodeId: null,"
                },
                {
                  "lineNumber": 1032,
                  "content": "      nodeId: null,"
                },
                {
                  "lineNumber": 1132,
                  "content": "          nodeId: null,"
                },
                {
                  "lineNumber": 1148,
                  "content": "          nodeId: null,"
                },
                {
                  "lineNumber": 1633,
                  "content": "                  nodeId: null,"
                }
              ]
            }
          ],
          "totalLines": 8,
          "totalMatchedLines": 8
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying treeId presence across state updates**

I'm confirming that the initial state includes treeId and examining multiple locations to ensure treeId is consistently present, starting with the code around lines 660-740 where related updates were made.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking additional occurrences**

I'm inspecting surrounding code near lines 1020 and 1120 to verify other similar updates beyond line 772.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating tree context in selection patch**

I'm fixing the setSelectionPopover to include treeId and adjusting nodesWithNew to use baseNodes and treeId to align with the earlier treeSnapshot update.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "504f5d5b-2d7a-41ad-96dd-d3c343041a30",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "504f5d5b-2d7a-41ad-96dd-d3c343041a30",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "        messageIndex: null,\n        nodeId: null,\n+       treeId: null,\n      });\n      window.getSelection()?.removeAllRanges?.();\n      try {\n        // Build context against a snapshot that includes the new node (setState is async).\n+       const treeSnapshot = treesById[treeId];\n+       const baseNodes = treeSnapshot?.nodesById || nodesById;\n        const nodesWithNew = {\n-         ...nodesById,\n+         ...baseNodes,\n          [newNodeId]: {\n            id: newNodeId,",
        "oldStart": 1031,
        "newStart": 1031,
        "oldLines": 10,
        "newLines": 13,
        "linesRemoved": 1,
        "linesAdded": 4
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;h1&gt;Chat Tree&lt;/h1&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying treeId null checks**

I'm reviewing other spots where nodeId is checked for null at lines 1132 and 1148 to add treeId null checks as well, focusing again around handleSelection near line 1120.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking selectionPopover state updates**

I'm reviewing useEffect around line 772 where treeId is set and verifying if selectionPopover state needs updates there or in handleSend; I'll also review all "treeId: null" occurrences for related state handling.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "nodeId: null,\\n\\s*treeId",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "nodeId: null,\\n\\s*treeId",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying nodeId null occurrences**

I'm rechecking all instances of null nodeId to confirm whether any also have a null treeId, ensuring resets consistently include treeId.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "nodeId: null",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "nodeId: null",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 428,
                  "content": "    nodeId: null,"
                },
                {
                  "lineNumber": 683,
                  "content": "        nodeId: null,"
                },
                {
                  "lineNumber": 726,
                  "content": "          nodeId: null,"
                },
                {
                  "lineNumber": 772,
                  "content": "      nodeId: null,"
                },
                {
                  "lineNumber": 1032,
                  "content": "      nodeId: null,"
                },
                {
                  "lineNumber": 1135,
                  "content": "          nodeId: null,"
                },
                {
                  "lineNumber": 1151,
                  "content": "          nodeId: null,"
                },
                {
                  "lineNumber": 1636,
                  "content": "                  nodeId: null,"
                }
              ]
            }
          ],
          "totalLines": 8,
          "totalMatchedLines": 8
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking presence of treeId near line 420**

I'm verifying whether treeId is included around line 420 to confirm its presence in the initial state near line 428.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating tempHighlight to handle treeId**

I'll revise the tempHighlight structure and all its usages to incorporate treeId, ensuring effects and setter calls correctly manage the new property. Next, I'll search for all setTempHighlight references to update them consistently.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "setTempHighlight",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "setTempHighlight",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 431,
                  "content": "  const [tempHighlight, setTempHighlight] = useState(null);"
                },
                {
                  "lineNumber": 694,
                  "content": "      setTempHighlight(null);"
                },
                {
                  "lineNumber": 737,
                  "content": "        setTempHighlight(null);"
                },
                {
                  "lineNumber": 764,
                  "content": "    setTempHighlight(null);"
                },
                {
                  "lineNumber": 818,
                  "content": "    setTempHighlight({"
                },
                {
                  "lineNumber": 1008,
                  "content": "      setTempHighlight(null);"
                },
                {
                  "lineNumber": 1649,
                  "content": "                  setTempHighlight(null);"
                }
              ]
            }
          ],
          "totalLines": 7,
          "totalMatchedLines": 7
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating sidebar header with tree list and new button**

I'm restructuring the sidebar header to include a title with tree count, a new tree button, and a tree list section between the title and view toggle, preparing to add corresponding CSS styles.
**Implementing tree list UI and selection handling**

I'm adding tree list rendering before the view toggle and wiring tree selection to update the active tree ID, ensuring the UI shows the tree list even if there's only one tree.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "bf3dc9dd-1920-4fc5-98b2-8b12aff9fdad",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "bf3dc9dd-1920-4fc5-98b2-8b12aff9fdad",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p&gt;{treeList.length} trees&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const branchCount = Math.max(Object.keys(tree.nodesById || {}).length - 1, 0);\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {branchCount} {branchCount === 1 ? \"branch\" : \"branches\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "        &gt;\n          &lt;div className=\"sidebar-header\"&gt;\n-           &lt;h1&gt;Chat Tree&lt;/h1&gt;\n+           &lt;div className=\"sidebar-title-row\"&gt;\n+             &lt;div&gt;\n+               &lt;h1&gt;Chat Tree&lt;/h1&gt;\n+               &lt;p&gt;{treeList.length} trees&lt;/p&gt;\n+             &lt;/div&gt;\n+             &lt;button\n+               type=\"button\"\n+               className=\"new-tree-button\"\n+               onClick={createNewTree}\n+             &gt;\n+               New tree\n+             &lt;/button&gt;\n+           &lt;/div&gt;\n+           &lt;div className=\"tree-list\"&gt;\n+             {treeList.map((tree) =&gt; {\n+               const branchCount = Math.max(Object.keys(tree.nodesById || {}).length - 1, 0);\n+               return (\n+                 &lt;button\n+                   key={tree.id}\n+                   type=\"button\"\n+                   className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n+                   onClick={() =&gt; setActiveTreeId(tree.id)}\n+                 &gt;\n+                   &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n+                   &lt;span className=\"tree-switch-meta\"&gt;\n+                     {branchCount} {branchCount === 1 ? \"branch\" : \"branches\"}\n+                   &lt;/span&gt;\n+                 &lt;/button&gt;\n+               );\n+             })}\n+           &lt;/div&gt;\n  \n            &lt;div className=\"view-toggle\"&gt;",
        "oldStart": 1315,
        "newStart": 1315,
        "oldLines": 5,
        "newLines": 35,
        "linesRemoved": 1,
        "linesAdded": 31
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p&gt;{treeList.length} trees&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const branchCount = Math.max(Object.keys(tree.nodesById || {}).length - 1, 0);\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {branchCount} {branchCount === 1 ? \"branch\" : \"branches\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding sidebar and tree CSS**

I'm preparing styles for new sidebar and tree-related classes with flex layouts, scroll for the tree list, and hover/active states for tree switches; these will be added near the existing sidebar header styles in styles.css.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "3da8ff0c-6fef-4107-a5eb-1586199ebf8c",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "3da8ff0c-6fef-4107-a5eb-1586199ebf8c",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 0;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow: auto;\n    padding-right: 2px;\n}\n\n.tree-switch {\n    width: 100%;\n    text-align: left;\n    border: 1px solid #2c3546;\n    background: #141821;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch:hover {\n    background: #1b2130;\n}\n\n.tree-switch.active {\n    border-color: #f8d34a;\n    background: #1f2532;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.5);\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 600;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      font-size: 20px;\n  }\n+ \n+ .sidebar-title-row {\n+     display: flex;\n+     align-items: center;\n+     justify-content: space-between;\n+     gap: 12px;\n+ }\n  \n  .sidebar-header p {",
        "oldStart": 60,
        "newStart": 60,
        "oldLines": 4,
        "newLines": 11,
        "linesAdded": 7
      },
      {
        "diffString": "      font-size: 13px;\n  }\n+ \n+ .new-tree-button {\n+     background: #2b3447;\n+     color: #e6e9ef;\n+     border: 1px solid #3c465a;\n+     border-radius: 10px;\n+     padding: 6px 10px;\n+     font-size: 12px;\n+     font-weight: 600;\n+     cursor: pointer;\n+     transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n+ }\n+ \n+ .new-tree-button:hover {\n+     background: #343e52;\n+     border-color: #4b5770;\n+ }\n+ \n+ .tree-list {\n+     display: flex;\n+     flex-direction: column;\n+     gap: 6px;\n+     max-height: 220px;\n+     overflow: auto;\n+     padding-right: 2px;\n+ }\n+ \n+ .tree-switch {\n+     width: 100%;\n+     text-align: left;\n+     border: 1px solid #2c3546;\n+     background: #141821;\n+     color: inherit;\n+     padding: 8px 10px;\n+     border-radius: 10px;\n+     cursor: pointer;\n+     display: flex;\n+     align-items: center;\n+     justify-content: space-between;\n+     gap: 10px;\n+ }\n+ \n+ .tree-switch:hover {\n+     background: #1b2130;\n+ }\n+ \n+ .tree-switch.active {\n+     border-color: #f8d34a;\n+     background: #1f2532;\n+     box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.5);\n+ }\n+ \n+ .tree-switch-title {\n+     font-size: 13px;\n+     font-weight: 600;\n+     overflow: hidden;\n+     text-overflow: ellipsis;\n+     white-space: nowrap;\n+ }\n+ \n+ .tree-switch-meta {\n+     font-size: 11px;\n+     color: #9aa3b2;\n+     white-space: nowrap;\n+ }\n  \n  .view-toggle {",
        "oldStart": 66,
        "newStart": 73,
        "oldLines": 4,
        "newLines": 69,
        "linesAdded": 65
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 0;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow: auto;\n    padding-right: 2px;\n}\n\n.tree-switch {\n    width: 100%;\n    text-align: left;\n    border: 1px solid #2c3546;\n    background: #141821;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch:hover {\n    background: #1b2130;\n}\n\n.tree-switch.active {\n    border-color: #f8d34a;\n    background: #1f2532;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.5);\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 600;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Refining tree and node state references**

I'm verifying that selection popover effects, click outside handling, and message updates correctly use the active tree ID and nodesById scoped per tree, ensuring temporary highlights and node snapshots respect active trees; also confirming sidebarRef was pre-existing and adjusting related functions accordingly.
**Ensuring active tree consistency in async updates**

I confirmed activeNodeId syncs with activeTreeId on tree switches and that async handlers like handleSend correctly capture activeTreeId in closures to avoid mismatches on response. I'm verifying all selectionPopover and nodesById references include active tree context and checking setSelectionPopover calls for proper treeId usage.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "setSelectionPopover\\(",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "setSelectionPopover\\(",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 676,
                  "content": "      setSelectionPopover({"
                },
                {
                  "lineNumber": 703,
                  "content": "          setSelectionPopover({"
                },
                {
                  "lineNumber": 719,
                  "content": "        setSelectionPopover({"
                },
                {
                  "lineNumber": 765,
                  "content": "    setSelectionPopover({"
                },
                {
                  "lineNumber": 1025,
                  "content": "    setSelectionPopover({"
                },
                {
                  "lineNumber": 1128,
                  "content": "        setSelectionPopover({"
                },
                {
                  "lineNumber": 1144,
                  "content": "        setSelectionPopover({"
                },
                {
                  "lineNumber": 1158,
                  "content": "    setSelectionPopover({"
                },
                {
                  "lineNumber": 1647,
                  "content": "              setSelectionPopover((prev) =&gt; ({"
                },
                {
                  "lineNumber": 1659,
                  "content": "                setSelectionPopover({"
                }
              ]
            }
          ],
          "totalLines": 10,
          "totalMatchedLines": 10
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking for remaining treeId usage**

I'm reviewing code near line 1158 around the selection popover handler to see if treeId is used there and needs updating.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Confirming state and persistence updates**

The tempHighlight and activeTreeId structures are aligned with usage and persistence plans; createInitialTreeState no longer depends on useMemo in components. Unique naming for new trees and handling tree deletions remain to be implemented.</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Inspect current tree/chat state management and UI
- [x] Locate persistence layer and add chat/tree storage
- [x] Add UI to create tree and list all trees

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking usage of sidebarRef**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "sidebarRef",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "sidebarRef",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 437,
                  "content": "  const sidebarRef = useRef(null);"
                },
                {
                  "lineNumber": 1271,
                  "content": "    const sidebar = sidebarRef.current;"
                },
                {
                  "lineNumber": 1314,
                  "content": "        ref={sidebarRef}"
                }
              ]
            }
          ],
          "totalLines": 3,
          "totalMatchedLines": 3
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating functions and checking lint**

I'm updating functions that use activeNodeId and nodesById in the hidden context and view toggle logic, adding persistence for the active tree, then running lint checks on App.jsx and styles.css.</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`
- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Confirming state handling and data persistence**

The selection popover and temp highlight treeId are managed carefully to avoid null issues, with effects resetting them appropriately on active tree changes. Tree creation relies on the current tree list length to prevent duplicates, and node message updates reference the correct tree. The updated tree list count will reflect in the header, and context for nodes is built from the selected tree's nodesById. Data persists via localStorage, with no deletion implemented yet. Next is to explain these changes clearly and mention possible future features like renaming and deleting trees.
**Outlining response structure and key details**

The final explanation will start with a brief overview followed by deeper details, including data persistence under the localStorage key `chat-trees:v1`. It will describe creating new trees via the "New tree" button in the sidebar and note that tree titles update automatically based on the first root message.</details></think>

---

Chats now persist across reloads and you can create/switch between multiple trees from the sidebar. I added a stored tree collection with an active tree pointer in `localStorage`, plus a tree list UI with a “New tree” button and branch counts; tree titles auto-fill from the first root message.

Details:
- Persisted state in `localStorage` under `chat-trees:v1` and hydrate on load, keeping all nodes/messages/highlights per tree.
- Added tree list + create button in the sidebar and wired switching to per‑tree active node state.
- Auto-title new trees from the first root message for easier identification.

If you want rename/delete actions or import/export, I can add those next.

---

_**User (2026-01-18 15:24Z)**_

1 trees -> 1 tree

Make the outline of current a lot more subtle, e.g. no border but just bg light change as in screenshot with difference between not selected, selected, hovered

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Editing label and styles**

I'm preparing to update App.jsx for the tree count label with proper pluralization and adjust styles for the tree-switch component using apply_patch.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "bc8c83d8-08f9-4b2d-a43a-b46af76e6076",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "bc8c83d8-08f9-4b2d-a43a-b46af76e6076",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p&gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const branchCount = Math.max(Object.keys(tree.nodesById || {}).length - 1, 0);\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {branchCount} {branchCount === 1 ? \"branch\" : \"branches\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "              &lt;div&gt;\n                &lt;h1&gt;Chat Tree&lt;/h1&gt;\n-               &lt;p&gt;{treeList.length} trees&lt;/p&gt;\n+               &lt;p&gt;\n+                 {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n+               &lt;/p&gt;\n              &lt;/div&gt;\n              &lt;button",
        "oldStart": 1318,
        "newStart": 1318,
        "oldLines": 5,
        "newLines": 7,
        "linesRemoved": 1,
        "linesAdded": 3
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p&gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const branchCount = Math.max(Object.keys(tree.nodesById || {}).length - 1, 0);\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {branchCount} {branchCount === 1 ? \"branch\" : \"branches\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "603473e1-81ec-41e6-8774-c1381a9802c5",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "603473e1-81ec-41e6-8774-c1381a9802c5",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 0;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow: auto;\n    padding-right: 2px;\n}\n\n.tree-switch {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: #141821;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch:hover {\n    background: #1a2030;\n}\n\n.tree-switch.active {\n    background: #212838;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 600;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      width: 100%;\n      text-align: left;\n-     border: 1px solid #2c3546;\n+     border: none;\n      background: #141821;\n      color: inherit;",
        "oldStart": 103,
        "newStart": 103,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      },
      {
        "diffString": "  \n  .tree-switch:hover {\n-     background: #1b2130;\n+     background: #1a2030;\n  }\n  \n  .tree-switch.active {\n-     border-color: #f8d34a;\n-     background: #1f2532;\n-     box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.5);\n+     background: #212838;\n  }\n  ",
        "oldStart": 116,
        "newStart": 116,
        "oldLines": 11,
        "newLines": 9,
        "linesRemoved": 4,
        "linesAdded": 2
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 0;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow: auto;\n    padding-right: 2px;\n}\n\n.tree-switch {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: #141821;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch:hover {\n    background: #1a2030;\n}\n\n.tree-switch.active {\n    background: #212838;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 600;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`
- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results


**No lint errors found**
</details>
</tool-use>

---

Updated the tree count label to singular/plural and made the active outline subtle (no border, just background shifts for default/hover/active).

- Pluralization fix in `src/App.jsx`
- Subtle background-only states in `src/styles.css`

If you want the hover/active contrast even softer or different shades, tell me the exact colors you prefer.

---

_**User (2026-01-18 15:24Z)**_

more margin bottom between number of trees and tree list

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Adjusting CSS for spacing**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "0c0f5e5e-4f3f-48bb-b0c2-7d4cb3a9dc93",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "0c0f5e5e-4f3f-48bb-b0c2-7d4cb3a9dc93",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow: auto;\n    padding-right: 2px;\n}\n\n.tree-switch {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: #141821;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch:hover {\n    background: #1a2030;\n}\n\n.tree-switch.active {\n    background: #212838;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 600;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  \n  .sidebar-header p {\n-     margin: 6px 0 0;\n+     margin: 6px 0 12px;\n      color: #9aa3b2;\n      font-size: 13px;",
        "oldStart": 69,
        "newStart": 69,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow: auto;\n    padding-right: 2px;\n}\n\n.tree-switch {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: #141821;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch:hover {\n    background: #1a2030;\n}\n\n.tree-switch.active {\n    background: #212838;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 600;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results


**No lint errors found**
</details>
</tool-use>

---

Added more space under the tree count label by increasing the bottom margin in `src/styles.css`.

---

_**User (2026-01-18 15:24Z)**_

count number of nodes and not number of branches

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Updating tree label to nodes count**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "8e042c6e-35b3-48e1-b132-0157dcfd1b65",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "8e042c6e-35b3-48e1-b132-0157dcfd1b65",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "            &lt;div className=\"tree-list\"&gt;\n              {treeList.map((tree) =&gt; {\n-               const branchCount = Math.max(Object.keys(tree.nodesById || {}).length - 1, 0);\n+               const nodeCount = Object.keys(tree.nodesById || {}).length;\n                return (\n                  &lt;button",
        "oldStart": 1332,
        "newStart": 1332,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      },
      {
        "diffString": "                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n-                     {branchCount} {branchCount === 1 ? \"branch\" : \"branches\"}\n+                     {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/button&gt;",
        "oldStart": 1342,
        "newStart": 1342,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`

Lint results


**No lint errors found**
</details>
</tool-use>

---

Updated the tree list to show node counts (and singular/plural “node(s)”) instead of branches in `src/App.jsx`.

---

_**User (2026-01-18 15:24Z)**_

Use an AI call for naming the tree, and give three dots option when hovering tree name to give option to rename or delete

---

_**Agent (model gpt-5.2, mode Agent)**_



---

Got it—next I’ll (1) add a small “…” hover menu on each tree row with Rename/Delete, and (2) switch tree naming to an OpenAI call (with a safe fallback if the call fails). I’ll update `src/App.jsx` for the UI/state and `src/styles.css` for the hover/menu styling.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---



---

Nice — we already have the OpenAI helper in place (`sendToOpenAI`), so I’m going to reuse that to generate a better 2–5 word tree title on the first root message, then add a hover-only “…” menu per tree with Rename/Delete (no nested buttons, proper click-outside close).

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "ce1d874e-ed31-4c69-aa11-4dc53b533550",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "ce1d874e-ed31-4c69-aa11-4dc53b533550",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      treeId: null,\n    });\n+   const [treeMenu, setTreeMenu] = useState({\n+     visible: false,\n+     treeId: null,\n+     rect: null,\n+     mode: \"menu\",\n+     draft: \"\",\n+   });\n    const [tempHighlight, setTempHighlight] = useState(null);\n  \n    const chatAreaRef = useRef(null);\n    const inputRef = useRef(null);\n    const popoverRef = useRef(null);\n+   const treeMenuRef = useRef(null);\n    const graphContainerRef = useRef(null);\n    const sidebarRef = useRef(null);",
        "oldStart": 429,
        "newStart": 429,
        "oldLines": 9,
        "newLines": 17,
        "linesAdded": 8
      },
      {
        "diffString": "      setTreeView(\"graph\");\n    };\n+ \n+   const closeTreeMenu = () =&gt; {\n+     setTreeMenu({\n+       visible: false,\n+       treeId: null,\n+       rect: null,\n+       mode: \"menu\",\n+       draft: \"\",\n+     });\n+   };\n+ \n+   const openTreeMenu = (treeId, event) =&gt; {\n+     event.preventDefault();\n+     event.stopPropagation();\n+     const buttonRect = event.currentTarget.getBoundingClientRect();\n+     const left = Math.min(buttonRect.left, window.innerWidth - 260);\n+     setTreeMenu({\n+       visible: true,\n+       treeId,\n+       rect: { top: buttonRect.bottom + 8, left },\n+       mode: \"menu\",\n+       draft: treesById[treeId]?.title ?? \"\",\n+     });\n+   };\n+ \n+   const deleteTree = (treeId) =&gt; {\n+     const tree = treesById[treeId];\n+     if (!tree) return;\n+     const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n+     if (!ok) return;\n+ \n+     setTreesById((prev) =&gt; {\n+       const next = { ...prev };\n+       delete next[treeId];\n+       const remainingIds = Object.keys(next);\n+       if (!remainingIds.length) {\n+         const fresh = createTree(\"New tree\");\n+         next[fresh.id] = fresh;\n+       }\n+       return next;\n+     });\n+ \n+     closeTreeMenu();\n+ \n+     if (activeTreeId === treeId) {\n+       const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n+       if (remaining.length) {\n+         setActiveTreeId(remaining[0].id);\n+       } else {\n+         // Will be set by the activeTreeId/treeList effect after state update.\n+         setActiveTreeId(null);\n+       }\n+     }\n+   };\n+ \n+   const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n+     const prompt = [\n+       \"Generate a concise 2-5 word title for this conversation.\",\n+       \"Return only the title, no quotes or punctuation.\",\n+       \"\",\n+       &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n+       assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n+     ]\n+       .filter(Boolean)\n+       .join(\"\\n\");\n+     return sendToOpenAI([{ role: \"user\", content: prompt }]);\n+   };\n  \n    useLayoutEffect(() =&gt; {",
        "oldStart": 649,
        "newStart": 657,
        "oldLines": 4,
        "newLines": 71,
        "linesAdded": 67
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "2d136b07-3a08-436c-8525-0ba7334834fa",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "2d136b07-3a08-436c-8525-0ba7334834fa",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      }\n    });\n+ \n+   useClickOutside(treeMenuRef, () =&gt; {\n+     if (treeMenu.visible) closeTreeMenu();\n+   });\n  \n    useEffect(() =&gt; {",
        "oldStart": 770,
        "newStart": 770,
        "oldLines": 4,
        "newLines": 8,
        "linesAdded": 4
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    if (activeNodeId === \"root\") {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\") return tree;\n        return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "3dcb2b66-773f-476c-9dd5-98563f92c496",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "3dcb2b66-773f-476c-9dd5-98563f92c496",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    const fallbackTitle = summarizeTitle(trimmed) || \"New tree\";\n    if (isFirstRootTurn) {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\" &amp;&amp; !/^Tree \\d+$/.test(tree.title)) return tree;\n        return { ...tree, title: fallbackTitle };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n\n      if (isFirstRootTurn &amp;&amp; treeSnapshot) {\n        requestTreeTitle(trimmed, reply || \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (tree.title !== fallbackTitle) return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      const trimmed = content.trim();\n      const nodeSnapshot = nodesById[activeNodeId];\n+     const treeIdSnapshot = activeTreeId;\n+     const treeSnapshot = treesById[treeIdSnapshot];\n+     const isFirstRootTurn =\n+       activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n      const hiddenContext = shouldShowContext\n        ? buildHiddenContextForNode(activeNodeId, nodesById)",
        "oldStart": 997,
        "newStart": 997,
        "oldLines": 4,
        "newLines": 8,
        "linesAdded": 4
      },
      {
        "diffString": "        { role: \"user\", content: trimmed },\n      ]);\n-     if (activeNodeId === \"root\") {\n+     const fallbackTitle = summarizeTitle(trimmed) || \"New tree\";\n+     if (isFirstRootTurn) {\n        updateTree(activeTreeId, (tree) =&gt; {\n-         if (tree.title !== \"New tree\") return tree;\n-         return { ...tree, title: summarizeTitle(trimmed) || tree.title };\n+         if (tree.title !== \"New tree\" &amp;&amp; !/^Tree \\d+$/.test(tree.title)) return tree;\n+         return { ...tree, title: fallbackTitle };\n        });\n      }",
        "oldStart": 1004,
        "newStart": 1008,
        "oldLines": 8,
        "newLines": 9,
        "linesRemoved": 3,
        "linesAdded": 4
      },
      {
        "diffString": "          { role: \"assistant\", content: reply || \"No response returned.\" },\n        ]);\n+ \n+       if (isFirstRootTurn &amp;&amp; treeSnapshot) {\n+         requestTreeTitle(trimmed, reply || \"\")\n+           .then((title) =&gt; {\n+             const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n+             updateTree(treeIdSnapshot, (tree) =&gt; {\n+               if (!tree) return tree;\n+               // Don't override if the user renamed it in the meantime.\n+               if (tree.title !== fallbackTitle) return tree;\n+               return { ...tree, title: nextTitle };\n+             });\n+           })\n+           .catch(() =&gt; { });\n+       }\n      } catch (err) {\n        setError(err.message || \"Failed to reach OpenAI.\");",
        "oldStart": 1021,
        "newStart": 1026,
        "oldLines": 4,
        "newLines": 18,
        "linesAdded": 14
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    const fallbackTitle = summarizeTitle(trimmed) || \"New tree\";\n    if (isFirstRootTurn) {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\" &amp;&amp; !/^Tree \\d+$/.test(tree.title)) return tree;\n        return { ...tree, title: fallbackTitle };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n\n      if (isFirstRootTurn &amp;&amp; treeSnapshot) {\n        requestTreeTitle(trimmed, reply || \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (tree.title !== fallbackTitle) return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              return (\n                &lt;button\n                  key={tree.id}\n                  type=\"button\"\n                  className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n                  onClick={() =&gt; setActiveTreeId(tree.id)}\n                &gt;\n                  &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;span className=\"tree-switch-meta\"&gt;\n                    {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                  &lt;/span&gt;\n                &lt;/button&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

Nice—tree naming is now truly “AI-first”: we set a reasonable fallback immediately for responsiveness, then replace it with an OpenAI-generated 2–5 word title once the first assistant reply comes back (and we won’t override if you rename it meanwhile). Next up is refactoring the tree list row so we can add the “…” menu without invalid nested buttons.

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "00b618bc-7689-4f0e-a8df-526108c3b116",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "00b618bc-7689-4f0e-a8df-526108c3b116",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    const fallbackTitle = summarizeTitle(trimmed) || \"New tree\";\n    if (isFirstRootTurn) {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\" &amp;&amp; !/^Tree \\d+$/.test(tree.title)) return tree;\n        return { ...tree, title: fallbackTitle };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n\n      if (isFirstRootTurn &amp;&amp; treeSnapshot) {\n        requestTreeTitle(trimmed, reply || \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (tree.title !== fallbackTitle) return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-actions-button\"\n                    aria-label=\"Tree options\"\n                    title=\"Options\"\n                    onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "              {treeList.map((tree) =&gt; {\n                const nodeCount = Object.keys(tree.nodesById || {}).length;\n+               const isActive = tree.id === activeTreeId;\n                return (\n-                 &lt;button\n+                 &lt;div\n                    key={tree.id}\n-                   type=\"button\"\n-                   className={&#96;tree-switch ${tree.id === activeTreeId ? \"active\" : \"\"}&#96;}\n-                   onClick={() =&gt; setActiveTreeId(tree.id)}\n-                 &gt;\n-                   &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n-                   &lt;span className=\"tree-switch-meta\"&gt;\n-                     {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n-                   &lt;/span&gt;\n-                 &lt;/button&gt;\n+                   className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n+                 &gt;\n+                   &lt;button\n+                     type=\"button\"\n+                     className=\"tree-switch\"\n+                     onClick={() =&gt; setActiveTreeId(tree.id)}\n+                   &gt;\n+                     &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n+                     &lt;span className=\"tree-switch-meta\"&gt;\n+                       {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n+                     &lt;/span&gt;\n+                   &lt;/button&gt;\n+                   &lt;button\n+                     type=\"button\"\n+                     className=\"tree-actions-button\"\n+                     aria-label=\"Tree options\"\n+                     title=\"Options\"\n+                     onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n+                   &gt;\n+                     &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n+                       &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n+                       &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n+                       &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n+                     &lt;/svg&gt;\n+                   &lt;/button&gt;\n+                 &lt;/div&gt;\n                );\n              })}",
        "oldStart": 1451,
        "newStart": 1451,
        "oldLines": 16,
        "newLines": 34,
        "linesRemoved": 10,
        "linesAdded": 28
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    const fallbackTitle = summarizeTitle(trimmed) || \"New tree\";\n    if (isFirstRootTurn) {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\" &amp;&amp; !/^Tree \\d+$/.test(tree.title)) return tree;\n        return { ...tree, title: fallbackTitle };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n\n      if (isFirstRootTurn &amp;&amp; treeSnapshot) {\n        requestTreeTitle(trimmed, reply || \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (tree.title !== fallbackTitle) return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-actions-button\"\n                    aria-label=\"Tree options\"\n                    title=\"Options\"\n                    onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "a91f039d-e528-4c04-b29c-820fe89762c0",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "a91f039d-e528-4c04-b29c-820fe89762c0",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    const fallbackTitle = summarizeTitle(trimmed) || \"New tree\";\n    if (isFirstRootTurn) {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\" &amp;&amp; !/^Tree \\d+$/.test(tree.title)) return tree;\n        return { ...tree, title: fallbackTitle };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n\n      if (isFirstRootTurn &amp;&amp; treeSnapshot) {\n        requestTreeTitle(trimmed, reply || \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (tree.title !== fallbackTitle) return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-actions-button\"\n                    aria-label=\"Tree options\"\n                    title=\"Options\"\n                    onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "          &lt;/div&gt;\n        )}\n+       {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n+         &lt;div\n+           ref={treeMenuRef}\n+           className=\"tree-menu-popover\"\n+           style={{\n+             top: &#96;${treeMenu.rect.top}px&#96;,\n+             left: &#96;${treeMenu.rect.left}px&#96;,\n+           }}\n+           role=\"dialog\"\n+           aria-label=\"Tree options\"\n+         &gt;\n+           {treeMenu.mode === \"rename\" ? (\n+             &lt;&gt;\n+               &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n+               &lt;input\n+                 className=\"tree-menu-input\"\n+                 value={treeMenu.draft}\n+                 onChange={(e) =&gt;\n+                   setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n+                 }\n+                 placeholder=\"Tree name\"\n+                 autoFocus\n+               /&gt;\n+               &lt;div className=\"tree-menu-actions\"&gt;\n+                 &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n+                   Cancel\n+                 &lt;/button&gt;\n+                 &lt;button\n+                   type=\"button\"\n+                   className=\"primary\"\n+                   onClick={() =&gt; {\n+                     const nextTitle = (treeMenu.draft || \"\").trim();\n+                     if (!nextTitle) return;\n+                     updateTree(treeMenu.treeId, (tree) =&gt; ({\n+                       ...tree,\n+                       title: nextTitle,\n+                       updatedAt: Date.now(),\n+                     }));\n+                     closeTreeMenu();\n+                   }}\n+                   disabled={!treeMenu.draft.trim()}\n+                 &gt;\n+                   Save\n+                 &lt;/button&gt;\n+               &lt;/div&gt;\n+             &lt;/&gt;\n+           ) : (\n+             &lt;&gt;\n+               &lt;button\n+                 type=\"button\"\n+                 className=\"tree-menu-item\"\n+                 onClick={() =&gt;\n+                   setTreeMenu((prev) =&gt; ({\n+                     ...prev,\n+                     mode: \"rename\",\n+                     draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n+                   }))\n+                 }\n+               &gt;\n+                 Rename\n+               &lt;/button&gt;\n+               &lt;button\n+                 type=\"button\"\n+                 className=\"tree-menu-item danger\"\n+                 onClick={() =&gt; deleteTree(treeMenu.treeId)}\n+               &gt;\n+                 Delete\n+               &lt;/button&gt;\n+             &lt;/&gt;\n+           )}\n+         &lt;/div&gt;\n+       )}\n      &lt;/div&gt;\n    );",
        "oldStart": 1833,
        "newStart": 1833,
        "oldLines": 4,
        "newLines": 76,
        "linesAdded": 72
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const createNewTree = () =&gt; {\n    const nextIndex = treeList.length + 1;\n    const tree = createTree(&#96;Tree ${nextIndex}&#96;);\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n    const fallbackTitle = summarizeTitle(trimmed) || \"New tree\";\n    if (isFirstRootTurn) {\n      updateTree(activeTreeId, (tree) =&gt; {\n        if (tree.title !== \"New tree\" &amp;&amp; !/^Tree \\d+$/.test(tree.title)) return tree;\n        return { ...tree, title: fallbackTitle };\n      });\n    }\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const reply = await sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n\n      if (isFirstRootTurn &amp;&amp; treeSnapshot) {\n        requestTreeTitle(trimmed, reply || \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (tree.title !== fallbackTitle) return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;button\n              type=\"button\"\n              className=\"new-tree-button\"\n              onClick={createNewTree}\n            &gt;\n              New tree\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {treeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-actions-button\"\n                    aria-label=\"Tree options\"\n                    title=\"Options\"\n                    onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;span className=\"chat-meta\"&gt;\n                    {activeNode.messages.length} messages\n                  &lt;/span&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "a24257d9-8933-4a2b-8ca6-ed5ec2fc0bb8",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "a24257d9-8933-4a2b-8ca6-ed5ec2fc0bb8",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow: auto;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    width: 100%;\n    flex: 1;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 600;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      padding-right: 2px;\n  }\n+ \n+ .tree-switch-row {\n+     display: flex;\n+     align-items: center;\n+     gap: 6px;\n+     border-radius: 10px;\n+     background: #141821;\n+ }\n+ \n+ .tree-switch-row:hover {\n+     background: #1a2030;\n+ }\n+ \n+ .tree-switch-row.active {\n+     background: #212838;\n+ }\n  \n  .tree-switch {\n      width: 100%;\n+     flex: 1;\n      text-align: left;\n      border: none;\n-     background: #141821;\n+     background: transparent;\n      color: inherit;\n      padding: 8px 10px;",
        "oldStart": 99,
        "newStart": 99,
        "oldLines": 10,
        "newLines": 27,
        "linesRemoved": 1,
        "linesAdded": 18
      },
      {
        "diffString": "  }\n  \n- .tree-switch:hover {\n-     background: #1a2030;\n+ .tree-actions-button {\n+     width: 34px;\n+     height: 34px;\n+     border-radius: 10px;\n+     border: none;\n+     background: transparent;\n+     color: #9aa3b2;\n+     cursor: pointer;\n+     display: inline-flex;\n+     align-items: center;\n+     justify-content: center;\n+     opacity: 0;\n+     transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n  }\n  \n- .tree-switch.active {\n-     background: #212838;\n+ .tree-switch-row:hover .tree-actions-button,\n+ .tree-switch-row:focus-within .tree-actions-button {\n+     opacity: 1;\n+ }\n+ \n+ .tree-actions-button:hover {\n+     background: rgba(255, 255, 255, 0.06);\n+     color: #e6e9ef;\n+ }\n+ \n+ .tree-actions-button svg {\n+     width: 18px;\n+     height: 18px;\n+     fill: currentColor;\n  }\n  ",
        "oldStart": 115,
        "newStart": 132,
        "oldLines": 10,
        "newLines": 33,
        "linesRemoved": 4,
        "linesAdded": 27
      },
      {
        "diffString": "      white-space: nowrap;\n  }\n+ \n+ .tree-menu-popover {\n+     position: fixed;\n+     width: 220px;\n+     background: #1b202b;\n+     border: 1px solid #2c3546;\n+     border-radius: 12px;\n+     padding: 8px;\n+     z-index: 1800;\n+     box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n+ }\n+ \n+ .tree-menu-item {\n+     width: 100%;\n+     text-align: left;\n+     border: none;\n+     background: transparent;\n+     color: #e6e9ef;\n+     padding: 8px 10px;\n+     border-radius: 10px;\n+     cursor: pointer;\n+ }\n+ \n+ .tree-menu-item:hover {\n+     background: #1f2532;\n+ }\n+ \n+ .tree-menu-item.danger {\n+     color: #fca5a5;\n+ }\n+ \n+ .tree-menu-title {\n+     font-size: 13px;\n+     color: #9aa3b2;\n+     margin: 2px 4px 8px;\n+ }\n+ \n+ .tree-menu-input {\n+     width: 100%;\n+     background: #141821;\n+     border: 1px solid #2c3546;\n+     color: #e6e9ef;\n+     border-radius: 10px;\n+     padding: 8px 10px;\n+     margin-bottom: 10px;\n+ }\n+ \n+ .tree-menu-actions {\n+     display: flex;\n+     justify-content: flex-end;\n+     gap: 8px;\n+ }\n+ \n+ .tree-menu-actions button {\n+     background: transparent;\n+     border: 1px solid #374156;\n+     color: #e6e9ef;\n+     padding: 6px 10px;\n+     border-radius: 8px;\n+     cursor: pointer;\n+ }\n+ \n+ .tree-menu-actions .primary {\n+     background: #4f77ff;\n+     border: none;\n+ }\n  \n  .view-toggle {",
        "oldStart": 136,
        "newStart": 176,
        "oldLines": 4,
        "newLines": 70,
        "linesAdded": 66
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow: auto;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    width: 100%;\n    flex: 1;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 600;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`
- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results


**No lint errors found**
</details>
</tool-use>

---

Implemented both changes:

### AI tree naming
- On the **first message in a new tree’s root**, we now kick off an **OpenAI call** to generate a **2–5 word** title and update the tree title when it returns.
- We keep a **quick fallback title** immediately for responsiveness, and **won’t overwrite** if you manually rename it before the AI responds.

### “…” hover menu (Rename / Delete)
- Added a **three-dots button** that appears on hover/focus for each tree row.
- Clicking it opens a small popover with **Rename** (inline input) and **Delete** (with confirm).
- No nested buttons (valid HTML), click-outside closes the menu.

Files changed:
- `src/App.jsx`
- `src/styles.css`

---

