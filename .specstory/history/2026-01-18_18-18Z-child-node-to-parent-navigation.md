<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 1c977267-5397-43ad-8914-8bf19a4f0c49 (2026-01-18 18:18Z) -->

# Child node to parent navigation (2026-01-18 18:18Z)

_**User (2026-01-18 15:24Z)**_

when I'm on a child node, in the top message give me a nice way to teleport myself back to the parent's node corresponding highlight

---

_**Agent (model gpt-5.2, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Exploring React feature implementation**

I'm working on a feature for a React app that will show a tree structure with highlights. I'll focus on the App.jsx file and consider using tools. The plan is to add a UI element, like a breadcrumb or "Jump to parent" link at the top, which will allow users to scroll to the parent node and highlight it. I’ll make sure to implement this based on the existing state, and I'll need to inspect everything carefully.</details></think>

---

Got it. I’m going to find where the “top message” is rendered and how node selection/highlighting works, then add a small “Jump to parent” action that (a) switches selection to the parent node and (b) scrolls/centers the parent highlight so it’s immediately visible. Let me inspect `src/App.jsx` and any helper code involved.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/main.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Determining top message context**

I need to find the "top message," which might be called the "context bar" above the chat. I’ll need to highlight the parent node and understand the relationships. Looking at nodesById and childrenMap is important, and I should also check the parentMap. I’ll search for parent references and grep for parentId to get the right context. This is a bit complex, but I’ll get there!</details></think>

---

Nice — the app already has a custom “branch highlight” mechanism embedded in message markdown (`[[[hl:highlightId:branchNodeId]]]...[[[/hl]]]`), plus an `activeNodeId` that controls which node you’re “on”. Next I’ll locate the top message UI and the node parent relationship so we can add a “Jump to parent” control that selects the parent node and centers its corresponding highlight.

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "parentId|parent_id|parent\b" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 9 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `parentId: null,` | L261 |
| `src/App.jsx` | `const parent = node.parentId ?? "root-parent";` | L322 |
| `src/App.jsx` | `if (!map[parent]) \{` | L323 |
| `src/App.jsx` | `map[parent] = [];` | L324 |
| `src/App.jsx` | `map[parent].push(node.id);` | L326 |
| `src/App.jsx` | `currentId = nodesById[currentId].parentId;` | L345 |
| `src/App.jsx` | `const addNode = (treeId, parentId, title, messages, extra = \{}, options = \{}) => \{` | L934 |
| `src/App.jsx` | `parentId,` | L941 |
| `src/App.jsx` | `parentId: sourceNodeId,` | L1155 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "top message|top-message|toast|banner|status|context" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 48 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `const truncateForContext = (text, maxChars) => \{` | L331 |
| `src/App.jsx` | `const buildHiddenContextForNode = (nodeId, nodesById) => \{` | L350 |
| `src/App.jsx` | `"Hidden context for the assistant (do not repeat verbatim unless asked):",` | L367 |
| `src/App.jsx` | `const excerpt = node?.branchContext?.excerpt;` | L371 |
| `src/App.jsx` | `lines.push(`Branch highlight excerpt:\n"""$\{truncateForContext(excerpt, 1200)\}"""`);` | L373 |
| `src/App.jsx` | `.map((m) => `$\{m.role\}: $\{truncateForContext(m.content ?? "", 220)\}`)` | L385 |
| `src/App.jsx` | `const [isContextModalOpen, setIsContextModalOpen] = useState(false);` | L421 |
| `src/App.jsx` | `const shouldShowContext = activeNodeId !== "root";` | L465 |
| `src/App.jsx` | ``User: $\{truncateForContext(userMessage, 300)\}`,` | L723 |
| `src/App.jsx` | `assistantMessage ? `Assistant: $\{truncateForContext(assistantMessage, 360)\}` : "",` | L724 |
| `src/App.jsx` | `if (!shouldShowContext && isContextModalOpen) \{` | L917 |
| `src/App.jsx` | `setIsContextModalOpen(false);` | L918 |
| `src/App.jsx` | `\}, [shouldShowContext, isContextModalOpen]);` | L920 |
| `src/App.jsx` | `requestStatus: node.requestStatus === "ready" ? "idle" : node.requestStatus,` | L929 |
| `src/App.jsx` | `const sendToOpenAI = async (messages, hiddenContext = "") => \{` | L953 |
| `src/App.jsx` | `if (hiddenContext && hiddenContext.trim()) \{` | L959 |
| `src/App.jsx` | `systemMessages.push(\{ role: "system", content: hiddenContext.trim() \});` | L960 |
| `src/App.jsx` | `throw new Error(`OpenAI error $\{response.status\}: $\{details\}`);` | L976 |
| `src/App.jsx` | ``User request: $\{truncateForContext(userMessage, 240)\}`,` | L987 |
| `src/App.jsx` | `? `Selected excerpt: $\{truncateForContext(branchExcerpt, 240)\}`` | L989 |
| `src/App.jsx` | `const hiddenContext = shouldShowContext` | L1007 |
| `src/App.jsx` | `? buildHiddenContextForNode(activeNodeId, nodesById)` | L1008 |
| `src/App.jsx` | `hiddenContext,` | L1027 |
| `src/App.jsx` | `branchContext: \{` | L1093 |
| `src/App.jsx` | `requestStatus: "pending",` | L1098 |
| `src/App.jsx` | `// Build context against a snapshot that includes the new node (setState is async).` | L1148 |
| `src/App.jsx` | `branchContext: \{` | L1158 |
| `src/App.jsx` | `requestStatus: "pending",` | L1163 |
| `src/App.jsx` | `const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);` | L1167 |
| `src/App.jsx` | `const replyPromise = sendToOpenAI([\{ role: "user", content: userMessage \}], hiddenContext);` | L1168 |
| `src/App.jsx` | `requestStatus: "ready",` | L1184 |
| `src/App.jsx` | `requestStatus: "idle",` | L1191 |
| `src/App.jsx` | `const isPending = node?.requestStatus === "pending";` | L1284 |
| `src/App.jsx` | `const isPending = node?.requestStatus === "pending";` | L1574 |
| `src/App.jsx` | `\{error && <div className="error-banner">\{error\}</div>\}` | L1634 |
| `src/App.jsx` | `\{shouldShowContext && (` | L1673 |
| `src/App.jsx` | `className="context-button"` | L1677 |
| `src/App.jsx` | `onClick=\{() => setIsContextModalOpen(true)\}` | L1678 |
| `src/App.jsx` | `aria-label="View AI context"` | L1679 |
| `src/App.jsx` | `title="View AI context"` | L1680 |
| `src/App.jsx` | `\{error && <div className="error-banner">\{error\}</div>\}` | L1731 |
| `src/App.jsx` | `\{shouldShowContext && isContextModalOpen && (` | L1765 |
| `src/App.jsx` | `aria-label="AI context"` | L1770 |
| `src/App.jsx` | `onClick=\{() => setIsContextModalOpen(false)\}` | L1771 |
| `src/App.jsx` | `<div className="modal-title">AI context</div>` | L1775 |
| `src/App.jsx` | `onClick=\{() => setIsContextModalOpen(false)\}` | L1779 |
| `src/App.jsx` | `<pre className="context-preview">` | L1788 |
| `src/App.jsx` | `\{buildHiddenContextForNode(activeNodeId, nodesById) \|\| "No context."\}` | L1789 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "branch-highlight:" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 2 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `url: `branch-highlight:$\{highlightId\}:$\{branchNodeId\}`,` | L191 |
| `src/App.jsx` | `if (typeof href === "string" && href.startsWith("branch-highlight:")) \{` | L493 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "activeNodeId" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 20 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `activeNodeId: "root",` | L276 |
| `src/App.jsx` | `const activeNodeId = activeTree?.activeNodeId \|\| "root";` | L462 |
| `src/App.jsx` | `const activeNode = nodesById[activeNodeId];` | L463 |
| `src/App.jsx` | `const shouldShowContext = activeNodeId !== "root";` | L465 |
| `src/App.jsx` | `updateTree(activeTreeId, (tree) => (\{ ...tree, activeNodeId: nodeId \}));` | L654 |
| `src/App.jsx` | `nodeId: activeNodeId,` | L793 |
| `src/App.jsx` | `\}, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);` | L826 |
| `src/App.jsx` | `updateNode(activeTreeId, activeNodeId, (node) => \{` | L924 |
| `src/App.jsx` | `\}, [activeTreeId, activeNodeId]);` | L932 |
| `src/App.jsx` | `updateTree(treeId, (tree) => (\{ ...tree, activeNodeId: id \}));` | L948 |
| `src/App.jsx` | `const nodeSnapshot = nodesById[activeNodeId];` | L1002 |
| `src/App.jsx` | `activeNodeId === "root" && (nodeSnapshot?.messages?.length ?? 0) === 0;` | L1006 |
| `src/App.jsx` | `? buildHiddenContextForNode(activeNodeId, nodesById)` | L1008 |
| `src/App.jsx` | `updateNodeMessages(activeTreeId, activeNodeId, (messages) => [` | L1010 |
| `src/App.jsx` | `updateNodeMessages(activeTreeId, activeNodeId, (messages) => [` | L1051 |
| `src/App.jsx` | `const sourceNodeId = selectionPopover.nodeId \|\| activeNodeId;` | L1083 |
| `src/App.jsx` | `nodeId: activeNodeId,` | L1276 |
| `src/App.jsx` | `className=\{`tree-item $\{activeNodeId === nodeId ? "active" : ""\} $\{hoveredBranchNodeId === nodeId ? "branch-hover" : ""` | L1289 |
| `src/App.jsx` | `className=\{`graph-node $\{nodeId === activeNodeId ? "active" : ""` | L1579 |
| `src/App.jsx` | `\{buildHiddenContextForNode(activeNodeId, nodesById) \|\| "No context."\}` | L1789 |


</details>
</tool-use>

---



---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating chat interface**

I'm considering how to enhance the user experience by adding a "Back to parent highlight" button at the top message. Maybe I could include a little arrow or the title of the parent. I’m thinking of coding it so it teleports users back to the previous point when clicked. I should also check the CSS for the `.teleport-button` to give it a nice background and update the header message to include an actions area. Sounds like a solid plan!</details></think>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "\.chat-header\b|\.chat-meta\b|\.chat-header-actions\b" in "/Users/cosmo/Documents/projects/trees/src/styles.css" • 4 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/styles.css` | `.chat-header \{` | L473 |
| `src/styles.css` | `.chat-header h2 \{` | L481 |
| `src/styles.css` | `.chat-meta \{` | L485 |
| `src/styles.css` | `.chat-header-actions \{` | L495 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "branch-highlight" in "/Users/cosmo/Documents/projects/trees/src/styles.css" • 5 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/styles.css` | `.branch-highlight \{` | L753 |
| `src/styles.css` | `.branch-highlight.is-temp \{` | L762 |
| `src/styles.css` | `.branch-highlight:hover,` | L767 |
| `src/styles.css` | `.branch-highlight.is-hovered \{` | L768 |
| `src/styles.css` | `.branch-highlight.no-hover:hover \{` | L773 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "setActiveNodeId\s*=" in "/Users/cosmo/Documents/projects/trees/src/App.jsx" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/App.jsx` | `const setActiveNodeId = (nodeId) => \{` | L653 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Implementing teleport functionality**

I need to implement teleport with the `setActiveNodeId`. It's important to ensure that `markdownComponents` includes the flash state for highlight updates, so I’ll add that to the `useMemo` dependencies. 

When on a child node, I'm looking to provide a way to teleport back to the parent's node, which means it’ll only display for child nodes. I’ll check for the existence of the parentId and whether there's a highlight in the parent referencing this node, using regex to ensure accuracy. I'll also clarify placement under message counts.
**Patching App.jsx and styles.css**

I’m planning to patch `App.jsx` and `styles.css`. I need to add state variables close to the other `useState` declarations. It's essential to update `markdownComponents` to include the flash class for clear visual feedback. 

I also need to create an effect for `pendingTeleport`. I want to ensure I'm crafting this patch carefully, and I’ll use `apply_patch` to implement these changes effectively. It’s all about keeping things tidy and functional!</details></think>

---

Cool, we already have everything we need: every branch highlight in a parent message renders as a span with `data-branch-node-id="<childId>"`, and every node stores its `parentId`. Next I’ll add a “Jump to parent highlight” control in the chat header for child nodes, plus a tiny scroll+flash effect so the exact originating highlight is obvious when you land back on the parent.

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "59fa34f4-cf8e-4aa7-aa4e-f0aa8cabf506",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "59fa34f4-cf8e-4aa7-aa4e-f0aa8cabf506",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New Tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n    const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n+   const [pendingTeleport, setPendingTeleport] = useState(null);\n+   const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n    const [draft, setDraft] = useState(\"\");\n    const [isLoading, setIsLoading] = useState(false);",
        "oldStart": 410,
        "newStart": 410,
        "oldLines": 4,
        "newLines": 6,
        "linesAdded": 2
      },
      {
        "diffString": "    const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n    const shouldShowContext = activeNodeId !== \"root\";\n+   const parentNodeId = activeNode?.parentId || null;\n+   const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n    const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n    const treeList = useMemo(",
        "oldStart": 464,
        "newStart": 466,
        "oldLines": 4,
        "newLines": 6,
        "linesAdded": 2
      },
      {
        "diffString": "            const disableHoverEffects = selectionPopover.visible;\n            const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n+           const isTeleportFlash = flashBranchNodeId === branchNodeId;\n            return (\n              &lt;span\n                {...props}\n                className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n+                 } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                  }&#96;}\n                data-highlight-id={highlightId}",
        "oldStart": 497,
        "newStart": 501,
        "oldLines": 8,
        "newLines": 10,
        "linesAdded": 2
      },
      {
        "diffString": "        },\n      }),\n-     [hoveredBranchNodeId, selectionPopover.visible],\n+     [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n    );\n    const graphLayout = useMemo(() =&gt; {",
        "oldStart": 565,
        "newStart": 571,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      },
      {
        "diffString": "      updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n    };\n+ \n+   const teleportToParentHighlight = () =&gt; {\n+     if (!parentNodeId) return;\n+     setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n+     setActiveNodeId(parentNodeId);\n+   };\n  \n    const createNewTree = () =&gt; {",
        "oldStart": 654,
        "newStart": 660,
        "oldLines": 4,
        "newLines": 10,
        "linesAdded": 6
      },
      {
        "diffString": "      };\n    }, [sidebarWidth]);\n+ \n+   useLayoutEffect(() =&gt; {\n+     if (!pendingTeleport) return;\n+     if (activeNodeId !== pendingTeleport.parentNodeId) return;\n+ \n+     const container = chatAreaRef.current;\n+     if (!container) {\n+       setPendingTeleport(null);\n+       return;\n+     }\n+ \n+     // Wait a frame so the parent node messages/highlights are in the DOM.\n+     const raf = window.requestAnimationFrame(() =&gt; {\n+       const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n+       const highlightEl = container.querySelector(selector);\n+       if (highlightEl) {\n+         highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n+         setFlashBranchNodeId(pendingTeleport.childNodeId);\n+         window.setTimeout(() =&gt; {\n+           setFlashBranchNodeId(null);\n+         }, 1200);\n+       }\n+       setPendingTeleport(null);\n+     });\n+ \n+     return () =&gt; window.cancelAnimationFrame(raf);\n+   }, [activeNodeId, pendingTeleport]);\n  \n    const handleGraphWheel = (event) =&gt; {",
        "oldStart": 1353,
        "newStart": 1365,
        "oldLines": 4,
        "newLines": 31,
        "linesAdded": 27
      },
      {
        "diffString": "                  &lt;div&gt;\n                    &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n-                   &lt;span className=\"chat-meta\"&gt;\n-                     {activeNode.messages.length} messages\n-                   &lt;/span&gt;\n+                   &lt;div className=\"chat-subhead\"&gt;\n+                     &lt;span className=\"chat-meta\"&gt;\n+                       {activeNode.messages.length} messages\n+                     &lt;/span&gt;\n+                     {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n+                       &lt;button\n+                         type=\"button\"\n+                         className=\"teleport-button\"\n+                         onClick={teleportToParentHighlight}\n+                         title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n+                         aria-label=\"Jump to parent highlight\"\n+                       &gt;\n+                         &lt;span className=\"teleport-button-label\"&gt;\n+                           Jump to parent highlight\n+                         &lt;/span&gt;\n+                         &lt;span className=\"teleport-button-parent\"&gt;\n+                           {parentNode.title}\n+                         &lt;/span&gt;\n+                       &lt;/button&gt;\n+                     )}\n+                   &lt;/div&gt;\n                  &lt;/div&gt;\n                  {shouldShowContext &amp;&amp; (",
        "oldStart": 1667,
        "newStart": 1706,
        "oldLines": 7,
        "newLines": 25,
        "linesRemoved": 3,
        "linesAdded": 21
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New Tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "50c7460f-6df2-477f-af65-440e053211ec",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "50c7460f-6df2-477f-af65-440e053211ec",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      margin: 0 0 4px;\n  }\n+ \n+ .chat-subhead {\n+     display: flex;\n+     align-items: center;\n+     gap: 10px;\n+     flex-wrap: wrap;\n+ }\n  \n  .chat-meta {\n      color: #9aa3b2;\n      font-size: 12px;\n  }\n+ \n+ .teleport-button {\n+     border: 1px solid #2c3546;\n+     background: rgba(255, 255, 255, 0.03);\n+     color: #e6e9ef;\n+     border-radius: 9999px;\n+     padding: 6px 10px;\n+     display: inline-flex;\n+     align-items: baseline;\n+     gap: 8px;\n+     cursor: pointer;\n+     transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n+ }\n+ \n+ .teleport-button:hover {\n+     background: rgba(255, 255, 255, 0.06);\n+     border-color: #3c465a;\n+     transform: translateY(-1px);\n+ }\n+ \n+ .teleport-button:active {\n+     transform: translateY(0);\n+ }\n+ \n+ .teleport-button:focus-visible {\n+     outline: none;\n+     box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n+ }\n+ \n+ .teleport-button-label {\n+     font-size: 12px;\n+     font-weight: 600;\n+ }\n+ \n+ .teleport-button-parent {\n+     font-size: 12px;\n+     color: #9aa3b2;\n+     max-width: 220px;\n+     overflow: hidden;\n+     text-overflow: ellipsis;\n+     white-space: nowrap;\n+ }\n  \n  .thinking {",
        "oldStart": 482,
        "newStart": 482,
        "oldLines": 9,
        "newLines": 58,
        "linesAdded": 49
      },
      {
        "diffString": "      box-shadow: none;\n  }\n+ \n+ .branch-highlight.teleport-flash {\n+     animation: teleportPulse 900ms ease-out 1;\n+ }\n+ \n+ @keyframes teleportPulse {\n+     0% {\n+         box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n+     }\n+     18% {\n+         box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n+     }\n+     100% {\n+         box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n+     }\n+ }\n  \n  .chat-area ::selection {",
        "oldStart": 775,
        "newStart": 824,
        "oldLines": 4,
        "newLines": 20,
        "linesAdded": 16
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    gap: 12px;\n    align-items: flex-end;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

### What changed

- **Chat header now shows a “Jump to parent highlight” button** when you’re on a child node (i.e., `activeNode.parentId` exists).
- Clicking it **switches you back to the parent node and auto-scrolls to the exact branch highlight** that created the child (the highlight span with `data-branch-node-id="<childId>"`), then **briefly “pulses”** that highlight so it’s obvious.

### Files updated

- `src/App.jsx`
- `src/styles.css`

---

_**User (2026-01-18 15:24Z)**_

nice but cant you instead use the usual "Forwarded" UX with the curved arrow and if we click on it it teleports us back? with same yellow color for semantic match

---

_**Agent (model gpt-5.2, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Designing UX elements**

I’m considering the semantic match for a yellow background highlight, thinking about using rgba(255, 235, 59, 0.55). I should include hover effects and an SVG arrow icon. For stroke color, I'm leaning towards #0f1115, but text color might need to be #141821 for better readability. The "Forwarded" label should have a yellow background, possibly with a border, and include a little arrow. I'll make sure to update App.jsx and the styles accordingly.
**Creating a todo list**

I've received a system reminder, but I'm wondering if I can ignore it. Still, maybe I'll create a minimal todo list since it's a multi-step process. I think I should include two items: change the UI and run lints. I’ll call a tool to proceed with creating the todo, applying the patch, and checking for errors in App.jsx and styles.css. 

For the new components in App.jsx, I plan to replace the teleport button with a forwarded pill that includes an icon and source title.</details></think>

---

Yep — we can make this feel like a real “Forwarded from …” affordance instead of a generic button. I’ll swap the header UI to a small forwarded-style pill with a curved arrow, tint it with the same yellow semantics as branch highlights, keep it clickable to teleport, then run lints to ensure everything’s clean.

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Replace chat header teleport button with forwarded-style pill (curved arrow + 'Forwarded from <parent>') using branch-highlight yellow semantics; click teleports back and flashes highlight
- [ ] Run lints for edited files and fix any issues

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "ef715816-0f3f-498f-89af-1750462f9de7",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "ef715816-0f3f-498f-89af-1750462f9de7",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New Tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"forwarded-pill\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Forwarded from \"${parentNode.title}\" — click to jump back to the originating highlight&#96;}\n                        aria-label={&#96;Forwarded from ${parentNode.title}. Click to jump back to the originating highlight.&#96;}\n                      &gt;\n                        &lt;svg\n                          className=\"forwarded-icon\"\n                          viewBox=\"0 0 24 24\"\n                          aria-hidden=\"true\"\n                        &gt;\n                          &lt;path d=\"M9 7l-5 5 5 5\" /&gt;\n                          &lt;path d=\"M20 18v-2a7 7 0 0 0-7-7H4\" /&gt;\n                        &lt;/svg&gt;\n                        &lt;span className=\"forwarded-label\"&gt;Forwarded from&lt;/span&gt;\n                        &lt;span className=\"forwarded-source\"&gt;{parentNode.title}&lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "                        &lt;button\n                          type=\"button\"\n-                         className=\"teleport-button\"\n+                         className=\"forwarded-pill\"\n                          onClick={teleportToParentHighlight}\n-                         title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n-                         aria-label=\"Jump to parent highlight\"\n+                         title={&#96;Forwarded from \"${parentNode.title}\" — click to jump back to the originating highlight&#96;}\n+                         aria-label={&#96;Forwarded from ${parentNode.title}. Click to jump back to the originating highlight.&#96;}\n                        &gt;\n-                         &lt;span className=\"teleport-button-label\"&gt;\n-                           Jump to parent highlight\n-                         &lt;/span&gt;\n-                         &lt;span className=\"teleport-button-parent\"&gt;\n-                           {parentNode.title}\n-                         &lt;/span&gt;\n+                         &lt;svg\n+                           className=\"forwarded-icon\"\n+                           viewBox=\"0 0 24 24\"\n+                           aria-hidden=\"true\"\n+                         &gt;\n+                           &lt;path d=\"M9 7l-5 5 5 5\" /&gt;\n+                           &lt;path d=\"M20 18v-2a7 7 0 0 0-7-7H4\" /&gt;\n+                         &lt;/svg&gt;\n+                         &lt;span className=\"forwarded-label\"&gt;Forwarded from&lt;/span&gt;\n+                         &lt;span className=\"forwarded-source\"&gt;{parentNode.title}&lt;/span&gt;\n                        &lt;/button&gt;\n                      )}",
        "oldStart": 1713,
        "newStart": 1713,
        "oldLines": 15,
        "newLines": 19,
        "linesRemoved": 9,
        "linesAdded": 13
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    setTreesById((prev) =&gt; {\n      const next = { ...prev };\n      delete next[treeId];\n      const remainingIds = Object.keys(next);\n      if (!remainingIds.length) {\n        const fresh = createTree(\"New Tree\");\n        next[fresh.id] = fresh;\n      }\n      return next;\n    });\n\n    closeTreeMenu();\n\n    if (activeTreeId === treeId) {\n      const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n      if (remaining.length) {\n        setActiveTreeId(remaining[0].id);\n      } else {\n        // Will be set by the activeTreeId/treeList effect after state update.\n        setActiveTreeId(null);\n      }\n    }\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  const words = node.title.split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode.title}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"forwarded-pill\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Forwarded from \"${parentNode.title}\" — click to jump back to the originating highlight&#96;}\n                        aria-label={&#96;Forwarded from ${parentNode.title}. Click to jump back to the originating highlight.&#96;}\n                      &gt;\n                        &lt;svg\n                          className=\"forwarded-icon\"\n                          viewBox=\"0 0 24 24\"\n                          aria-hidden=\"true\"\n                        &gt;\n                          &lt;path d=\"M9 7l-5 5 5 5\" /&gt;\n                          &lt;path d=\"M20 18v-2a7 7 0 0 0-7-7H4\" /&gt;\n                        &lt;/svg&gt;\n                        &lt;span className=\"forwarded-label\"&gt;Forwarded from&lt;/span&gt;\n                        &lt;span className=\"forwarded-source\"&gt;{parentNode.title}&lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

Cancelled

---

