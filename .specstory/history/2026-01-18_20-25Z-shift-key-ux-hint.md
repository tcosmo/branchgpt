<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 771447a6-e45f-4aef-bf8c-e51b54f899ed (2026-01-18 20:25Z) -->

# SHIFT key UX hint (2026-01-18 20:25Z)

_**User (2026-01-18 16:02Z)**_

Add a UX hint that makes it clear that the goal is to press SHIFT when something is highlighted put the info when I have written a message and also on top of the graph view on the left pannel

---

_**Agent (model gpt-5.2-codex, mode Agent)**_



---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning hint additions**

I need to add a hint after the message is written, possibly near the chat input, and also atop the graph view in the left panel. There's an existing selection-hint class, so I'll check its current usage to integrate these hints consistently.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "selection-hint",
  "path": "/Users/cosmo/Documents/projects/trees/src",
  "outputMode": "content",
  "caseInsensitive": false,
  "headLimit": 20
}
```
Result:

```json
{
  "success": {
    "pattern": "selection-hint",
    "path": "/Users/cosmo/Documents/projects/trees/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/styles.css",
              "matches": [
                {
                  "lineNumber": 959,
                  "content": ".selection-hint {"
                },
                {
                  "lineNumber": 965,
                  "content": ".chat-input--empty .selection-hint {"
                }
              ]
            }
          ],
          "totalLines": 2,
          "totalMatchedLines": 2
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning hint text insertion**

Deciding to add a conditional hint below the chat composer when the draft has content, plus a similar small label above the tree graph in the sidebar, styling both with new CSS classes for positioning.
**Adding hints to empty chat and graph view**

Planning to show the hint in the empty chat input as well by reusing the same logic and implementing the graph hint as an absolute-positioned overlay above the tree graph with proper styling for readability and non-interference.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "0486e6ca-d77d-4eca-877f-076acf51916b",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "0486e6ca-d77d-4eca-877f-076acf51916b",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHintText = \"Tip: Highlight text, then press Shift to start a branch.\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;div\n              className=\"tree-graph\"\n              ref={graphContainerRef}\n              onWheel={handleGraphWheel}\n              onMouseDown={handleGraphMouseDown}\n            &gt;\n              &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n              &lt;svg\n                width=\"100%\"\n                height=\"100%\"\n                viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                preserveAspectRatio=\"xMidYMin meet\"\n              &gt;\n                &lt;g\n                  transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                &gt;\n                  {graphLayout.edges.map((edge) =&gt; {\n                    const from = graphLayout.positions[edge.from];\n                    const to = graphLayout.positions[edge.to];\n                    if (!from || !to) return null;\n                    return (\n                      &lt;line\n                        key={&#96;${edge.from}-${edge.to}&#96;}\n                        x1={from.x}\n                        y1={from.y}\n                        x2={to.x}\n                        y2={to.y}\n                        className=\"graph-edge\"\n                      /&gt;\n                    );\n                  })}\n                  {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                    const node = nodesById[nodeId];\n                    if (!node) return null;\n                    const words = (node.title || \"\").split(\" \").filter(Boolean);\n                    const isPending = node?.requestStatus === \"pending\";\n                    const isReady = node?.hasUnread;\n                    return (\n                      &lt;g\n                        key={nodeId}\n                        className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                          } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                        onClick={() =&gt; setActiveNodeId(nodeId)}\n                        onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                        onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                      &gt;\n                        &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                        {isPending &amp;&amp; (\n                          &lt;circle\n                            className=\"graph-node-badge pending\"\n                            cx={pos.x + 22}\n                            cy={pos.y - 22}\n                            r=\"6\"\n                          /&gt;\n                        )}\n                        {!isPending &amp;&amp; isReady &amp;&amp; (\n                          &lt;circle\n                            className=\"graph-node-badge ready\"\n                            cx={pos.x + 22}\n                            cy={pos.y - 22}\n                            r=\"6\"\n                          /&gt;\n                        )}\n                        &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                          {words.length &gt; 1 ? (\n                            &lt;&gt;\n                              &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                              &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                {words.slice(1).join(\" \")}\n                              &lt;/tspan&gt;\n                            &lt;/&gt;\n                          ) : (\n                            &lt;tspan x={pos.x} dy=\"4\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                          )}\n                        &lt;/text&gt;\n                      &lt;/g&gt;\n                    );\n                  })}\n                &lt;/g&gt;\n              &lt;/svg&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n                {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n                {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n    const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n+   const selectionHintText = \"Tip: Highlight text, then press Shift to start a branch.\";\n    const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n    const treeList = useMemo(",
        "oldStart": 662,
        "newStart": 662,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "                onMouseDown={handleGraphMouseDown}\n              &gt;\n+               &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n                &lt;svg\n                  width=\"100%\"",
        "oldStart": 1826,
        "newStart": 1827,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "                    &lt;/button&gt;\n                  &lt;/div&gt;\n+                 {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n  \n                &lt;/div&gt;",
        "oldStart": 1942,
        "newStart": 1944,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "                    &lt;/button&gt;\n                  &lt;/div&gt;\n+                 {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n  \n                &lt;/footer&gt;",
        "oldStart": 2059,
        "newStart": 2062,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHintText = \"Tip: Highlight text, then press Shift to start a branch.\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;div\n              className=\"tree-graph\"\n              ref={graphContainerRef}\n              onWheel={handleGraphWheel}\n              onMouseDown={handleGraphMouseDown}\n            &gt;\n              &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n              &lt;svg\n                width=\"100%\"\n                height=\"100%\"\n                viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                preserveAspectRatio=\"xMidYMin meet\"\n              &gt;\n                &lt;g\n                  transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                &gt;\n                  {graphLayout.edges.map((edge) =&gt; {\n                    const from = graphLayout.positions[edge.from];\n                    const to = graphLayout.positions[edge.to];\n                    if (!from || !to) return null;\n                    return (\n                      &lt;line\n                        key={&#96;${edge.from}-${edge.to}&#96;}\n                        x1={from.x}\n                        y1={from.y}\n                        x2={to.x}\n                        y2={to.y}\n                        className=\"graph-edge\"\n                      /&gt;\n                    );\n                  })}\n                  {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                    const node = nodesById[nodeId];\n                    if (!node) return null;\n                    const words = (node.title || \"\").split(\" \").filter(Boolean);\n                    const isPending = node?.requestStatus === \"pending\";\n                    const isReady = node?.hasUnread;\n                    return (\n                      &lt;g\n                        key={nodeId}\n                        className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                          } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                        onClick={() =&gt; setActiveNodeId(nodeId)}\n                        onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                        onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                      &gt;\n                        &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                        {isPending &amp;&amp; (\n                          &lt;circle\n                            className=\"graph-node-badge pending\"\n                            cx={pos.x + 22}\n                            cy={pos.y - 22}\n                            r=\"6\"\n                          /&gt;\n                        )}\n                        {!isPending &amp;&amp; isReady &amp;&amp; (\n                          &lt;circle\n                            className=\"graph-node-badge ready\"\n                            cx={pos.x + 22}\n                            cy={pos.y - 22}\n                            r=\"6\"\n                          /&gt;\n                        )}\n                        &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                          {words.length &gt; 1 ? (\n                            &lt;&gt;\n                              &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                              &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                {words.slice(1).join(\" \")}\n                              &lt;/tspan&gt;\n                            &lt;/&gt;\n                          ) : (\n                            &lt;tspan x={pos.x} dy=\"4\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                          )}\n                        &lt;/text&gt;\n                      &lt;/g&gt;\n                    );\n                  })}\n                &lt;/g&gt;\n              &lt;/svg&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n                {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n                {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding CSS for graph hint and tree-graph**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "cf224899-869d-44bc-ab57-96541aff056a",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "cf224899-869d-44bc-ab57-96541aff056a",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n    position: relative;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.graph-hint {\n    position: absolute;\n    top: 8px;\n    left: 10px;\n    padding: 4px 8px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 999px;\n    pointer-events: none;\n}\n\n.chat-input--empty .selection-hint {\n    margin-top: 8px;\n    text-align: center;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      cursor: grab;\n      user-select: none;\n+     position: relative;\n  }\n  ",
        "oldStart": 332,
        "newStart": 332,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "      letter-spacing: 0.01em;\n  }\n+ \n+ .graph-hint {\n+     position: absolute;\n+     top: 8px;\n+     left: 10px;\n+     padding: 4px 8px;\n+     background: rgba(15, 17, 21, 0.75);\n+     border: 1px solid rgba(60, 70, 90, 0.6);\n+     border-radius: 999px;\n+     pointer-events: none;\n+ }\n  \n  .chat-input--empty .selection-hint {",
        "oldStart": 962,
        "newStart": 963,
        "oldLines": 4,
        "newLines": 15,
        "linesAdded": 11
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n    position: relative;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.graph-hint {\n    position: absolute;\n    top: 8px;\n    left: 10px;\n    padding: 4px 8px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 999px;\n    pointer-events: none;\n}\n\n.chat-input--empty .selection-hint {\n    margin-top: 8px;\n    text-align: center;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Running lints**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`
- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---



---

Added a clear Shift-to-branch hint in two spots: right under the composer once you’ve typed a message, and as a small label at the top of the graph view in the left panel. Both use the existing `selection-hint` styling with a new overlay style for the graph.

- Updated `src/App.jsx` to render the hint conditionally when `draft` has text and to show the hint above the graph.
- Updated `src/styles.css` to position the graph hint cleanly and make the graph container `position: relative`.

If you want different wording or always-visible behavior (even when the draft is empty), tell me the exact text and I’ll tweak it.

---

_**User (2026-01-18 16:02Z)**_

dont put it IN the graph view but on top of it

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Adjusting hint placement**

I'm moving the hint outside the graph container to appear above it in the sidebar and updating CSS to replace positioning with margin spacing for cleaner layout.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "629e2995-d636-4cf3-9c4d-7ae953d91a67",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "629e2995-d636-4cf3-9c4d-7ae953d91a67",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHintText = \"Tip: Highlight text, then press Shift to start a branch.\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n              &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n                {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n                {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "          {hasActiveTree &amp;&amp;\n            (treeView === \"graph\" ? (\n-             &lt;div\n-               className=\"tree-graph\"\n-               ref={graphContainerRef}\n-               onWheel={handleGraphWheel}\n-               onMouseDown={handleGraphMouseDown}\n-             &gt;\n-               &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n-               &lt;svg\n-                 width=\"100%\"\n-                 height=\"100%\"\n-                 viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n-                 preserveAspectRatio=\"xMidYMin meet\"\n-               &gt;\n-                 &lt;g\n-                   transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n-                 &gt;\n-                   {graphLayout.edges.map((edge) =&gt; {\n-                     const from = graphLayout.positions[edge.from];\n-                     const to = graphLayout.positions[edge.to];\n-                     if (!from || !to) return null;\n-                     return (\n-                       &lt;line\n-                         key={&#96;${edge.from}-${edge.to}&#96;}\n-                         x1={from.x}\n-                         y1={from.y}\n-                         x2={to.x}\n-                         y2={to.y}\n-                         className=\"graph-edge\"\n-                       /&gt;\n-                     );\n-                   })}\n-                   {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n-                     const node = nodesById[nodeId];\n-                     if (!node) return null;\n-                     const words = (node.title || \"\").split(\" \").filter(Boolean);\n-                     const isPending = node?.requestStatus === \"pending\";\n-                     const isReady = node?.hasUnread;\n-                     return (\n-                       &lt;g\n-                         key={nodeId}\n-                         className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n-                           } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n-                         onClick={() =&gt; setActiveNodeId(nodeId)}\n-                         onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n-                         onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n-                       &gt;\n-                         &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n-                         {isPending &amp;&amp; (\n-                           &lt;circle\n-                             className=\"graph-node-badge pending\"\n-                             cx={pos.x + 22}\n-                             cy={pos.y - 22}\n-                             r=\"6\"\n-                           /&gt;\n-                         )}\n-                         {!isPending &amp;&amp; isReady &amp;&amp; (\n-                           &lt;circle\n-                             className=\"graph-node-badge ready\"\n-                             cx={pos.x + 22}\n-                             cy={pos.y - 22}\n-                             r=\"6\"\n-                           /&gt;\n-                         )}\n-                         &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n-                           {words.length &gt; 1 ? (\n-                             &lt;&gt;\n-                               &lt;tspan x={pos.x} dy=\"-6\"&gt;\n-                                 {words[0]}\n-                               &lt;/tspan&gt;\n-                               &lt;tspan x={pos.x} dy=\"14\"&gt;\n-                                 {words.slice(1).join(\" \")}\n-                               &lt;/tspan&gt;\n-                             &lt;/&gt;\n-                           ) : (\n-                             &lt;tspan x={pos.x} dy=\"4\"&gt;\n-                               {words[0]}\n-                             &lt;/tspan&gt;\n-                           )}\n-                         &lt;/text&gt;\n-                       &lt;/g&gt;\n-                     );\n-                   })}\n-                 &lt;/g&gt;\n-               &lt;/svg&gt;\n-             &lt;/div&gt;\n+             &lt;&gt;\n+               &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n+               &lt;div\n+                 className=\"tree-graph\"\n+                 ref={graphContainerRef}\n+                 onWheel={handleGraphWheel}\n+                 onMouseDown={handleGraphMouseDown}\n+               &gt;\n+                 &lt;svg\n+                   width=\"100%\"\n+                   height=\"100%\"\n+                   viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n+                   preserveAspectRatio=\"xMidYMin meet\"\n+                 &gt;\n+                   &lt;g\n+                     transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n+                   &gt;\n+                     {graphLayout.edges.map((edge) =&gt; {\n+                       const from = graphLayout.positions[edge.from];\n+                       const to = graphLayout.positions[edge.to];\n+                       if (!from || !to) return null;\n+                       return (\n+                         &lt;line\n+                           key={&#96;${edge.from}-${edge.to}&#96;}\n+                           x1={from.x}\n+                           y1={from.y}\n+                           x2={to.x}\n+                           y2={to.y}\n+                           className=\"graph-edge\"\n+                         /&gt;\n+                       );\n+                     })}\n+                     {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n+                       const node = nodesById[nodeId];\n+                       if (!node) return null;\n+                       const words = (node.title || \"\").split(\" \").filter(Boolean);\n+                       const isPending = node?.requestStatus === \"pending\";\n+                       const isReady = node?.hasUnread;\n+                       return (\n+                         &lt;g\n+                           key={nodeId}\n+                           className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n+                             } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n+                           onClick={() =&gt; setActiveNodeId(nodeId)}\n+                           onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n+                           onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n+                         &gt;\n+                           &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n+                           {isPending &amp;&amp; (\n+                             &lt;circle\n+                               className=\"graph-node-badge pending\"\n+                               cx={pos.x + 22}\n+                               cy={pos.y - 22}\n+                               r=\"6\"\n+                             /&gt;\n+                           )}\n+                           {!isPending &amp;&amp; isReady &amp;&amp; (\n+                             &lt;circle\n+                               className=\"graph-node-badge ready\"\n+                               cx={pos.x + 22}\n+                               cy={pos.y - 22}\n+                               r=\"6\"\n+                             /&gt;\n+                           )}\n+                           &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n+                             {words.length &gt; 1 ? (\n+                               &lt;&gt;\n+                                 &lt;tspan x={pos.x} dy=\"-6\"&gt;\n+                                   {words[0]}\n+                                 &lt;/tspan&gt;\n+                                 &lt;tspan x={pos.x} dy=\"14\"&gt;\n+                                   {words.slice(1).join(\" \")}\n+                                 &lt;/tspan&gt;\n+                               &lt;/&gt;\n+                             ) : (\n+                               &lt;tspan x={pos.x} dy=\"4\"&gt;\n+                                 {words[0]}\n+                               &lt;/tspan&gt;\n+                             )}\n+                           &lt;/text&gt;\n+                         &lt;/g&gt;\n+                       );\n+                     })}\n+                   &lt;/g&gt;\n+                 &lt;/svg&gt;\n+               &lt;/div&gt;\n+             &lt;/&gt;\n            ) : (\n              &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;",
        "oldStart": 1821,
        "newStart": 1821,
        "oldLines": 89,
        "newLines": 91,
        "linesRemoved": 85,
        "linesAdded": 87
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHintText = \"Tip: Highlight text, then press Shift to start a branch.\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n              &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n                {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n                {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "016e3502-8e4c-4d46-a867-e77d99b95218",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "016e3502-8e4c-4d46-a867-e77d99b95218",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 999px;\n}\n\n.chat-input--empty .selection-hint {\n    margin-top: 8px;\n    text-align: center;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      cursor: grab;\n      user-select: none;\n-     position: relative;\n  }\n  ",
        "oldStart": 332,
        "newStart": 332,
        "oldLines": 5,
        "newLines": 4,
        "linesRemoved": 1
      },
      {
        "diffString": "  \n  .graph-hint {\n-     position: absolute;\n-     top: 8px;\n-     left: 10px;\n+     display: inline-block;\n+     align-self: flex-start;\n      padding: 4px 8px;\n+     margin-bottom: 6px;\n      background: rgba(15, 17, 21, 0.75);\n      border: 1px solid rgba(60, 70, 90, 0.6);\n      border-radius: 999px;\n-     pointer-events: none;\n  }\n  ",
        "oldStart": 965,
        "newStart": 964,
        "oldLines": 12,
        "newLines": 11,
        "linesRemoved": 4,
        "linesAdded": 3
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 999px;\n}\n\n.chat-input--empty .selection-hint {\n    margin-top: 8px;\n    text-align: center;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`
- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

Moved the hint outside the graph container so it sits above the graph (not inside). The graph hint now renders just before the graph and is styled as a pill with margin.

If you want it aligned differently (centered, full width, etc.), tell me and I’ll tweak the styling.

---

_**User (2026-01-18 16:02Z)**_

always show the tip near the composer and put it on top of the composer

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Adjusting hint placement and styles**

I'm moving the hint element above the composer in both empty and normal states by removing the conditional rendering, and updating CSS to shift margin from top to bottom with possible center alignment to ensure consistent positioning above the composer.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "e42e2a1f-76c5-4395-9ec6-18898da1e542",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "e42e2a1f-76c5-4395-9ec6-18898da1e542",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHintText = \"Tip: Highlight text, then press Shift to start a branch.\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n              &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n                &lt;div className=\"chat-input chat-input--empty\"&gt;\n+                 &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n                  &lt;div className=\"composer\"&gt;\n                    &lt;textarea",
        "oldStart": 1920,
        "newStart": 1920,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "                    &lt;/button&gt;\n                  &lt;/div&gt;\n-                 {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n  \n                &lt;/div&gt;",
        "oldStart": 1946,
        "newStart": 1947,
        "oldLines": 5,
        "newLines": 4,
        "linesRemoved": 1
      },
      {
        "diffString": "                &lt;/section&gt;\n                &lt;footer className=\"chat-input\"&gt;\n+                 &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n                  &lt;div className=\"composer\"&gt;\n                    &lt;textarea",
        "oldStart": 2038,
        "newStart": 2038,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "                    &lt;/button&gt;\n                  &lt;/div&gt;\n-                 {draft.trim() &amp;&amp; &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;}\n  \n                &lt;/footer&gt;",
        "oldStart": 2064,
        "newStart": 2065,
        "oldLines": 5,
        "newLines": 4,
        "linesRemoved": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHintText = \"Tip: Highlight text, then press Shift to start a branch.\";\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n              &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Identifying patch failure cause**

The patch likely failed because of context changes affecting line numbers, so I'm going to examine the code around selection-hint to understand the mismatch.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating border-radius in selection hint**

Updating the selection-hint area's border-radius to 999px to reflect the intended style instead of the previous 10px.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "167e1bd6-c407-4b41-a9e6-605efd4a9059",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "167e1bd6-c407-4b41-a9e6-605efd4a9059",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.chat-input .selection-hint {\n    margin-bottom: 8px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      letter-spacing: 0.01em;\n  }\n+ \n+ .chat-input .selection-hint {\n+     margin-bottom: 8px;\n+ }\n  \n  .graph-hint {",
        "oldStart": 962,
        "newStart": 962,
        "oldLines": 4,
        "newLines": 8,
        "linesAdded": 4
      },
      {
        "diffString": "  \n  .chat-input--empty .selection-hint {\n-     margin-top: 8px;\n      text-align: center;\n  }",
        "oldStart": 974,
        "newStart": 978,
        "oldLines": 5,
        "newLines": 4,
        "linesRemoved": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.chat-input .selection-hint {\n    margin-bottom: 8px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`
- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

Got it. The tip now always shows and sits above the composer (both in the empty state and normal chat input).

- `src/App.jsx`: moved the hint above the composer and removed the conditional.
- `src/styles.css`: added bottom margin for the hint in `.chat-input`.

If you want different spacing or alignment, tell me what you prefer.

---

_**User (2026-01-18 16:02Z)**_

In the tip can we highlight "Shift" with the same yellow highlight

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Updating tip text with styled span**

Planning to wrap the key "Shift" in a span with both highlight and tip classes to style it and disable pointer events, then update App.jsx to render this as a React element and add corresponding CSS changes.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "ab6de4ba-6972-4cde-b2a1-fe83cb8d17f4",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "ab6de4ba-6972-4cde-b2a1-fe83cb8d17f4",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to start a branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n              &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n    const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n-   const selectionHintText = \"Tip: Highlight text, then press Shift to start a branch.\";\n+   const selectionHint = (\n+     &lt;&gt;\n+       Tip: Highlight text, then press{\" \"}\n+       &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to start a branch.\n+     &lt;/&gt;\n+   );\n    const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n    const treeList = useMemo(",
        "oldStart": 662,
        "newStart": 662,
        "oldLines": 5,
        "newLines": 10,
        "linesRemoved": 1,
        "linesAdded": 6
      },
      {
        "diffString": "            (treeView === \"graph\" ? (\n              &lt;&gt;\n-               &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n+               &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div\n                  className=\"tree-graph\"",
        "oldStart": 1822,
        "newStart": 1827,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      },
      {
        "diffString": "                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n                &lt;div className=\"chat-input chat-input--empty\"&gt;\n-                 &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n+                 &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                  &lt;div className=\"composer\"&gt;\n                    &lt;textarea",
        "oldStart": 1920,
        "newStart": 1925,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      },
      {
        "diffString": "                &lt;/section&gt;\n                &lt;footer className=\"chat-input\"&gt;\n-                 &lt;div className=\"selection-hint\"&gt;{selectionHintText}&lt;/div&gt;\n+                 &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                  &lt;div className=\"composer\"&gt;\n                    &lt;textarea",
        "oldStart": 2038,
        "newStart": 2043,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to start a branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n              &lt;div className=\"graph-hint selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "5e4fd59d-3594-4ca6-b35b-e6f64161996d",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "5e4fd59d-3594-4ca6-b35b-e6f64161996d",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight.is-tip {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.chat-input .selection-hint {\n    margin-bottom: 8px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      pointer-events: none;\n  }\n+ \n+ .branch-highlight.is-tip {\n+     cursor: default;\n+     pointer-events: none;\n+ }\n  \n  .branch-highlight:hover,",
        "oldStart": 818,
        "newStart": 818,
        "oldLines": 4,
        "newLines": 9,
        "linesAdded": 5
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight.is-tip {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.chat-input .selection-hint {\n    margin-bottom: 8px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`
- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

Done. “Shift” in the tip now uses the same yellow highlight (and won’t act like a clickable highlight).

If you want it a bit smaller or less intense, I can tweak the styling.

---

_**User (2026-01-18 16:02Z)**_

For screenshot I use cmd shift 4, can you not trigger popover when shift is not pressed alone?

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Refining shift keydown handling**

Planning to update the onKeyDown handler to trigger only when Shift is pressed alone without modifiers like Meta, Ctrl, or Alt, to avoid false triggers during shortcuts like Cmd+Shift+4 for screenshots.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "82f14baf-5518-4528-bbed-d94ce6d5f64c",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "82f14baf-5518-4528-bbed-d94ce6d5f64c",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to create a new branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        if (event.metaKey || event.ctrlKey || event.altKey) return;\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      const onKeyDown = (event) =&gt; {\n        if (event.key === \"Shift\") {\n+         if (event.metaKey || event.ctrlKey || event.altKey) return;\n          const payload = getSelectionPayload();\n          if (payload) {",
        "oldStart": 990,
        "newStart": 990,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to create a new branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        if (event.metaKey || event.ctrlKey || event.altKey) return;\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

Made Shift-only behavior strict: the popover won’t trigger if Shift is pressed with Cmd/Ctrl/Alt (so Cmd+Shift+4 won’t open it).

---

_**User (2026-01-18 16:02Z)**_

allow to hide the thread composer hint but default state is not hidden

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Planning composer hint toggle**

I'm locating the chat input area to implement a "Hide" toggle for the composer hint with state persisted in localStorage and adding minimal UI styling. Next, I'll update the related files accordingly.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning composer hint toggle**

I'm adding a toggle to show or hide the composer hint, defaulting to visible, with a button switching between "Hide tip" and "Show tip" near the composer; the state will be managed via useState and possibly styled with a dedicated wrapper class.
**Designing hint toggle UI and CSS**

I'm rendering a flex row with the hint text and a toggle button to show or hide the composer hint, adjusting layout differently for empty and normal states, and updating CSS to handle spacing, alignment, and button styling consistently while preventing margin conflicts.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "a17a09b6-d792-41f5-b3dc-64515f466aae",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "a17a09b6-d792-41f5-b3dc-64515f466aae",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [showComposerHint, setShowComposerHint] = useState(true);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to create a new branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        if (event.metaKey || event.ctrlKey || event.altKey) return;\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                {showComposerHint ? (\n                  &lt;div className=\"selection-hint-row\"&gt;\n                    &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"selection-hint-toggle\"\n                      onClick={() =&gt; setShowComposerHint(false)}\n                    &gt;\n                      Hide\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                ) : (\n                  &lt;button\n                    type=\"button\"\n                    className=\"selection-hint-toggle is-show\"\n                    onClick={() =&gt; setShowComposerHint(true)}\n                  &gt;\n                    Show tip\n                  &lt;/button&gt;\n                )}\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                {showComposerHint ? (\n                  &lt;div className=\"selection-hint-row\"&gt;\n                    &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"selection-hint-toggle\"\n                      onClick={() =&gt; setShowComposerHint(false)}\n                    &gt;\n                      Hide\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                ) : (\n                  &lt;button\n                    type=\"button\"\n                    className=\"selection-hint-toggle is-show\"\n                    onClick={() =&gt; setShowComposerHint(true)}\n                  &gt;\n                    Show tip\n                  &lt;/button&gt;\n                )}\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n    const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n+   const [showComposerHint, setShowComposerHint] = useState(true);\n    const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n    const [isContextModalOpen, setIsContextModalOpen] = useState(false);",
        "oldStart": 611,
        "newStart": 611,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      },
      {
        "diffString": "                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n                &lt;div className=\"chat-input chat-input--empty\"&gt;\n-                 &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n+                 {showComposerHint ? (\n+                   &lt;div className=\"selection-hint-row\"&gt;\n+                     &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n+                     &lt;button\n+                       type=\"button\"\n+                       className=\"selection-hint-toggle\"\n+                       onClick={() =&gt; setShowComposerHint(false)}\n+                     &gt;\n+                       Hide\n+                     &lt;/button&gt;\n+                   &lt;/div&gt;\n+                 ) : (\n+                   &lt;button\n+                     type=\"button\"\n+                     className=\"selection-hint-toggle is-show\"\n+                     onClick={() =&gt; setShowComposerHint(true)}\n+                   &gt;\n+                     Show tip\n+                   &lt;/button&gt;\n+                 )}\n                  &lt;div className=\"composer\"&gt;\n                    &lt;textarea",
        "oldStart": 1926,
        "newStart": 1927,
        "oldLines": 5,
        "newLines": 24,
        "linesRemoved": 1,
        "linesAdded": 20
      },
      {
        "diffString": "                &lt;/section&gt;\n                &lt;footer className=\"chat-input\"&gt;\n-                 &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n+                 {showComposerHint ? (\n+                   &lt;div className=\"selection-hint-row\"&gt;\n+                     &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n+                     &lt;button\n+                       type=\"button\"\n+                       className=\"selection-hint-toggle\"\n+                       onClick={() =&gt; setShowComposerHint(false)}\n+                     &gt;\n+                       Hide\n+                     &lt;/button&gt;\n+                   &lt;/div&gt;\n+                 ) : (\n+                   &lt;button\n+                     type=\"button\"\n+                     className=\"selection-hint-toggle is-show\"\n+                     onClick={() =&gt; setShowComposerHint(true)}\n+                   &gt;\n+                     Show tip\n+                   &lt;/button&gt;\n+                 )}\n                  &lt;div className=\"composer\"&gt;\n                    &lt;textarea",
        "oldStart": 2044,
        "newStart": 2064,
        "oldLines": 5,
        "newLines": 24,
        "linesRemoved": 1,
        "linesAdded": 20
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [showComposerHint, setShowComposerHint] = useState(true);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to create a new branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        if (event.metaKey || event.ctrlKey || event.altKey) return;\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                {showComposerHint ? (\n                  &lt;div className=\"selection-hint-row\"&gt;\n                    &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"selection-hint-toggle\"\n                      onClick={() =&gt; setShowComposerHint(false)}\n                    &gt;\n                      Hide\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                ) : (\n                  &lt;button\n                    type=\"button\"\n                    className=\"selection-hint-toggle is-show\"\n                    onClick={() =&gt; setShowComposerHint(true)}\n                  &gt;\n                    Show tip\n                  &lt;/button&gt;\n                )}\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                {showComposerHint ? (\n                  &lt;div className=\"selection-hint-row\"&gt;\n                    &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"selection-hint-toggle\"\n                      onClick={() =&gt; setShowComposerHint(false)}\n                    &gt;\n                      Hide\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                ) : (\n                  &lt;button\n                    type=\"button\"\n                    className=\"selection-hint-toggle is-show\"\n                    onClick={() =&gt; setShowComposerHint(true)}\n                  &gt;\n                    Show tip\n                  &lt;/button&gt;\n                )}\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

The model made no changes to the file.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/styles.css</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "b16b8ea5-ba54-474f-9cf9-bce61102ab9e",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "b16b8ea5-ba54-474f-9cf9-bce61102ab9e",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight.is-tip {\n    cursor: default;\n    pointer-events: none;\n    color: black;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.selection-hint-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n    margin-bottom: 8px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input--empty .selection-hint-row {\n    justify-content: center;\n    flex-wrap: wrap;\n}\n\n.selection-hint-toggle {\n    background: transparent;\n    border: 1px solid #2c3546;\n    color: #9aa3b2;\n    padding: 2px 8px;\n    border-radius: 999px;\n    font-size: 11px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.selection-hint-toggle:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    color: #e6e9ef;\n}\n\n.selection-hint-toggle.is-show {\n    align-self: flex-start;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  }\n  \n- .chat-input .selection-hint {\n+ .selection-hint-row {\n+     display: flex;\n+     align-items: center;\n+     justify-content: space-between;\n+     gap: 12px;\n      margin-bottom: 8px;\n  }",
        "oldStart": 969,
        "newStart": 969,
        "oldLines": 5,
        "newLines": 9,
        "linesRemoved": 1,
        "linesAdded": 5
      },
      {
        "diffString": "      text-align: center;\n  }\n+ \n+ .chat-input--empty .selection-hint-row {\n+     justify-content: center;\n+     flex-wrap: wrap;\n+ }\n+ \n+ .selection-hint-toggle {\n+     background: transparent;\n+     border: 1px solid #2c3546;\n+     color: #9aa3b2;\n+     padding: 2px 8px;\n+     border-radius: 999px;\n+     font-size: 11px;\n+     cursor: pointer;\n+     transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n+ }\n+ \n+ .selection-hint-toggle:hover {\n+     background: rgba(255, 255, 255, 0.06);\n+     border-color: #3c465a;\n+     color: #e6e9ef;\n+ }\n+ \n+ .selection-hint-toggle.is-show {\n+     align-self: flex-start;\n+ }\n  \n  .chat-input .send-button {",
        "oldStart": 986,
        "newStart": 990,
        "oldLines": 4,
        "newLines": 30,
        "linesAdded": 26
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight.is-tip {\n    cursor: default;\n    pointer-events: none;\n    color: black;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.selection-hint-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n    margin-bottom: 8px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input--empty .selection-hint-row {\n    justify-content: center;\n    flex-wrap: wrap;\n}\n\n.selection-hint-toggle {\n    background: transparent;\n    border: 1px solid #2c3546;\n    color: #9aa3b2;\n    padding: 2px 8px;\n    border-radius: 999px;\n    font-size: 11px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.selection-hint-toggle:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    color: #e6e9ef;\n}\n\n.selection-hint-toggle.is-show {\n    align-self: flex-start;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`
- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

Added a hide/show control for the composer tip with default visible. It’s now a small “Hide” button next to the hint, and when hidden you’ll see a “Show tip” button above the composer.

If you want the setting to persist across reloads, say the word and I’ll store it in localStorage.

---

_**User (2026-01-18 16:02Z)**_

put the hide button just after the text instead of justify between

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Adjusting layout for inline button**

Planning to update CSS for .selection-hint-row to use inline-flex with centered alignment and gap, removing space-between to place the button immediately after the text inline. Also considering centering the layout for empty states.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "f55bc35b-b463-4a09-96fa-156c0d62a889",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "f55bc35b-b463-4a09-96fa-156c0d62a889",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight.is-tip {\n    cursor: default;\n    pointer-events: none;\n    color: black;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.selection-hint-row {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    margin-bottom: 8px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input--empty .selection-hint-row {\n    justify-content: center;\n    flex-wrap: wrap;\n}\n\n.selection-hint-toggle {\n    background: transparent;\n    border: 1px solid #2c3546;\n    color: #9aa3b2;\n    padding: 2px 8px;\n    border-radius: 999px;\n    font-size: 11px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.selection-hint-toggle:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    color: #e6e9ef;\n}\n\n.selection-hint-toggle.is-show {\n    align-self: flex-start;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  \n  .selection-hint-row {\n-     display: flex;\n+     display: inline-flex;\n      align-items: center;\n-     justify-content: space-between;\n-     gap: 12px;\n+     gap: 8px;\n      margin-bottom: 8px;\n  }",
        "oldStart": 970,
        "newStart": 970,
        "oldLines": 8,
        "newLines": 7,
        "linesRemoved": 3,
        "linesAdded": 2
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight.is-tip {\n    cursor: default;\n    pointer-events: none;\n    color: black;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.selection-hint-row {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    margin-bottom: 8px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input--empty .selection-hint-row {\n    justify-content: center;\n    flex-wrap: wrap;\n}\n\n.selection-hint-toggle {\n    background: transparent;\n    border: 1px solid #2c3546;\n    color: #9aa3b2;\n    padding: 2px 8px;\n    border-radius: 999px;\n    font-size: 11px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.selection-hint-toggle:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    color: #e6e9ef;\n}\n\n.selection-hint-toggle.is-show {\n    align-self: flex-start;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results


**No lint errors found**
</details>
</tool-use>

---

Updated the layout so the “Hide” button sits immediately after the tip text (inline, with a small gap), not spaced to the far edge.

If you want it to wrap under the text instead of inline on smaller widths, I can adjust that too.

---

_**User (2026-01-18 16:02Z)**_

remove hide button in the initial chat screen, leave it just when we're in a thread

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "b46a1b4d-eb76-4913-a5ea-7b830b94ee43",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "b46a1b4d-eb76-4913-a5ea-7b830b94ee43",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [showComposerHint, setShowComposerHint] = useState(true);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to create a new branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        if (event.metaKey || event.ctrlKey || event.altKey) return;\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Let's start branching?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                {showComposerHint ? (\n                  &lt;div className=\"selection-hint-row\"&gt;\n                    &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"selection-hint-toggle\"\n                      onClick={() =&gt; setShowComposerHint(false)}\n                    &gt;\n                      Hide\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                ) : (\n                  &lt;button\n                    type=\"button\"\n                    className=\"selection-hint-toggle is-show\"\n                    onClick={() =&gt; setShowComposerHint(true)}\n                  &gt;\n                    Show tip\n                  &lt;/button&gt;\n                )}\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n                &lt;div className=\"chat-input chat-input--empty\"&gt;\n-                 {showComposerHint ? (\n-                   &lt;div className=\"selection-hint-row\"&gt;\n-                     &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n-                     &lt;button\n-                       type=\"button\"\n-                       className=\"selection-hint-toggle\"\n-                       onClick={() =&gt; setShowComposerHint(false)}\n-                     &gt;\n-                       Hide\n-                     &lt;/button&gt;\n-                   &lt;/div&gt;\n-                 ) : (\n-                   &lt;button\n-                     type=\"button\"\n-                     className=\"selection-hint-toggle is-show\"\n-                     onClick={() =&gt; setShowComposerHint(true)}\n-                   &gt;\n-                     Show tip\n-                   &lt;/button&gt;\n-                 )}\n+                 &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                  &lt;div className=\"composer\"&gt;\n                    &lt;textarea",
        "oldStart": 1927,
        "newStart": 1927,
        "oldLines": 24,
        "newLines": 5,
        "linesRemoved": 20,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [showComposerHint, setShowComposerHint] = useState(true);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to create a new branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        if (event.metaKey || event.ctrlKey || event.altKey) return;\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Let's start branching?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                {showComposerHint ? (\n                  &lt;div className=\"selection-hint-row\"&gt;\n                    &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"selection-hint-toggle\"\n                      onClick={() =&gt; setShowComposerHint(false)}\n                    &gt;\n                      Hide\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                ) : (\n                  &lt;button\n                    type=\"button\"\n                    className=\"selection-hint-toggle is-show\"\n                    onClick={() =&gt; setShowComposerHint(true)}\n                  &gt;\n                    Show tip\n                  &lt;/button&gt;\n                )}\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

Done. The initial chat screen now shows just the tip text (no hide button). The hide/show control remains only inside an active thread.

---

_**User (2026-01-18 16:02Z)**_

the tip section changes height between hide and show state, make the height constant so no hickup

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Adjusting CSS and markup for fixed hint row height**

Planning to wrap both hint states in a persistent container with class selection-hint-row having min-height set to keep consistent height, modifying App.jsx to always render this container and include the toggle button inside it when hidden.
**Refining CSS and App.jsx only for thread footer**

Decided to set min-height 22px with align-items center and consistent margin-bottom on selection-hint-row, keeping inline-flex. Planning to update App.jsx only in the thread footer area to wrap hint and toggle button without changing initial state rendering.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "10382377-3159-467e-a0c6-5211dc91f732",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "10382377-3159-467e-a0c6-5211dc91f732",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [showComposerHint, setShowComposerHint] = useState(true);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to create a new branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        if (event.metaKey || event.ctrlKey || event.altKey) return;\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Let's start branching?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"selection-hint-row\"&gt;\n                  {showComposerHint ? (\n                    &lt;&gt;\n                      &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                      &lt;button\n                        type=\"button\"\n                        className=\"selection-hint-toggle\"\n                        onClick={() =&gt; setShowComposerHint(false)}\n                      &gt;\n                        Hide\n                      &lt;/button&gt;\n                    &lt;/&gt;\n                  ) : (\n                    &lt;button\n                      type=\"button\"\n                      className=\"selection-hint-toggle is-show\"\n                      onClick={() =&gt; setShowComposerHint(true)}\n                    &gt;\n                      Show tip\n                    &lt;/button&gt;\n                  )}\n                &lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "                &lt;/section&gt;\n                &lt;footer className=\"chat-input\"&gt;\n-                 {showComposerHint ? (\n-                   &lt;div className=\"selection-hint-row\"&gt;\n-                     &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n-                     &lt;button\n-                       type=\"button\"\n-                       className=\"selection-hint-toggle\"\n-                       onClick={() =&gt; setShowComposerHint(false)}\n-                     &gt;\n-                       Hide\n-                     &lt;/button&gt;\n-                   &lt;/div&gt;\n-                 ) : (\n-                   &lt;button\n-                     type=\"button\"\n-                     className=\"selection-hint-toggle is-show\"\n-                     onClick={() =&gt; setShowComposerHint(true)}\n-                   &gt;\n-                     Show tip\n-                   &lt;/button&gt;\n-                 )}\n+                 &lt;div className=\"selection-hint-row\"&gt;\n+                   {showComposerHint ? (\n+                     &lt;&gt;\n+                       &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n+                       &lt;button\n+                         type=\"button\"\n+                         className=\"selection-hint-toggle\"\n+                         onClick={() =&gt; setShowComposerHint(false)}\n+                       &gt;\n+                         Hide\n+                       &lt;/button&gt;\n+                     &lt;/&gt;\n+                   ) : (\n+                     &lt;button\n+                       type=\"button\"\n+                       className=\"selection-hint-toggle is-show\"\n+                       onClick={() =&gt; setShowComposerHint(true)}\n+                     &gt;\n+                       Show tip\n+                     &lt;/button&gt;\n+                   )}\n+                 &lt;/div&gt;\n                  &lt;div className=\"composer\"&gt;\n                    &lt;textarea",
        "oldStart": 2045,
        "newStart": 2045,
        "oldLines": 24,
        "newLines": 26,
        "linesRemoved": 20,
        "linesAdded": 22
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst buildPlainTextIndex = (content) =&gt; {\n  const map = [];\n  let plain = \"\";\n  let i = 0;\n\n  while (i &lt; content.length) {\n    if (content[i] === \"\\\\\") {\n      if (i + 1 &lt; content.length) {\n        plain += content[i + 1];\n        map.push(i + 1);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (content[i] === \"&#96;\") {\n      let tickCount = 1;\n      while (content[i + tickCount] === \"&#96;\") tickCount += 1;\n      const ticks = \"&#96;\".repeat(tickCount);\n      const end = content.indexOf(ticks, i + tickCount);\n      if (end !== -1) {\n        for (let j = i + tickCount; j &lt; end; j += 1) {\n          plain += content[j];\n          map.push(j);\n        }\n        i = end + tickCount;\n        continue;\n      }\n    }\n\n    if (content[i] === \"[\") {\n      const closeBracket = content.indexOf(\"]\", i + 1);\n      if (closeBracket !== -1 &amp;&amp; content[closeBracket + 1] === \"(\") {\n        const closeParen = content.indexOf(\")\", closeBracket + 2);\n        if (closeParen !== -1) {\n          for (let j = i + 1; j &lt; closeBracket; j += 1) {\n            plain += content[j];\n            map.push(j);\n          }\n          i = closeParen + 1;\n          continue;\n        }\n      }\n    }\n\n    if (content.startsWith(\"**\", i) || content.startsWith(\"__\", i) || content.startsWith(\"~~\", i)) {\n      i += 2;\n      continue;\n    }\n    if (content[i] === \"*\" || content[i] === \"_\") {\n      i += 1;\n      continue;\n    }\n\n    plain += content[i];\n    map.push(i);\n    i += 1;\n  }\n\n  return { plain, map };\n};\n\nconst findMatchInPlainText = (content, selectedText) =&gt; {\n  if (!content || !selectedText) return null;\n  const { plain, map } = buildPlainTextIndex(content);\n  let matchIndex = plain.indexOf(selectedText);\n  let matchText = selectedText;\n\n  if (matchIndex === -1) {\n    const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n    try {\n      const re = new RegExp(pattern, \"m\");\n      const match = re.exec(plain);\n      if (!match || match.index == null) return null;\n      matchIndex = match.index;\n      matchText = match[0];\n    } catch {\n      return null;\n    }\n  }\n\n  if (matchIndex &lt; 0 || !matchText) return null;\n  const startRaw = map[matchIndex];\n  const endRawIndex = map[matchIndex + matchText.length - 1];\n  if (startRaw == null || endRawIndex == null) return null;\n  return { startRaw, endRaw: endRawIndex + 1 };\n};\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        cleaned.slice(0, match.index) +\n        start +\n        cleaned.slice(match.index, match.index + matchText.length) +\n        end +\n        cleaned.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(cleaned, selectedText);\n  if (!fallbackMatch) return cleaned;\n  return (\n    cleaned.slice(0, fallbackMatch.startRaw) +\n    start +\n    cleaned.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    cleaned.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (match &amp;&amp; match.index != null) {\n      const matchText = match[0];\n      return (\n        content.slice(0, match.index) +\n        start +\n        content.slice(match.index, match.index + matchText.length) +\n        end +\n        content.slice(match.index + matchText.length)\n      );\n    }\n  } catch {\n    // Fall through to plain-text matching.\n  }\n\n  const fallbackMatch = findMatchInPlainText(content, selectedText);\n  if (!fallbackMatch) return content;\n  return (\n    content.slice(0, fallbackMatch.startRaw) +\n    start +\n    content.slice(fallbackMatch.startRaw, fallbackMatch.endRaw) +\n    end +\n    content.slice(fallbackMatch.endRaw)\n  );\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const markerToText = (marker) =&gt; {\n    if (marker.kind === \"end\") {\n      return marker.highlightType === \"branch\" ? BRANCH_HL_END : TEMP_HL_END;\n    }\n    if (marker.highlightType === \"branch\") {\n      return &#96;${BRANCH_HL_START}${marker.highlightId}:${marker.branchNodeId}]]]&#96;;\n    }\n    return &#96;${TEMP_HL_START}${marker.tempId}]]]&#96;;\n  };\n\n  const splitTextWithMarkers = (value) =&gt; {\n    const result = [];\n    let i = 0;\n    const pushText = (text) =&gt; {\n      if (text) result.push({ type: \"text\", value: text });\n    };\n\n    while (i &lt; value.length) {\n      const candidates = [\n        { kind: \"branch-start\", token: BRANCH_HL_START, index: value.indexOf(BRANCH_HL_START, i) },\n        { kind: \"temp-start\", token: TEMP_HL_START, index: value.indexOf(TEMP_HL_START, i) },\n        { kind: \"branch-end\", token: BRANCH_HL_END, index: value.indexOf(BRANCH_HL_END, i) },\n        { kind: \"temp-end\", token: TEMP_HL_END, index: value.indexOf(TEMP_HL_END, i) },\n      ].filter((entry) =&gt; entry.index !== -1);\n\n      if (!candidates.length) {\n        pushText(value.slice(i));\n        break;\n      }\n\n      candidates.sort((a, b) =&gt; a.index - b.index);\n      const next = candidates[0];\n      if (next.index &gt; i) {\n        pushText(value.slice(i, next.index));\n      }\n\n      if (next.kind === \"branch-end\" || next.kind === \"temp-end\") {\n        result.push({\n          type: \"highlightMarker\",\n          kind: \"end\",\n          highlightType: next.kind === \"branch-end\" ? \"branch\" : \"temp\",\n        });\n        i = next.index + next.token.length;\n        continue;\n      }\n\n      const metaEndIdx = value.indexOf(\"]]]\", next.index);\n      if (metaEndIdx === -1) {\n        pushText(value.slice(next.index));\n        break;\n      }\n      const meta = value.slice(next.index + next.token.length, metaEndIdx);\n      if (next.kind === \"branch-start\") {\n        const [highlightId, branchNodeId] = meta.split(\":\");\n        if (highlightId &amp;&amp; branchNodeId) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"branch\",\n            highlightId,\n            branchNodeId,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      } else {\n        if (meta) {\n          result.push({\n            type: \"highlightMarker\",\n            kind: \"start\",\n            highlightType: \"temp\",\n            tempId: meta,\n          });\n        } else {\n          pushText(value.slice(next.index, metaEndIdx + 3));\n        }\n      }\n      i = metaEndIdx + 3;\n    }\n\n    return result;\n  };\n\n  const makeLinkNode = (marker, children) =&gt; {\n    if (marker.highlightType === \"branch\") {\n      return {\n        type: \"link\",\n        url: &#96;branch-highlight:${marker.highlightId}:${marker.branchNodeId}&#96;,\n        children,\n      };\n    }\n    return {\n      type: \"link\",\n      url: &#96;temp-highlight:${marker.tempId}&#96;,\n      children,\n    };\n  };\n\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const expanded = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          expanded.push(...splitTextWithMarkers(child.value));\n        } else {\n          expanded.push(child);\n        }\n      });\n\n      const nextChildren = [];\n      let active = null;\n      let buffer = [];\n      const pushNode = (child) =&gt; {\n        if (active) {\n          buffer.push(child);\n        } else {\n          nextChildren.push(child);\n        }\n      };\n\n      expanded.forEach((child) =&gt; {\n        if (child?.type === \"highlightMarker\") {\n          if (child.kind === \"start\" &amp;&amp; !active) {\n            active = child;\n            buffer = [];\n            return;\n          }\n          if (\n            child.kind === \"end\" &amp;&amp;\n            active &amp;&amp;\n            child.highlightType === active.highlightType\n          ) {\n            if (buffer.length) {\n              nextChildren.push(makeLinkNode(active, buffer));\n            }\n            active = null;\n            buffer = [];\n            return;\n          }\n          pushNode({ type: \"text\", value: markerToText(child) });\n          return;\n        }\n\n        transformNode(child);\n        pushNode(child);\n      });\n\n      if (active) {\n        nextChildren.push({ type: \"text\", value: markerToText(active) }, ...buffer);\n      }\n\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    return { treesById: parsed.treesById, activeTreeId: null };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  return { treesById: {}, activeTreeId: null };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [showComposerHint, setShowComposerHint] = useState(true);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = activeTreeId ? treesById[activeTreeId] : null;\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId ?? null;\n  const activeNode = nodesById[activeNodeId];\n  const hasActiveTree = Boolean(activeTreeId &amp;&amp; activeTree);\n  const isEmptyThread = !hasActiveTree || (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = Boolean(activeNodeId &amp;&amp; activeNodeId !== \"root\");\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const selectionHint = (\n    &lt;&gt;\n      Tip: Highlight text, then press{\" \"}\n      &lt;span className=\"branch-highlight is-tip\"&gt;Shift&lt;/span&gt; to create a new branch.\n    &lt;/&gt;\n  );\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    if (!activeTreeId) return;\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    if (!remaining.length) {\n      setTreesById({});\n      setActiveTreeId(null);\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(null);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        if (event.metaKey || event.ctrlKey || event.altKey) return;\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    let treeIdSnapshot = activeTreeId;\n    let treeSnapshot = treeIdSnapshot ? treesById[treeIdSnapshot] : null;\n    if (!treeSnapshot) {\n      const freshTree = createTree(\"New Tree\");\n      setTreesById((prev) =&gt; ({ ...prev, [freshTree.id]: freshTree }));\n      setActiveTreeId(freshTree.id);\n      treeIdSnapshot = freshTree.id;\n      treeSnapshot = freshTree;\n    }\n    const nodeIdSnapshot = treeSnapshot.activeNodeId;\n    const nodeSnapshot = treeSnapshot.nodesById[nodeIdSnapshot];\n    const isFirstRootTurn =\n      nodeIdSnapshot === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = nodeIdSnapshot &amp;&amp; nodeIdSnapshot !== \"root\"\n      ? buildHiddenContextForNode(nodeIdSnapshot, treeSnapshot.nodesById)\n      : \"\";\n    updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeIdSnapshot, nodeIdSnapshot, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1\n                className=\"app-title\"\n                role=\"button\"\n                tabIndex={0}\n                onClick={() =&gt; {\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                onKeyDown={(event) =&gt; {\n                  if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                  event.preventDefault();\n                  setActiveTreeId(null);\n                  closeTreeMenu();\n                }}\n                title=\"Show all trees\"\n              &gt;\n                BranchGPT\n              &lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              {treeList.length &gt; 1 &amp;&amp; (\n                &lt;button\n                  type=\"button\"\n                  className=\"collapse-tree-button\"\n                  onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                  title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n                &gt;\n                  {isTreeListCollapsed ? \"Show trees\" : \"Hide trees\"}\n                &lt;/button&gt;\n              )}\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          {hasActiveTree &amp;&amp; (\n            &lt;div className=\"view-toggle\"&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"graph\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"graph\")}\n                aria-label=\"Graph view\"\n                title=\"Graph view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                  &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                  &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className={treeView === \"list\" ? \"active\" : \"\"}\n                onClick={() =&gt; setTreeView(\"list\")}\n                aria-label=\"List view\"\n                title=\"List view\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        {hasActiveTree &amp;&amp;\n          (treeView === \"graph\" ? (\n            &lt;&gt;\n\n              &lt;div\n                className=\"tree-graph\"\n                ref={graphContainerRef}\n                onWheel={handleGraphWheel}\n                onMouseDown={handleGraphMouseDown}\n              &gt;\n                &lt;svg\n                  width=\"100%\"\n                  height=\"100%\"\n                  viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n                  preserveAspectRatio=\"xMidYMin meet\"\n                &gt;\n                  &lt;g\n                    transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n                  &gt;\n                    {graphLayout.edges.map((edge) =&gt; {\n                      const from = graphLayout.positions[edge.from];\n                      const to = graphLayout.positions[edge.to];\n                      if (!from || !to) return null;\n                      return (\n                        &lt;line\n                          key={&#96;${edge.from}-${edge.to}&#96;}\n                          x1={from.x}\n                          y1={from.y}\n                          x2={to.x}\n                          y2={to.y}\n                          className=\"graph-edge\"\n                        /&gt;\n                      );\n                    })}\n                    {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                      const node = nodesById[nodeId];\n                      if (!node) return null;\n                      const words = (node.title || \"\").split(\" \").filter(Boolean);\n                      const isPending = node?.requestStatus === \"pending\";\n                      const isReady = node?.hasUnread;\n                      return (\n                        &lt;g\n                          key={nodeId}\n                          className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                            } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                          onClick={() =&gt; setActiveNodeId(nodeId)}\n                          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                        &gt;\n                          &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                          {isPending &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge pending\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          {!isPending &amp;&amp; isReady &amp;&amp; (\n                            &lt;circle\n                              className=\"graph-node-badge ready\"\n                              cx={pos.x + 22}\n                              cy={pos.y - 22}\n                              r=\"6\"\n                            /&gt;\n                          )}\n                          &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                            {words.length &gt; 1 ? (\n                              &lt;&gt;\n                                &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                                  {words[0]}\n                                &lt;/tspan&gt;\n                                &lt;tspan x={pos.x} dy=\"14\"&gt;\n                                  {words.slice(1).join(\" \")}\n                                &lt;/tspan&gt;\n                              &lt;/&gt;\n                            ) : (\n                              &lt;tspan x={pos.x} dy=\"4\"&gt;\n                                {words[0]}\n                              &lt;/tspan&gt;\n                            )}\n                          &lt;/text&gt;\n                        &lt;/g&gt;\n                      );\n                    })}\n                  &lt;/g&gt;\n                &lt;/svg&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n          ))}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Let's start branching?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"selection-hint-row\"&gt;\n                  {showComposerHint ? (\n                    &lt;&gt;\n                      &lt;div className=\"selection-hint\"&gt;{selectionHint}&lt;/div&gt;\n                      &lt;button\n                        type=\"button\"\n                        className=\"selection-hint-toggle\"\n                        onClick={() =&gt; setShowComposerHint(false)}\n                      &gt;\n                        Hide\n                      &lt;/button&gt;\n                    &lt;/&gt;\n                  ) : (\n                    &lt;button\n                      type=\"button\"\n                      className=\"selection-hint-toggle is-show\"\n                      onClick={() =&gt; setShowComposerHint(true)}\n                    &gt;\n                      Show tip\n                    &lt;/button&gt;\n                  )}\n                &lt;/div&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
}
```
Additional data:

```json
{
  "codeblockId": "169a7b5f-a316-469a-bb38-9d8a497e4589",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/styles.css",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/styles.css",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/styles.css"
    },
    "codeblockId": "169a7b5f-a316-469a-bb38-9d8a497e4589",
    "codeBlockIdx": 0,
    "content": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight.is-tip {\n    cursor: default;\n    pointer-events: none;\n    color: black;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.selection-hint-row {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    margin-bottom: 8px;\n    min-height: 22px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input--empty .selection-hint-row {\n    justify-content: center;\n    flex-wrap: wrap;\n}\n\n.selection-hint-toggle {\n    background: transparent;\n    border: 1px solid #2c3546;\n    color: #9aa3b2;\n    padding: 2px 8px;\n    border-radius: 999px;\n    font-size: 11px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.selection-hint-toggle:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    color: #e6e9ef;\n}\n\n.selection-hint-toggle.is-show {\n    align-self: flex-start;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}",
    "languageId": "css"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "      gap: 8px;\n      margin-bottom: 8px;\n+     min-height: 22px;\n  }\n  ",
        "oldStart": 974,
        "newStart": 974,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/styles.css",
  "contentsAfterEdit": "* {\n    box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n    height: 100%;\n}\n\nbody {\n    margin: 0;\n    font-family: \"Inter\", system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\",\n        sans-serif;\n    background: #0f1115;\n    color: #e6e9ef;\n    overflow: auto;\n}\n\nbody.is-resizing {\n    user-select: none;\n    cursor: col-resize;\n}\n\n#root {\n    min-height: 100vh;\n}\n\n.app {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    background: #161a22;\n    border-right: 1px solid #242b37;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    height: 100vh;\n    overflow: hidden;\n    position: sticky;\n    top: 0;\n    flex: 0 0 auto;\n    min-width: 240px;\n    max-width: 520px;\n}\n\n.sidebar-resizer {\n    width: 8px;\n    cursor: col-resize;\n    background: #0f1115;\n    border-right: 1px solid #242b37;\n    border-left: 1px solid #242b37;\n}\n\n.sidebar-header h1 {\n    margin: 0;\n    font-size: 20px;\n}\n\n.app-title {\n    cursor: pointer;\n    user-select: none;\n}\n\n.sidebar-title-row {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 12px;\n}\n\n.sidebar-actions {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.sidebar-header p {\n    margin: 6px 0 12px;\n    color: #9aa3b2;\n    font-size: 13px;\n}\n\n.new-tree-button {\n    background: #2b3447;\n    color: #e6e9ef;\n    border: 1px solid #3c465a;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.new-tree-button:hover {\n    background: #343e52;\n    border-color: #4b5770;\n}\n\n.collapse-tree-button {\n    background: transparent;\n    color: #9aa3b2;\n    border: 1px solid #2c3546;\n    border-radius: 10px;\n    padding: 6px 10px;\n    font-size: 12px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: border-color 120ms ease, color 120ms ease, background 120ms ease;\n}\n\n.collapse-tree-button:hover {\n    color: #e6e9ef;\n    border-color: #4b5770;\n    background: rgba(255, 255, 255, 0.04);\n}\n\n.tree-list {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n    max-height: 220px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    padding-right: 2px;\n}\n\n.tree-switch-row {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-radius: 10px;\n    background: #141821;\n}\n\n.tree-switch-row:hover {\n    background: #1a2030;\n}\n\n.tree-switch-row.active {\n    background: #212838;\n}\n\n.tree-switch {\n    flex: 1;\n    min-width: 0;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-switch-actions {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding-right: 6px;\n    flex: 0 0 auto;\n}\n\n.tree-actions-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 120ms ease, background 120ms ease, color 120ms ease;\n}\n\n.tree-switch-row:hover .tree-actions-button,\n.tree-switch-row:focus-within .tree-actions-button {\n    opacity: 1;\n}\n\n.tree-actions-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    color: #e6e9ef;\n}\n\n.tree-actions-button svg {\n    width: 18px;\n    height: 18px;\n    fill: currentColor;\n}\n\n.tree-switch-title {\n    font-size: 13px;\n    font-weight: 400;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n    flex: 1;\n}\n\n.tree-switch-meta {\n    font-size: 11px;\n    color: #9aa3b2;\n    white-space: nowrap;\n}\n\n.tree-menu-popover {\n    position: fixed;\n    width: 220px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 8px;\n    z-index: 1800;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);\n}\n\n.tree-menu-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: #e6e9ef;\n    padding: 8px 10px;\n    border-radius: 10px;\n    cursor: pointer;\n}\n\n.tree-menu-item:hover {\n    background: #1f2532;\n}\n\n.tree-menu-item.danger {\n    color: #fca5a5;\n}\n\n.tree-menu-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin: 2px 4px 8px;\n}\n\n.tree-menu-input {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px 10px;\n    margin-bottom: 10px;\n}\n\n.tree-menu-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.tree-menu-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.tree-menu-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n.view-toggle {\n    margin-top: 12px;\n    display: inline-flex;\n    gap: 6px;\n    background: #1f2532;\n    border-radius: 10px;\n    padding: 4px;\n}\n\n.view-toggle button {\n    border: none;\n    background: transparent;\n    color: #9aa3b2;\n    padding: 6px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.view-toggle button.active {\n    background: #2b3447;\n    color: #f8d34a;\n}\n\n.view-toggle svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.tree {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.tree-graph {\n    flex: 1;\n    overflow: hidden;\n    border: 1px solid #242b37;\n    border-radius: 12px;\n    padding: 8px;\n    background: #131722;\n    height: 100%;\n    cursor: grab;\n    user-select: none;\n}\n\n.tree-graph:active {\n    cursor: grabbing;\n}\n\n.graph-edge {\n    stroke: #3c4558;\n    stroke-width: 1.5;\n}\n\n.graph-node {\n    cursor: pointer;\n    fill: #151a24;\n    stroke: #f8d34a;\n    stroke-width: 2.5;\n}\n\n.graph-node text {\n    fill: #e6e9ef;\n    font-size: 11px;\n    font-weight: 700;\n    pointer-events: none;\n    paint-order: stroke;\n    stroke: #0f1115;\n    stroke-width: 2px;\n    letter-spacing: 0.3px;\n}\n\n.graph-node.active circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n}\n\n.graph-node-badge {\n    stroke: #0f1115;\n    stroke-width: 2;\n}\n\n.graph-node-badge.pending {\n    fill: #f8d34a;\n}\n\n.graph-node-badge.ready {\n    fill: #58e3a1;\n}\n\n.tree-item {\n    width: 100%;\n    text-align: left;\n    border: none;\n    background: transparent;\n    color: inherit;\n    padding: 8px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.tree-item:hover {\n    background: #1f2532;\n}\n\n.tree-item.active {\n    background: #2b3447;\n}\n\n.tree-title {\n    font-size: 14px;\n    font-weight: 500;\n    flex: 1 1 auto;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.tree-item-label {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    width: 100%;\n}\n\n.tree-badge {\n    font-size: 11px;\n    font-weight: 600;\n    padding: 2px 6px;\n    border-radius: 999px;\n    border: 1px solid transparent;\n    letter-spacing: 0.2px;\n    text-transform: uppercase;\n}\n\n.tree-badge.pending {\n    color: #f8d34a;\n    border-color: #3d3420;\n    background: rgba(248, 211, 74, 0.12);\n}\n\n.tree-badge.ready {\n    color: #58e3a1;\n    border-color: #214a3a;\n    background: rgba(88, 227, 161, 0.12);\n}\n\n.chat {\n    display: flex;\n    justify-content: center;\n    min-height: 100vh;\n    padding: 0 24px;\n    flex: 1;\n}\n\n.chat-frame {\n    width: 100%;\n    max-width: 860px;\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n    min-height: 100vh;\n}\n\n.chat-empty {\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 24px;\n    padding: 24px;\n}\n\n.chat-empty-title {\n    margin: 0;\n    font-size: 56px;\n    font-weight: 500;\n    letter-spacing: -0.02em;\n    text-align: center;\n    color: #e6e9ef;\n}\n\n.chat-header {\n    padding: 20px 24px 12px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.chat-header h2 {\n    margin: 0 0 4px;\n}\n\n.chat-subhead {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.chat-meta {\n    color: #9aa3b2;\n    font-size: 12px;\n}\n\n.teleport-button {\n    border: 1px solid #2c3546;\n    background: rgba(255, 255, 255, 0.03);\n    color: #e6e9ef;\n    border-radius: 9999px;\n    padding: 6px 10px;\n    display: inline-flex;\n    align-items: baseline;\n    gap: 8px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, transform 120ms ease;\n}\n\n.teleport-button:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    transform: translateY(-1px);\n}\n\n.teleport-button:active {\n    transform: translateY(0);\n}\n\n.teleport-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.22);\n}\n\n.teleport-button-label {\n    font-size: 12px;\n    font-weight: 600;\n}\n\n.teleport-button-parent {\n    font-size: 12px;\n    color: #9aa3b2;\n    max-width: 220px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.thinking {\n    font-size: 13px;\n    color: #a6b3ff;\n}\n\n.chat-header-actions {\n    display: inline-flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.context-button {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;\n}\n\n.context-button:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n    border-color: #3c465a;\n}\n\n.context-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-overlay {\n    position: fixed;\n    inset: 0;\n    background: rgba(0, 0, 0, 0.6);\n    z-index: 2000;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    padding: 18px;\n}\n\n.modal {\n    width: min(820px, 96vw);\n    max-height: min(78vh, 760px);\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 14px;\n    box-shadow: 0 16px 44px rgba(0, 0, 0, 0.55);\n    display: grid;\n    grid-template-rows: auto 1fr;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 12px 14px;\n    border-bottom: 1px solid #242b37;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n.modal-title {\n    font-size: 14px;\n    font-weight: 600;\n    color: #e6e9ef;\n}\n\n.modal-close {\n    width: 34px;\n    height: 34px;\n    border-radius: 10px;\n    border: 1px solid #2c3546;\n    background: transparent;\n    color: #9aa3b2;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-close:hover {\n    background: #1f2532;\n    color: #e6e9ef;\n}\n\n.modal-close svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.modal-body {\n    padding: 12px 14px 14px;\n    overflow: auto;\n}\n\n.context-preview {\n    margin: 0;\n    white-space: pre-wrap;\n    word-break: break-word;\n    font-size: 12px;\n    line-height: 1.45;\n    color: #c5ccda;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n}\n\n.message--thinking {\n    opacity: 0.9;\n}\n\n.chat-area {\n    padding: 12px 24px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n}\n\n.message {\n    background: #1b202b;\n    border-radius: 12px;\n    padding: 12px 14px;\n    box-shadow: 0 0 0 1px #262d3a;\n}\n\n.message.user {\n    border-left: 3px solid #5b8cff;\n}\n\n.message.assistant {\n    border-left: 3px solid #6ee7b7;\n}\n\n.message-role {\n    font-size: 12px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.message-content {\n    line-height: 1.4;\n    word-break: break-word;\n}\n\n.message-content&gt; :first-child {\n    margin-top: 0;\n}\n\n.message-content&gt; :last-child {\n    margin-bottom: 0;\n}\n\n.message-content p {\n    margin: 0 0 10px;\n}\n\n.message-content a {\n    color: #8fb1ff;\n}\n\n.message-content h1,\n.message-content h2,\n.message-content h3,\n.message-content h4 {\n    margin: 16px 0 8px;\n    line-height: 1.2;\n}\n\n.message-content ul,\n.message-content ol {\n    margin: 0 0 10px 20px;\n    padding: 0;\n}\n\n.message-content li {\n    margin: 4px 0;\n}\n\n.message-content blockquote {\n    margin: 10px 0;\n    padding: 6px 12px;\n    border-left: 3px solid #4f77ff;\n    background: #151a23;\n    color: #c8d1e0;\n}\n\n.message-content hr {\n    border: none;\n    border-top: 1px solid #2c3546;\n    margin: 16px 0;\n}\n\n.message-content table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 10px 0;\n    font-size: 13px;\n}\n\n.message-content th,\n.message-content td {\n    border: 1px solid #2c3546;\n    padding: 6px 8px;\n    text-align: left;\n}\n\n.message-content th {\n    background: #151a23;\n}\n\n.message-content .inline-code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    background: #141821;\n    border: 1px solid #2c3546;\n    padding: 1px 4px;\n    border-radius: 4px;\n    font-size: 0.92em;\n}\n\n.message-content .code-block {\n    margin: 10px 0;\n    padding: 10px 12px;\n    background: #141821;\n    border: 1px solid #2c3546;\n    border-radius: 8px;\n    overflow-x: auto;\n}\n\n.message-content .code-block code {\n    font-family: \"SFMono-Regular\", Menlo, Monaco, Consolas, \"Liberation Mono\",\n        \"Courier New\", monospace;\n    font-size: 0.92em;\n}\n\n.message-content .katex {\n    font-size: 1em;\n}\n\n.message-content .katex-display {\n    margin: 12px 0;\n    overflow-x: auto;\n    overflow-y: hidden;\n}\n\n.branch-highlight {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n    border-radius: 4px;\n    padding: 0 3px;\n    transition: background 120ms ease, box-shadow 120ms ease;\n    cursor: pointer;\n}\n\n.branch-highlight.is-temp {\n    cursor: default;\n    pointer-events: none;\n}\n\n.branch-highlight.is-tip {\n    cursor: default;\n    pointer-events: none;\n    color: black;\n}\n\n.branch-highlight:hover,\n.branch-highlight.is-hovered {\n    background: rgba(255, 235, 59, 0.82);\n    box-shadow: 0 0 0 1px rgba(255, 235, 59, 0.65);\n}\n\n.branch-highlight.no-hover:hover {\n    background: rgba(255, 235, 59, 0.55);\n    box-shadow: none;\n}\n\n.branch-highlight.teleport-flash {\n    animation: teleportPulse 900ms ease-out 1;\n}\n\n@keyframes teleportPulse {\n    0% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n\n    18% {\n        box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.35);\n    }\n\n    100% {\n        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.0);\n    }\n}\n\n.chat-area ::selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.chat-area ::-moz-selection {\n    background: rgba(255, 235, 59, 0.55);\n    color: inherit;\n}\n\n.tree-item.branch-hover {\n    background: #2b3447;\n    box-shadow: 0 0 0 1px rgba(248, 211, 74, 0.55);\n}\n\n.graph-node.branch-hover circle {\n    fill: #2b3447;\n    stroke: #ffe37a;\n    filter: drop-shadow(0 8px 14px rgba(248, 211, 74, 0.18));\n}\n\n.error-banner {\n    background: #3b1f1f;\n    color: #fca5a5;\n    padding: 10px 12px;\n    border-radius: 10px;\n    border: 1px solid #6b2a2a;\n}\n\n.chat-input {\n    padding: 16px 24px 22px;\n    border-top: 1px solid #242b37;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    align-items: stretch;\n    position: sticky;\n    bottom: 0;\n    background: rgba(15, 17, 21, 0.92);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n}\n\n.chat-input--empty {\n    position: static;\n    width: min(900px, 100%);\n    border-top: none;\n    padding: 0;\n    background: transparent;\n    backdrop-filter: none;\n    -webkit-backdrop-filter: none;\n}\n\n.chat-input textarea {\n    flex: 1;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 10px 56px 10px 10px;\n    resize: none;\n    overflow-y: auto;\n    min-height: 96px;\n    max-height: 260px;\n    scrollbar-width: thin;\n    scrollbar-color: #3c465a #141821;\n}\n\n.chat-input textarea:focus,\n.chat-input textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.composer textarea:focus,\n.composer textarea:focus-visible,\n.selection-popover textarea:focus,\n.selection-popover textarea:focus-visible {\n    outline: none;\n    box-shadow: none;\n    border-color: #2c3546;\n}\n\n.chat-input textarea::-webkit-scrollbar {\n    width: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-track {\n    background: #141821;\n    border-radius: 10px;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb {\n    background: #3c465a;\n    border-radius: 10px;\n    border: 2px solid #141821;\n}\n\n.chat-input textarea::-webkit-scrollbar-thumb:hover {\n    background: #55627a;\n}\n\n.composer {\n    position: relative;\n    width: 100%;\n    display: flex;\n}\n\n.selection-hint {\n    font-size: 12px;\n    color: #8c96aa;\n    letter-spacing: 0.01em;\n}\n\n.selection-hint-row {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    margin-bottom: 8px;\n    min-height: 22px;\n}\n\n.graph-hint {\n    display: inline-block;\n    align-self: flex-start;\n    padding: 4px 8px;\n    margin-bottom: 6px;\n    background: rgba(15, 17, 21, 0.75);\n    border: 1px solid rgba(60, 70, 90, 0.6);\n    border-radius: 10px;\n}\n\n.chat-input--empty .selection-hint {\n    text-align: center;\n}\n\n.chat-input--empty .selection-hint-row {\n    justify-content: center;\n    flex-wrap: wrap;\n}\n\n.selection-hint-toggle {\n    background: transparent;\n    border: 1px solid #2c3546;\n    color: #9aa3b2;\n    padding: 2px 8px;\n    border-radius: 999px;\n    font-size: 11px;\n    cursor: pointer;\n    transition: background 120ms ease, border-color 120ms ease, color 120ms ease;\n}\n\n.selection-hint-toggle:hover {\n    background: rgba(255, 255, 255, 0.06);\n    border-color: #3c465a;\n    color: #e6e9ef;\n}\n\n.selection-hint-toggle.is-show {\n    align-self: flex-start;\n}\n\n.chat-input .send-button {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    width: 40px;\n    height: 40px;\n    border-radius: 9999px;\n    border: 1px solid #2c3546;\n    background: #4f77ff;\n    color: white;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    transition: transform 120ms ease, opacity 120ms ease, filter 120ms ease,\n        background 120ms ease;\n}\n\n.chat-input .send-button svg {\n    width: 18px;\n    height: 18px;\n    fill: none;\n    stroke: currentColor;\n    stroke-width: 2.2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n}\n\n.chat-input .send-button:hover:not(:disabled) {\n    filter: brightness(1.05);\n    transform: translateY(-1px);\n}\n\n.chat-input .send-button:active:not(:disabled) {\n    transform: translateY(0);\n}\n\n.chat-input .send-button:focus-visible {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(79, 119, 255, 0.35);\n}\n\n.chat-input .send-button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background: #2b3447;\n    color: #9aa3b2;\n}\n\n.selection-popover {\n    position: fixed;\n    width: 300px;\n    background: #1b202b;\n    border: 1px solid #2c3546;\n    border-radius: 12px;\n    padding: 12px;\n    z-index: 1000;\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\n    transform: translateY(0);\n}\n\n.selection-popover[data-placement=\"above\"] {\n    transform: translateY(calc(-100% - 8px));\n}\n\n.selection-title {\n    font-size: 13px;\n    color: #9aa3b2;\n    margin-bottom: 6px;\n}\n\n.selection-preview {\n    font-size: 12px;\n    color: #c5ccda;\n    margin-bottom: 10px;\n}\n\n.selection-popover textarea {\n    width: 100%;\n    background: #141821;\n    border: 1px solid #2c3546;\n    color: #e6e9ef;\n    border-radius: 10px;\n    padding: 8px;\n    resize: vertical;\n    margin-bottom: 10px;\n}\n\n.selection-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n}\n\n.selection-actions button {\n    background: transparent;\n    border: 1px solid #374156;\n    color: #e6e9ef;\n    padding: 6px 10px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n.selection-actions .primary {\n    background: #4f77ff;\n    border: none;\n}\n\n@media (max-width: 900px) {\n    .app {\n        flex-direction: column;\n    }\n\n    .sidebar {\n        border-right: none;\n        border-bottom: 1px solid #242b37;\n        height: auto;\n        position: static;\n        overflow: visible;\n        width: 100% !important;\n        max-width: none;\n    }\n\n    .sidebar-resizer {\n        display: none;\n    }\n}\n\n@media (max-width: 700px) {\n    .chat-empty-title {\n        font-size: 38px;\n    }\n}"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`
- `/Users/cosmo/Documents/projects/trees/src/styles.css`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

Made the hint row always present in the thread footer and gave it a fixed minimum height, so toggling hide/show won’t change the composer block height.

If you want the exact height matched to the text line height, I can fine-tune the `min-height`.

---

