<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session b466316d-6008-4e10-8017-94e6177eb77b (2026-01-18 19:36Z) -->

# Assistant model display (2026-01-18 19:36Z)

_**User (2026-01-18 16:02Z)**_

Next to "Assistant" in the assistant answers, give which model it is

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Inspecting main UI entry**

I'm checking the main UI file to understand the current structure and identify where to implement needed UI changes.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning search for assistant label**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "Assistant",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false,
  "headLimit": 20
}
```
Result:

```json
{
  "success": {
    "pattern": "Assistant",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 735,
                  "content": "      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\","
                },
                {
                  "lineNumber": 1790,
                  "content": "                      {message.role === \"user\" ? \"You\" : \"Assistant\"}"
                },
                {
                  "lineNumber": 1812,
                  "content": "                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;"
                }
              ]
            }
          ],
          "totalLines": 3,
          "totalMatchedLines": 3
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning model label addition**

I'm adding the model name next to "Assistant" in assistant messages only, including the thinking indicator. I'll check existing assistant labels around line 735 for the tree summary and around line 700 for potential thread list updates.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning assistant label changes**

I'm focusing on updating assistant message displays to include the model string next to "Assistant" in the UI—likely in chat message headers, thinking messages, and possibly selection popovers—while excluding user messages. I'll locate the component rendering message roles to add a helper constant that formats this label using the MODEL constant.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  "pattern": "function App|const App",
  "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
  "outputMode": "content",
  "caseInsensitive": false,
  "headLimit": 20
}
```
Result:

```json
{
  "success": {
    "pattern": "function App|const App",
    "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/cosmo/Documents/projects/trees": {
        "content": {
          "matches": [
            {
              "file": "src/App.jsx",
              "matches": [
                {
                  "lineNumber": 407,
                  "content": "const App = () =&gt; {"
                }
              ]
            }
          ],
          "totalLines": 1,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cosmo/Documents/projects/trees/src/App.jsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Standardizing assistant label display**

I'm consolidating the assistant label into a single constant for consistent use across chat UI and message previews, ensuring only assistant messages show the label with the model included, while user messages show "You." I'll update all relevant spots, including message rendering and thinking overlays, and skip model inclusion in the request tree title prompt.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "bc838e25-577e-417d-9750-b13818262fc5",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "bc838e25-577e-417d-9750-b13818262fc5",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantLabel = &#96;Assistant (${MODEL})&#96;;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    // Important: never leave &#96;activeTreeId&#96; as null even briefly; the render path assumes\n    // an active tree exists and will crash (black screen) otherwise.\n    if (!remaining.length) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(remaining[0].id);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const words = (node.title || \"\").split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    const parentNodeId = activeNode?.parentId || null;\n    const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n+   const assistantLabel = &#96;Assistant (${MODEL})&#96;;\n    const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n    const treeList = useMemo(",
        "oldStart": 468,
        "newStart": 468,
        "oldLines": 4,
        "newLines": 5,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantLabel = &#96;Assistant (${MODEL})&#96;;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    // Important: never leave &#96;activeTreeId&#96; as null even briefly; the render path assumes\n    // an active tree exists and will crash (black screen) otherwise.\n    if (!remaining.length) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(remaining[0].id);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const words = (node.title || \"\").split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : \"Assistant\"}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Replacing labels**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "7c2b9b1f-cb73-414c-b81a-3353d84ed67c",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "7c2b9b1f-cb73-414c-b81a-3353d84ed67c",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantLabel = &#96;Assistant (${MODEL})&#96;;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    // Important: never leave &#96;activeTreeId&#96; as null even briefly; the render path assumes\n    // an active tree exists and will crash (black screen) otherwise.\n    if (!remaining.length) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(remaining[0].id);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const words = (node.title || \"\").split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                  &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "                    &gt;\n                      &lt;div className=\"message-role\"&gt;\n-                       {message.role === \"user\" ? \"You\" : \"Assistant\"}\n+                       {message.role === \"user\" ? \"You\" : assistantLabel}\n                      &lt;/div&gt;\n                      &lt;div className=\"message-content\"&gt;",
        "oldStart": 1789,
        "newStart": 1789,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      },
      {
        "diffString": "                  {isLoading &amp;&amp; (\n                    &lt;div className=\"message assistant message--thinking\"&gt;\n-                     &lt;div className=\"message-role\"&gt;Assistant&lt;/div&gt;\n+                   &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                      &lt;div className=\"message-content\"&gt;\n                        &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;",
        "oldStart": 1811,
        "newStart": 1811,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantLabel = &#96;Assistant (${MODEL})&#96;;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    // Important: never leave &#96;activeTreeId&#96; as null even briefly; the render path assumes\n    // an active tree exists and will crash (black screen) otherwise.\n    if (!remaining.length) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(remaining[0].id);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const words = (node.title || \"\").split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                  &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Identifying missing lint reading function**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Completing task without tests**</details></think>

---

Added the model name next to “Assistant” for assistant messages (including the thinking state) by introducing a shared `assistantLabel` and using it in the message header render in `src/App.jsx`.

No tests run (UI-only change).

---

_**User (2026-01-18 16:02Z)**_

capitalise GPT when its gpt

---

_**Agent (model gpt-5.2-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Capitalizing model label**

I'm updating the model label display to always capitalize "GPT" in names like "gpt-5.2" by adding a helper that replaces the prefix with uppercase "GPT" before rendering.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
}
```
Additional data:

```json
{
  "codeblockId": "d5fc270e-96f3-450e-8bc0-6c6673c5d521",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cosmo/Documents/projects/trees/src/App.jsx",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cosmo/Documents/projects/trees/src/App.jsx",
      "_fsPath": "/Users/cosmo/Documents/projects/trees/src/App.jsx"
    },
    "codeblockId": "d5fc270e-96f3-450e-8bc0-6c6673c5d521",
    "codeBlockIdx": 0,
    "content": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    // Important: never leave &#96;activeTreeId&#96; as null even briefly; the render path assumes\n    // an active tree exists and will crash (black screen) otherwise.\n    if (!remaining.length) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(remaining[0].id);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const words = (node.title || \"\").split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n",
    "languageId": "javascriptreact"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "    const parentNodeId = activeNode?.parentId || null;\n    const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n-   const assistantLabel = &#96;Assistant (${MODEL})&#96;;\n+   const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n+   const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n    const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n    const treeList = useMemo(",
        "oldStart": 468,
        "newStart": 468,
        "oldLines": 5,
        "newLines": 6,
        "linesRemoved": 1,
        "linesAdded": 2
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cosmo/Documents/projects/trees/src/App.jsx",
  "contentsAfterEdit": "import React, {\n  useMemo,\n  useRef,\n  useState,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkMath from \"remark-math\";\nimport remarkBreaks from \"remark-breaks\";\nimport rehypeKatex from \"rehype-katex\";\n\nconst SYSTEM_PROMPT =\n  \"You are a helpful research assistant. Provide concise, precise explanations, \" +\n  \"use structured reasoning, and cite key assumptions when relevant.\";\n\nconst API_URL = \"https://api.openai.com/v1/chat/completions\";\nconst MODEL = \"gpt-5.2\";\n\nconst BRANCH_HL_START = \"[[[hl:\";\nconst BRANCH_HL_END = \"[[[/hl]]]\";\nconst TEMP_HL_START = \"[[[sel:\";\nconst TEMP_HL_END = \"[[[/sel]]]\";\n\nconst summarizeTitle = (text) =&gt; {\n  const cleaned = text\n    .replace(/[\\u2014\\u2013]/g, \" \")\n    .replace(/[^\\w\\s-]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  if (!cleaned) return \"New branch\";\n  const words = cleaned.split(\" \");\n  return words.slice(0, 2).join(\" \");\n};\n\nconst normalizeGeneratedTitle = (title, fallback = \"...\") =&gt; {\n  if (typeof title !== \"string\") return fallback;\n  const cleaned = title.replace(/\\s+/g, \" \").trim();\n  if (!cleaned) return fallback;\n  const words = cleaned.split(\" \").filter(Boolean);\n  if (!words.length) return fallback;\n  return words.slice(0, 4).join(\" \");\n};\n\nconst escapeRegex = (value) =&gt; value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\");\n\nconst stripAllTempHighlights = (content) =&gt; {\n  if (!content) return content;\n  return content\n    .replaceAll(TEMP_HL_END, \"\")\n    .replace(/\\[\\[\\[sel:[^\\]]+\\]\\]\\]/g, \"\");\n};\n\nconst wrapFirstMatchWithTempHighlight = (content, selectedText, tempId) =&gt; {\n  if (!content || !selectedText || !tempId) return content;\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const end = TEMP_HL_END;\n\n  const cleaned = stripAllTempHighlights(content);\n  const exactIndex = cleaned.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      cleaned.slice(0, exactIndex) +\n      start +\n      cleaned.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      cleaned.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(cleaned);\n    if (!match || match.index == null) return cleaned;\n    const matchText = match[0];\n    return (\n      cleaned.slice(0, match.index) +\n      start +\n      cleaned.slice(match.index, match.index + matchText.length) +\n      end +\n      cleaned.slice(match.index + matchText.length)\n    );\n  } catch {\n    return cleaned;\n  }\n};\n\nconst removeTempHighlightById = (content, tempId) =&gt; {\n  if (!content) return content;\n  if (!tempId) return stripAllTempHighlights(content);\n  const start = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  return content.replaceAll(start, \"\").replaceAll(TEMP_HL_END, \"\");\n};\n\nconst convertTempHighlightToBranchHighlight = (\n  content,\n  tempId,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !tempId || !highlightId || !branchNodeId) return content;\n  const tempStart = &#96;${TEMP_HL_START}${tempId}]]]&#96;;\n  const branchStart = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  return content\n    .replaceAll(tempStart, branchStart)\n    .replaceAll(TEMP_HL_END, BRANCH_HL_END);\n};\n\nconst wrapFirstMatchWithBranchHighlight = (\n  content,\n  selectedText,\n  highlightId,\n  branchNodeId,\n) =&gt; {\n  if (!content || !selectedText) return content;\n  const start = &#96;${BRANCH_HL_START}${highlightId}:${branchNodeId}]]]&#96;;\n  const end = BRANCH_HL_END;\n\n  const exactIndex = content.indexOf(selectedText);\n  if (exactIndex !== -1) {\n    return (\n      content.slice(0, exactIndex) +\n      start +\n      content.slice(exactIndex, exactIndex + selectedText.length) +\n      end +\n      content.slice(exactIndex + selectedText.length)\n    );\n  }\n\n  const pattern = escapeRegex(selectedText.trim()).replace(/\\s+/g, \"\\\\s+\");\n  try {\n    const re = new RegExp(pattern, \"m\");\n    const match = re.exec(content);\n    if (!match || match.index == null) return content;\n    const matchText = match[0];\n    return (\n      content.slice(0, match.index) +\n      start +\n      content.slice(match.index, match.index + matchText.length) +\n      end +\n      content.slice(match.index + matchText.length)\n    );\n  } catch {\n    return content;\n  }\n};\n\nconst remarkBranchHighlights = () =&gt; {\n  const transformNode = (node) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node.children)) {\n      const nextChildren = [];\n      node.children.forEach((child) =&gt; {\n        if (child?.type === \"text\" &amp;&amp; typeof child.value === \"string\") {\n          let value = child.value;\n          while (true) {\n            const branchIdx = value.indexOf(BRANCH_HL_START);\n            const tempIdx = value.indexOf(TEMP_HL_START);\n            const startIdx =\n              branchIdx === -1\n                ? tempIdx\n                : tempIdx === -1\n                  ? branchIdx\n                  : Math.min(branchIdx, tempIdx);\n            if (startIdx === -1) break;\n            const isBranch = startIdx === branchIdx;\n            const metaEndIdx = value.indexOf(\"]]]\", startIdx);\n            if (metaEndIdx === -1) break;\n            const meta = value.slice(\n              startIdx + (isBranch ? BRANCH_HL_START.length : TEMP_HL_START.length),\n              metaEndIdx,\n            );\n            const contentStartIdx = metaEndIdx + 3;\n            const endIdx = value.indexOf(isBranch ? BRANCH_HL_END : TEMP_HL_END, contentStartIdx);\n            if (endIdx === -1) break;\n\n            const before = value.slice(0, startIdx);\n            const inside = value.slice(contentStartIdx, endIdx);\n            const after = value.slice(\n              endIdx + (isBranch ? BRANCH_HL_END.length : TEMP_HL_END.length),\n            );\n\n            if (before) nextChildren.push({ type: \"text\", value: before });\n            if (isBranch) {\n              const [highlightId, branchNodeId] = meta.split(\":\");\n              if (!highlightId || !branchNodeId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;branch-highlight:${highlightId}:${branchNodeId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            } else {\n              const tempId = meta;\n              if (!tempId) break;\n              nextChildren.push({\n                type: \"link\",\n                url: &#96;temp-highlight:${tempId}&#96;,\n                children: [{ type: \"text\", value: inside }],\n              });\n            }\n\n            value = after;\n          }\n\n          if (value) {\n            nextChildren.push({ ...child, value });\n          }\n          return;\n        }\n\n        transformNode(child);\n        nextChildren.push(child);\n      });\n      node.children = nextChildren;\n      return;\n    }\n\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst remarkLatexDelimiters = () =&gt; {\n  const normalizeDelimiters = (value) =&gt;\n    value\n      .replace(/\\\\\\[/g, \"$$\")\n      .replace(/\\\\\\]/g, \"$$\")\n      .replace(/\\\\\\(/g, \"$\")\n      .replace(/\\\\\\)/g, \"$\");\n\n  const transformNode = (node, inCode = false) =&gt; {\n    if (!node || typeof node !== \"object\") return;\n    const nextInCode = inCode || node.type === \"code\" || node.type === \"inlineCode\";\n    if (node.type === \"text\" &amp;&amp; typeof node.value === \"string\" &amp;&amp; !nextInCode) {\n      node.value = normalizeDelimiters(node.value);\n      return;\n    }\n    if (Array.isArray(node.children)) {\n      node.children.forEach((child) =&gt; transformNode(child, nextInCode));\n      return;\n    }\n    Object.values(node).forEach((value) =&gt; {\n      if (value &amp;&amp; typeof value === \"object\") transformNode(value, nextInCode);\n    });\n  };\n\n  return (tree) =&gt; {\n    transformNode(tree);\n  };\n};\n\nconst createRootNode = () =&gt; ({\n  id: \"root\",\n  parentId: null,\n  title: \"Root\",\n  messages: [\n\n  ],\n});\n\nconst STORAGE_KEY = \"chat-trees:v1\";\n\nconst createTree = (title) =&gt; {\n  const now = Date.now();\n  return {\n    id: crypto.randomUUID(),\n    title,\n    nodesById: { root: createRootNode() },\n    activeNodeId: \"root\",\n    createdAt: now,\n    updatedAt: now,\n  };\n};\n\nconst loadTreesFromStorage = () =&gt; {\n  if (typeof window === \"undefined\") return null;\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    if (parsed?.version !== 1) return null;\n    if (!parsed.treesById || typeof parsed.treesById !== \"object\") return null;\n    const treeIds = Object.keys(parsed.treesById);\n    if (!treeIds.length) return null;\n    const activeTreeId = parsed.activeTreeId &amp;&amp; parsed.treesById[parsed.activeTreeId]\n      ? parsed.activeTreeId\n      : treeIds[0];\n    return { treesById: parsed.treesById, activeTreeId };\n  } catch {\n    return null;\n  }\n};\n\nconst createInitialTreeState = () =&gt; {\n  const loaded = loadTreesFromStorage();\n  if (loaded) return loaded;\n  const tree = createTree(\"New Tree\");\n  return { treesById: { [tree.id]: tree }, activeTreeId: tree.id };\n};\n\nconst getSvgViewport = (containerRect, viewBoxWidth, viewBoxHeight) =&gt; {\n  // Matches preserveAspectRatio=\"xMidYMin meet\"\n  const scale = Math.min(\n    containerRect.width / viewBoxWidth,\n    containerRect.height / viewBoxHeight,\n  );\n  const offsetX = (containerRect.width - viewBoxWidth * scale) / 2;\n  const offsetY = 0;\n  return { scale, offsetX, offsetY };\n};\n\nconst buildChildrenMap = (nodesById) =&gt; {\n  const map = {};\n  Object.values(nodesById).forEach((node) =&gt; {\n    const parent = node.parentId ?? \"root-parent\";\n    if (!map[parent]) {\n      map[parent] = [];\n    }\n    map[parent].push(node.id);\n  });\n  return map;\n};\n\nconst truncateForContext = (text, maxChars) =&gt; {\n  if (typeof text !== \"string\") return \"\";\n  const cleaned = text.replace(/\\s+/g, \" \").trim();\n  if (cleaned.length &lt;= maxChars) return cleaned;\n  return &#96;${cleaned.slice(0, Math.max(0, maxChars - 1))}…&#96;;\n};\n\nconst getNodePathToRoot = (nodeId, nodesById) =&gt; {\n  const path = [];\n  const visited = new Set();\n  let currentId = nodeId;\n  while (currentId &amp;&amp; nodesById[currentId] &amp;&amp; !visited.has(currentId)) {\n    visited.add(currentId);\n    path.push(currentId);\n    currentId = nodesById[currentId].parentId;\n  }\n  return path.reverse();\n};\n\nconst buildHiddenContextForNode = (nodeId, nodesById) =&gt; {\n  const node = nodesById[nodeId];\n  if (!node) return \"\";\n\n  const path = getNodePathToRoot(nodeId, nodesById);\n  const breadcrumb = path\n    .map((id, index) =&gt; {\n      const nodeTitle = nodesById[id]?.title;\n      if (index === path.length - 1 &amp;&amp; id !== \"root\") {\n        return \".\";\n      }\n      return nodeTitle || (id === \"root\" ? \"Root\" : null);\n    })\n    .filter(Boolean)\n    .join(\" &gt; \");\n\n  const lines = [\n    \"Hidden context for the assistant (do not repeat verbatim unless asked):\",\n    breadcrumb ? &#96;Branch path: ${breadcrumb}&#96; : \"\",\n  ].filter(Boolean);\n\n  const excerpt = node?.branchContext?.excerpt;\n  if (excerpt) {\n    lines.push(&#96;Branch highlight excerpt:\\n\"\"\"${truncateForContext(excerpt, 1200)}\"\"\"&#96;);\n  }\n\n  const ancestorIds = path.slice(0, -1);\n  if (ancestorIds.length) {\n    lines.push(\"Ancestor snippets (most recent turns):\");\n    ancestorIds.forEach((id) =&gt; {\n      const ancestor = nodesById[id];\n      if (!ancestor) return;\n      const tail = (ancestor.messages || []).slice(-4);\n      if (!tail.length) return;\n      const snippet = tail\n        .map((m) =&gt; &#96;${m.role}: ${truncateForContext(m.content ?? \"\", 220)}&#96;)\n        .join(\"\\n\");\n      lines.push(&#96;- ${ancestor.title}:\\n${snippet}&#96;);\n    });\n  }\n\n  return lines.join(\"\\n\\n\").trim();\n};\n\nconst useClickOutside = (ref, handler) =&gt; {\n  useEffect(() =&gt; {\n    const listener = (event) =&gt; {\n      if (!ref.current || ref.current.contains(event.target)) {\n        return;\n      }\n      handler(event);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    return () =&gt; document.removeEventListener(\"mousedown\", listener);\n  }, [ref, handler]);\n};\n\nconst App = () =&gt; {\n  const initialTreeState = useMemo(() =&gt; createInitialTreeState(), []);\n  const [treesById, setTreesById] = useState(initialTreeState.treesById);\n  const [activeTreeId, setActiveTreeId] = useState(initialTreeState.activeTreeId);\n  const [hoveredBranchNodeId, setHoveredBranchNodeId] = useState(null);\n  const [pendingTeleport, setPendingTeleport] = useState(null);\n  const [flashBranchNodeId, setFlashBranchNodeId] = useState(null);\n  const [draft, setDraft] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [treeView, setTreeView] = useState(\"graph\");\n  const [sidebarWidth, setSidebarWidth] = useState(320);\n  const [graphScale, setGraphScale] = useState(1.4);\n  const [graphTranslate, setGraphTranslate] = useState({ x: 0, y: 0 });\n  const [graphHasInteracted, setGraphHasInteracted] = useState(false);\n  const [isTreeListCollapsed, setIsTreeListCollapsed] = useState(false);\n  const [isContextModalOpen, setIsContextModalOpen] = useState(false);\n  const [selectionPopover, setSelectionPopover] = useState({\n    visible: false,\n    text: \"\",\n    rect: null,\n    draft: \"\",\n    placement: \"above\",\n    messageIndex: null,\n    nodeId: null,\n    treeId: null,\n  });\n  const [treeMenu, setTreeMenu] = useState({\n    visible: false,\n    treeId: null,\n    rect: null,\n    mode: \"menu\",\n    draft: \"\",\n  });\n  const [tempHighlight, setTempHighlight] = useState(null);\n\n  const chatAreaRef = useRef(null);\n  const inputRef = useRef(null);\n  const popoverRef = useRef(null);\n  const treeMenuRef = useRef(null);\n  const graphContainerRef = useRef(null);\n  const sidebarRef = useRef(null);\n  const panStateRef = useRef({\n    active: false,\n    startX: 0,\n    startY: 0,\n    tx: 0,\n    ty: 0,\n  });\n  const resizeStateRef = useRef({\n    active: false,\n    startX: 0,\n    startWidth: 0,\n  });\n\n  const activeTree = treesById[activeTreeId];\n  const nodesById = activeTree?.nodesById || {};\n  const activeNodeId = activeTree?.activeNodeId || \"root\";\n  const activeNode = nodesById[activeNodeId];\n  const isEmptyThread = (activeNode?.messages?.length ?? 0) === 0;\n  const shouldShowContext = activeNodeId !== \"root\";\n  const parentNodeId = activeNode?.parentId || null;\n  const parentNode = parentNodeId ? nodesById[parentNodeId] : null;\n  const assistantModelLabel = MODEL.replace(/^gpt/i, \"GPT\");\n  const assistantLabel = &#96;Assistant (${assistantModelLabel})&#96;;\n  const childrenMap = useMemo(() =&gt; buildChildrenMap(nodesById), [nodesById]);\n  const treeList = useMemo(\n    () =&gt; Object.values(treesById).sort((a, b) =&gt; a.createdAt - b.createdAt),\n    [treesById],\n  );\n  const visibleTreeList = useMemo(() =&gt; {\n    if (!isTreeListCollapsed) return treeList;\n    return treeList.filter((tree) =&gt; tree.id === activeTreeId);\n  }, [activeTreeId, isTreeListCollapsed, treeList]);\n  const markdownComponents = useMemo(\n    () =&gt; ({\n      a({ href, children, ...props }) {\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"temp-highlight:\")) {\n          const parts = href.split(\":\");\n          const tempId = parts[1];\n          return (\n            &lt;span\n              {...props}\n              className=\"branch-highlight is-temp\"\n              data-temp-id={tempId}\n              aria-hidden=\"true\"\n              onMouseDown={(event) =&gt; event.preventDefault()}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        if (typeof href === \"string\" &amp;&amp; href.startsWith(\"branch-highlight:\")) {\n          const parts = href.split(\":\");\n          const highlightId = parts[1];\n          const branchNodeId = parts[2];\n          const disableHoverEffects = selectionPopover.visible;\n          const isHovered = !disableHoverEffects &amp;&amp; hoveredBranchNodeId === branchNodeId;\n          const isTeleportFlash = flashBranchNodeId === branchNodeId;\n          return (\n            &lt;span\n              {...props}\n              className={&#96;branch-highlight ${disableHoverEffects ? \"no-hover\" : \"\"} ${isHovered ? \"is-hovered\" : \"\"\n                } ${isTeleportFlash ? \"teleport-flash\" : \"\"\n                }&#96;}\n              data-highlight-id={highlightId}\n              data-branch-node-id={branchNodeId}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Branch highlight\"\n              onMouseEnter={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onMouseLeave={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onFocus={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(branchNodeId);\n              }}\n              onBlur={() =&gt; {\n                if (disableHoverEffects) return;\n                setHoveredBranchNodeId(null);\n              }}\n              onMouseDown={(event) =&gt; {\n                // Avoid creating a new selection while clicking the highlight\n                event.preventDefault();\n              }}\n              onClick={(event) =&gt; {\n                event.preventDefault();\n                event.stopPropagation();\n                setActiveNodeId(branchNodeId);\n              }}\n              onKeyDown={(event) =&gt; {\n                if (event.key !== \"Enter\" &amp;&amp; event.key !== \" \") return;\n                event.preventDefault();\n                setActiveNodeId(branchNodeId);\n              }}\n            &gt;\n              {children}\n            &lt;/span&gt;\n          );\n        }\n        return (\n          &lt;a href={href} {...props}&gt;\n            {children}\n          &lt;/a&gt;\n        );\n      },\n      code({ inline, className, children, ...props }) {\n        if (inline) {\n          return (\n            &lt;code className={&#96;inline-code ${className || \"\"}&#96;} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          );\n        }\n        return (\n          &lt;pre className=\"code-block\"&gt;\n            &lt;code className={className} {...props}&gt;\n              {children}\n            &lt;/code&gt;\n          &lt;/pre&gt;\n        );\n      },\n    }),\n    [flashBranchNodeId, hoveredBranchNodeId, selectionPopover.visible],\n  );\n  const graphLayout = useMemo(() =&gt; {\n    const positions = {};\n    const edges = [];\n    let xCursor = 80;\n    let maxDepth = 0;\n\n    const walk = (nodeId, depth) =&gt; {\n      maxDepth = Math.max(maxDepth, depth);\n      const children = childrenMap[nodeId] || [];\n      if (children.length === 0) {\n        positions[nodeId] = { x: xCursor, y: depth * 160 + 70 };\n        xCursor += 220;\n        return;\n      }\n      children.forEach((childId) =&gt; {\n        edges.push({ from: nodeId, to: childId });\n        walk(childId, depth + 1);\n      });\n      const childXs = children.map((childId) =&gt; positions[childId].x);\n      const mid = (Math.min(...childXs) + Math.max(...childXs)) / 2;\n      positions[nodeId] = { x: mid, y: depth * 160 + 70 };\n    };\n\n    walk(\"root\", 0);\n\n    return {\n      positions,\n      edges,\n      width: Math.max(xCursor + 120, 240),\n      height: (maxDepth + 1) * 160 + 120,\n    };\n  }, [childrenMap]);\n\n  const updateTree = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const next = typeof updater === \"function\" ? updater(tree) : { ...tree, ...updater };\n      if (next === tree) return prev;\n      return { ...prev, [treeId]: next };\n    });\n  };\n\n  const updateTreeNodes = (treeId, updater) =&gt; {\n    setTreesById((prev) =&gt; {\n      const tree = prev[treeId];\n      if (!tree) return prev;\n      const nextNodes = typeof updater === \"function\" ? updater(tree.nodesById) : updater;\n      if (nextNodes === tree.nodesById) return prev;\n      return {\n        ...prev,\n        [treeId]: {\n          ...tree,\n          nodesById: nextNodes,\n          updatedAt: Date.now(),\n        },\n      };\n    });\n  };\n\n  const updateNodeMessages = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      return {\n        ...prevNodes,\n        [nodeId]: {\n          ...node,\n          messages: updater(node.messages),\n        },\n      };\n    });\n  };\n\n  const updateNode = (treeId, nodeId, updater) =&gt; {\n    updateTreeNodes(treeId, (prevNodes) =&gt; {\n      const node = prevNodes[nodeId];\n      if (!node) return prevNodes;\n      const next = typeof updater === \"function\" ? updater(node) : { ...node, ...updater };\n      if (next === node) return prevNodes;\n      return { ...prevNodes, [nodeId]: next };\n    });\n  };\n\n  const setActiveNodeId = (nodeId) =&gt; {\n    updateTree(activeTreeId, (tree) =&gt; ({ ...tree, activeNodeId: nodeId }));\n  };\n\n  const teleportToParentHighlight = () =&gt; {\n    if (!parentNodeId) return;\n    setPendingTeleport({ parentNodeId, childNodeId: activeNodeId });\n    setActiveNodeId(parentNodeId);\n  };\n\n  const createNewTree = () =&gt; {\n    const tree = createTree(\"New Tree\");\n    setTreesById((prev) =&gt; ({ ...prev, [tree.id]: tree }));\n    setActiveTreeId(tree.id);\n    setTreeView(\"graph\");\n  };\n\n  const closeTreeMenu = () =&gt; {\n    setTreeMenu({\n      visible: false,\n      treeId: null,\n      rect: null,\n      mode: \"menu\",\n      draft: \"\",\n    });\n  };\n\n  const openTreeMenu = (treeId, event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const buttonRect = event.currentTarget.getBoundingClientRect();\n    const left = Math.min(buttonRect.left, window.innerWidth - 260);\n    setTreeMenu({\n      visible: true,\n      treeId,\n      rect: { top: buttonRect.bottom + 8, left },\n      mode: \"menu\",\n      draft: treesById[treeId]?.title ?? \"\",\n    });\n  };\n\n  const deleteTree = (treeId) =&gt; {\n    const tree = treesById[treeId];\n    if (!tree) return;\n    const ok = window.confirm(&#96;Delete \"${tree.title}\"? This cannot be undone.&#96;);\n    if (!ok) return;\n\n    const remaining = treeList.filter((t) =&gt; t.id !== treeId);\n\n    // Important: never leave &#96;activeTreeId&#96; as null even briefly; the render path assumes\n    // an active tree exists and will crash (black screen) otherwise.\n    if (!remaining.length) {\n      const fresh = createTree(\"New Tree\");\n      setTreesById({ [fresh.id]: fresh });\n      setActiveTreeId(fresh.id);\n      setTreeView(\"graph\");\n    } else {\n      setTreesById((prev) =&gt; {\n        const next = { ...prev };\n        delete next[treeId];\n        return next;\n      });\n      if (activeTreeId === treeId) {\n        setActiveTreeId(remaining[0].id);\n      }\n    }\n\n    closeTreeMenu();\n  };\n\n  const requestTreeTitle = async (userMessage, assistantMessage = \"\") =&gt; {\n    const prompt = [\n      \"Generate a concise 2-5 word title for this conversation.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User: ${truncateForContext(userMessage, 300)}&#96;,\n      assistantMessage ? &#96;Assistant: ${truncateForContext(assistantMessage, 360)}&#96; : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  useLayoutEffect(() =&gt; {\n    if (treeView !== \"graph\" || graphHasInteracted) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const rootPos = graphLayout.positions.root;\n    if (!rootPos) return;\n    const nodeRadiusUser = 34;\n    const paddingPx = 12;\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const targetXUser = (rect.width / 2 - offsetX) / s;\n    const targetYUser = (paddingPx - offsetY) / s + nodeRadiusUser * graphScale;\n    setGraphTranslate({\n      x: targetXUser - rootPos.x * graphScale,\n      y: targetYUser - rootPos.y * graphScale,\n    });\n  }, [treeView, graphLayout, graphScale, graphHasInteracted, sidebarWidth]);\n\n  useClickOutside(popoverRef, () =&gt; {\n    if (selectionPopover.visible) {\n      setSelectionPopover({\n        visible: false,\n        text: \"\",\n        rect: null,\n        draft: \"\",\n        placement: \"above\",\n        messageIndex: null,\n        nodeId: null,\n        treeId: null,\n      });\n    }\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n      setTempHighlight(null);\n    }\n  });\n\n  useClickOutside(treeMenuRef, () =&gt; {\n    if (treeMenu.visible) closeTreeMenu();\n  });\n\n  useEffect(() =&gt; {\n    const onKeyDown = (event) =&gt; {\n      if (event.key === \"Shift\") {\n        const payload = getSelectionPayload();\n        if (payload) {\n          setSelectionPopover({\n            visible: true,\n            text: payload.text,\n            rect: payload.rect,\n            draft: \"\",\n            placement: payload.placement,\n            messageIndex: payload.messageIndex,\n            nodeId: activeNodeId,\n            treeId: activeTreeId,\n          });\n        }\n        return;\n      }\n      if (event.key !== \"Escape\") return;\n      window.getSelection()?.removeAllRanges?.();\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      if (tempHighlight) {\n        updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n          messages.map((m, i) =&gt; {\n            if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n            return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n          }),\n        );\n        setTempHighlight(null);\n      }\n    };\n\n    window.addEventListener(\"keydown\", onKeyDown);\n    return () =&gt; window.removeEventListener(\"keydown\", onKeyDown);\n  }, [selectionPopover.visible, activeNodeId, activeTreeId, tempHighlight]);\n\n  useEffect(() =&gt; {\n    if (activeTreeId) return;\n    if (!treeList.length) return;\n    setActiveTreeId(treeList[0].id);\n  }, [activeTreeId, treeList]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: removeTempHighlightById(m.content, tempHighlight.tempId),\n          };\n        }),\n      );\n    }\n    setTempHighlight(null);\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    setHoveredBranchNodeId(null);\n    setDraft(\"\");\n    setError(\"\");\n  }, [activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (typeof window === \"undefined\") return;\n    const payload = {\n      version: 1,\n      treesById,\n      activeTreeId,\n    };\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  }, [treesById, activeTreeId]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    if (!selectionPopover.text?.trim()) return;\n    if (selectionPopover.messageIndex == null) return;\n    if (!selectionPopover.nodeId) return;\n    if (!selectionPopover.treeId) return;\n\n    if (tempHighlight) {\n      updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return { ...m, content: removeTempHighlightById(m.content, tempHighlight.tempId) };\n        }),\n      );\n    }\n\n    const tempId = crypto.randomUUID();\n    const nodeId = selectionPopover.nodeId;\n    const msgIdx = selectionPopover.messageIndex;\n    updateNodeMessages(selectionPopover.treeId, nodeId, (messages) =&gt;\n      messages.map((m, i) =&gt; {\n        if (i !== msgIdx || typeof m?.content !== \"string\") return m;\n        return {\n          ...m,\n          content: wrapFirstMatchWithTempHighlight(m.content, selectionPopover.text, tempId),\n        };\n      }),\n    );\n    setTempHighlight({\n      nodeId,\n      messageIndex: msgIdx,\n      tempId,\n      treeId: selectionPopover.treeId,\n    });\n    window.getSelection()?.removeAllRanges?.();\n  }, [\n    selectionPopover.visible,\n    selectionPopover.text,\n    selectionPopover.messageIndex,\n    selectionPopover.nodeId,\n    selectionPopover.treeId,\n  ]);\n\n  useEffect(() =&gt; {\n    if (!shouldShowContext &amp;&amp; isContextModalOpen) {\n      setIsContextModalOpen(false);\n    }\n  }, [shouldShowContext, isContextModalOpen]);\n\n  useEffect(() =&gt; {\n    if (!activeTreeId) return;\n    updateNode(activeTreeId, activeNodeId, (node) =&gt; {\n      if (!node?.hasUnread) return node;\n      return {\n        ...node,\n        hasUnread: false,\n        requestStatus: node.requestStatus === \"ready\" ? \"idle\" : node.requestStatus,\n      };\n    });\n  }, [activeTreeId, activeNodeId]);\n\n  const addNode = (treeId, parentId, title, messages, extra = {}, options = {}) =&gt; {\n    const id = crypto.randomUUID();\n    const shouldActivate = options.activate !== false;\n    updateTreeNodes(treeId, (prev) =&gt; ({\n      ...prev,\n      [id]: {\n        id,\n        parentId,\n        title,\n        messages,\n        ...extra,\n      },\n    }));\n    if (shouldActivate) {\n      updateTree(treeId, (tree) =&gt; ({ ...tree, activeNodeId: id }));\n    }\n    return id;\n  };\n\n  const sendToOpenAI = async (messages, hiddenContext = \"\") =&gt; {\n    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"Missing VITE_OPENAI_API_KEY in .env\");\n    }\n    const systemMessages = [{ role: \"system\", content: SYSTEM_PROMPT }];\n    if (hiddenContext &amp;&amp; hiddenContext.trim()) {\n      systemMessages.push({ role: \"system\", content: hiddenContext.trim() });\n    }\n    const response = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        Authorization: &#96;Bearer ${apiKey}&#96;,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model: MODEL,\n        messages: [...systemMessages, ...messages],\n        temperature: 0.2,\n      }),\n    });\n    if (!response.ok) {\n      const details = await response.text();\n      throw new Error(&#96;OpenAI error ${response.status}: ${details}&#96;);\n    }\n    const data = await response.json();\n    return data.choices?.[0]?.message?.content?.trim() ?? \"\";\n  };\n\n  const requestBranchTitle = async (userMessage, branchExcerpt) =&gt; {\n    const prompt = [\n      \"Generate a concise 2-4 word title for this branch request.\",\n      \"Return only the title, no quotes or punctuation.\",\n      \"\",\n      &#96;User request: ${truncateForContext(userMessage, 240)}&#96;,\n      branchExcerpt\n        ? &#96;Selected excerpt: ${truncateForContext(branchExcerpt, 240)}&#96;\n        : \"\",\n    ]\n      .filter(Boolean)\n      .join(\"\\n\");\n    return sendToOpenAI([{ role: \"user\", content: prompt }]);\n  };\n\n  const handleSend = async (content) =&gt; {\n    if (!content.trim() || isLoading) return;\n    if (!activeTreeId) return;\n    setError(\"\");\n    const trimmed = content.trim();\n    const nodeSnapshot = nodesById[activeNodeId];\n    const treeIdSnapshot = activeTreeId;\n    const treeSnapshot = treesById[treeIdSnapshot];\n    const isFirstRootTurn =\n      activeNodeId === \"root\" &amp;&amp; (nodeSnapshot?.messages?.length ?? 0) === 0;\n    const hiddenContext = shouldShowContext\n      ? buildHiddenContextForNode(activeNodeId, nodesById)\n      : \"\";\n    updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n      ...messages,\n      { role: \"user\", content: trimmed },\n    ]);\n\n    const shouldAutoTitle =\n      isFirstRootTurn &amp;&amp;\n      treeSnapshot &amp;&amp;\n      (treeSnapshot.title === \"New Tree\" ||\n        treeSnapshot.title === \"New tree\" ||\n        /^Tree \\d+$/.test(treeSnapshot.title));\n\n    setDraft(\"\");\n    setIsLoading(true);\n    try {\n      const replyPromise = sendToOpenAI(\n        [...(nodeSnapshot?.messages ?? []), { role: \"user\", content: trimmed }],\n        hiddenContext,\n      );\n\n      // Fire this in parallel with the main reply request so it can return ASAP.\n      if (shouldAutoTitle) {\n        requestTreeTitle(trimmed, \"\")\n          .then((title) =&gt; {\n            const nextTitle = normalizeGeneratedTitle(title, \"New Tree\");\n            updateTree(treeIdSnapshot, (tree) =&gt; {\n              if (!tree) return tree;\n              // Don't override if the user renamed it in the meantime.\n              if (\n                tree.title !== \"New Tree\" &amp;&amp;\n                tree.title !== \"New tree\" &amp;&amp;\n                !/^Tree \\d+$/.test(tree.title)\n              )\n                return tree;\n              return { ...tree, title: nextTitle };\n            });\n          })\n          .catch(() =&gt; { });\n      }\n\n      const reply = await replyPromise;\n      updateNodeMessages(activeTreeId, activeNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleComposerKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleSend(draft);\n  };\n\n  const handleBranchKeyDown = (event) =&gt; {\n    if (event.key !== \"Enter\") return;\n    if (event.shiftKey) return;\n    event.preventDefault();\n    handleBranchSend();\n  };\n\n  const handleBranchSend = async () =&gt; {\n    if (!selectionPopover.text.trim() || !selectionPopover.draft.trim()) {\n      return;\n    }\n    setError(\"\");\n    const treeId = selectionPopover.treeId || activeTreeId;\n    if (!treeId) return;\n    const sourceNodeId = selectionPopover.nodeId || activeNodeId;\n    const userMessage = selectionPopover.draft.trim();\n    const fallbackTitle = \"...\";\n    const branchExcerpt = selectionPopover.text.trim();\n    const newNodeId = addNode(\n      treeId,\n      sourceNodeId,\n      fallbackTitle,\n      [{ role: \"user\", content: userMessage }],\n      {\n        branchContext: {\n          excerpt: branchExcerpt,\n          sourceNodeId,\n          createdAt: Date.now(),\n        },\n        requestStatus: \"pending\",\n        hasUnread: false,\n      },\n      { activate: false },\n    );\n    const highlightId = crypto.randomUUID();\n    if (tempHighlight &amp;&amp; tempHighlight.nodeId === sourceNodeId &amp;&amp; tempHighlight.treeId === treeId) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: convertTempHighlightToBranchHighlight(\n              m.content,\n              tempHighlight.tempId,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n      setTempHighlight(null);\n    } else if (selectionPopover.messageIndex != null) {\n      updateNodeMessages(treeId, sourceNodeId, (messages) =&gt;\n        messages.map((m, i) =&gt; {\n          if (i !== selectionPopover.messageIndex || typeof m?.content !== \"string\") return m;\n          return {\n            ...m,\n            content: wrapFirstMatchWithBranchHighlight(\n              m.content,\n              selectionPopover.text,\n              highlightId,\n              newNodeId,\n            ),\n          };\n        }),\n      );\n    }\n    setSelectionPopover({\n      visible: false,\n      text: \"\",\n      rect: null,\n      draft: \"\",\n      placement: \"above\",\n      messageIndex: null,\n      nodeId: null,\n      treeId: null,\n    });\n    window.getSelection()?.removeAllRanges?.();\n    try {\n      // Build context against a snapshot that includes the new node (setState is async).\n      const treeSnapshot = treesById[treeId];\n      const baseNodes = treeSnapshot?.nodesById || nodesById;\n      const nodesWithNew = {\n        ...baseNodes,\n        [newNodeId]: {\n          id: newNodeId,\n          parentId: sourceNodeId,\n          title: fallbackTitle,\n          messages: [{ role: \"user\", content: userMessage }],\n          branchContext: {\n            excerpt: branchExcerpt,\n            sourceNodeId,\n            createdAt: Date.now(),\n          },\n          requestStatus: \"pending\",\n          hasUnread: false,\n        },\n      };\n      const hiddenContext = buildHiddenContextForNode(newNodeId, nodesWithNew);\n      const replyPromise = sendToOpenAI([{ role: \"user\", content: userMessage }], hiddenContext);\n      const titlePromise = requestBranchTitle(userMessage, branchExcerpt);\n      titlePromise\n        .then((title) =&gt; {\n          const nextTitle = normalizeGeneratedTitle(title, fallbackTitle);\n          updateNode(treeId, newNodeId, (node) =&gt; ({ ...node, title: nextTitle }));\n        })\n        .catch(() =&gt; { });\n\n      const reply = await replyPromise;\n      updateNodeMessages(treeId, newNodeId, (messages) =&gt; [\n        ...messages,\n        { role: \"assistant\", content: reply || \"No response returned.\" },\n      ]);\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"ready\",\n        hasUnread: true,\n      }));\n    } catch (err) {\n      setError(err.message || \"Failed to reach OpenAI.\");\n      updateNode(treeId, newNodeId, (node) =&gt; ({\n        ...node,\n        requestStatus: \"idle\",\n      }));\n    }\n  };\n\n  const getSelectionPayload = () =&gt; {\n    const selection = window.getSelection();\n    if (!selection || selection.isCollapsed) return null;\n    const anchorNode = selection.anchorNode;\n    const focusNode = selection.focusNode;\n    if (\n      !chatAreaRef.current ||\n      !chatAreaRef.current.contains(anchorNode) ||\n      !chatAreaRef.current.contains(focusNode)\n    ) {\n      return null;\n    }\n    const text = selection.toString().trim();\n    if (!text) return null;\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n    const placement = rect.top &gt; 220 ? \"above\" : \"below\";\n    const top = placement === \"above\" ? rect.top - 8 : rect.bottom + 8;\n    const left = Math.min(rect.left, window.innerWidth - 320);\n\n    const startContainer =\n      range.startContainer?.nodeType === Node.TEXT_NODE\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const messageEl = startContainer?.closest?.(\".message\");\n    const messageIndexRaw = messageEl?.dataset?.messageIndex;\n    const messageIndex =\n      messageIndexRaw != null &amp;&amp; messageIndexRaw !== \"\"\n        ? Number(messageIndexRaw)\n        : null;\n\n    return {\n      text,\n      rect: { top, left },\n      placement,\n      messageIndex: Number.isFinite(messageIndex) ? messageIndex : null,\n    };\n  };\n\n  const handleSelection = (event) =&gt; {\n    const payload = getSelectionPayload();\n    if (!payload) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    if (!event?.shiftKey) {\n      if (selectionPopover.visible) {\n        setSelectionPopover({\n          visible: false,\n          text: \"\",\n          rect: null,\n          draft: \"\",\n          placement: \"above\",\n          messageIndex: null,\n          nodeId: null,\n          treeId: null,\n        });\n      }\n      return;\n    }\n\n    setSelectionPopover({\n      visible: true,\n      text: payload.text,\n      rect: payload.rect,\n      draft: \"\",\n      placement: payload.placement,\n      messageIndex: payload.messageIndex,\n      nodeId: activeNodeId,\n      treeId: activeTreeId,\n    });\n  };\n\n  const renderTree = (nodeId, depth = 0) =&gt; {\n    const node = nodesById[nodeId];\n    const children = childrenMap[nodeId] || [];\n    const isPending = node?.requestStatus === \"pending\";\n    const isReady = node?.hasUnread;\n    return (\n      &lt;div key={nodeId}&gt;\n        &lt;button\n          className={&#96;tree-item ${activeNodeId === nodeId ? \"active\" : \"\"} ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"\n            }&#96;}\n          style={{ paddingLeft: &#96;${12 + depth * 16}px&#96; }}\n          onClick={() =&gt; setActiveNodeId(nodeId)}\n          onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n          onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n          type=\"button\"\n        &gt;\n          &lt;span className=\"tree-item-label\"&gt;\n            &lt;span className=\"tree-title\"&gt;{node.title}&lt;/span&gt;\n            {isPending &amp;&amp; &lt;span className=\"tree-badge pending\"&gt;Pending&lt;/span&gt;}\n            {!isPending &amp;&amp; isReady &amp;&amp; &lt;span className=\"tree-badge ready\"&gt;Ready&lt;/span&gt;}\n          &lt;/span&gt;\n        &lt;/button&gt;\n        {children.map((childId) =&gt; renderTree(childId, depth + 1))}\n      &lt;/div&gt;\n    );\n  };\n\n  const resizeInput = (element) =&gt; {\n    if (!element) return;\n    element.style.height = \"auto\";\n    element.style.height = &#96;${element.scrollHeight}px&#96;;\n  };\n\n  useEffect(() =&gt; {\n    resizeInput(inputRef.current);\n  }, [draft]);\n\n  useEffect(() =&gt; {\n    if (!selectionPopover.visible) return;\n    setHoveredBranchNodeId(null);\n  }, [selectionPopover.visible]);\n\n  useEffect(() =&gt; {\n    if (!hoveredBranchNodeId) return;\n    const clearHoverIfOutside = (event) =&gt; {\n      const target = event?.target;\n      if (!(target instanceof Element)) {\n        setHoveredBranchNodeId(null);\n        return;\n      }\n      const hoverable = target.closest(\".branch-highlight, .tree-item, .graph-node\");\n      if (!hoverable) {\n        setHoveredBranchNodeId(null);\n      }\n    };\n    const clearHover = () =&gt; setHoveredBranchNodeId(null);\n\n    window.addEventListener(\"pointermove\", clearHoverIfOutside);\n    window.addEventListener(\"scroll\", clearHover, true);\n    window.addEventListener(\"blur\", clearHover);\n    return () =&gt; {\n      window.removeEventListener(\"pointermove\", clearHoverIfOutside);\n      window.removeEventListener(\"scroll\", clearHover, true);\n      window.removeEventListener(\"blur\", clearHover);\n    };\n  }, [hoveredBranchNodeId]);\n\n  useEffect(() =&gt; {\n    const handleMove = (event) =&gt; {\n      if (panStateRef.current.active) {\n        const container = graphContainerRef.current;\n        if (!container) return;\n        const dx = event.clientX - panStateRef.current.startX;\n        const dy = event.clientY - panStateRef.current.startY;\n        const s = panStateRef.current.viewportScale || 1;\n        setGraphTranslate({\n          x: panStateRef.current.tx + dx / s,\n          y: panStateRef.current.ty + dy / s,\n        });\n        return;\n      }\n      if (resizeStateRef.current.active) {\n        const dx = event.clientX - resizeStateRef.current.startX;\n        const nextWidth = Math.min(\n          Math.max(resizeStateRef.current.startWidth + dx, 240),\n          520,\n        );\n        setSidebarWidth(nextWidth);\n      }\n    };\n\n    const handleUp = () =&gt; {\n      panStateRef.current.active = false;\n      resizeStateRef.current.active = false;\n      document.body.classList.remove(\"is-resizing\");\n    };\n\n    window.addEventListener(\"mousemove\", handleMove);\n    window.addEventListener(\"mouseup\", handleUp);\n    return () =&gt; {\n      window.removeEventListener(\"mousemove\", handleMove);\n      window.removeEventListener(\"mouseup\", handleUp);\n    };\n  }, [sidebarWidth]);\n\n  useLayoutEffect(() =&gt; {\n    if (!pendingTeleport) return;\n    if (activeNodeId !== pendingTeleport.parentNodeId) return;\n\n    const container = chatAreaRef.current;\n    if (!container) {\n      setPendingTeleport(null);\n      return;\n    }\n\n    // Wait a frame so the parent node messages/highlights are in the DOM.\n    const raf = window.requestAnimationFrame(() =&gt; {\n      const selector = &#96;[data-branch-node-id=\"${pendingTeleport.childNodeId}\"]&#96;;\n      const highlightEl = container.querySelector(selector);\n      if (highlightEl) {\n        highlightEl.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        setFlashBranchNodeId(pendingTeleport.childNodeId);\n        window.setTimeout(() =&gt; {\n          setFlashBranchNodeId(null);\n        }, 1200);\n      }\n      setPendingTeleport(null);\n    });\n\n    return () =&gt; window.cancelAnimationFrame(raf);\n  }, [activeNodeId, pendingTeleport]);\n\n  const handleGraphWheel = (event) =&gt; {\n    event.preventDefault();\n    event.stopPropagation();\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s, offsetX, offsetY } = getSvgViewport(\n      rect,\n      graphLayout.width,\n      graphLayout.height,\n    );\n    const delta = event.deltaY &gt; 0 ? 0.9 : 1.1;\n    const nextScale = Math.min(Math.max(graphScale * delta, 0.6), 3.2);\n    const pointerX = (event.clientX - rect.left - offsetX) / s;\n    const pointerY = (event.clientY - rect.top - offsetY) / s;\n    const graphX = (pointerX - graphTranslate.x) / graphScale;\n    const graphY = (pointerY - graphTranslate.y) / graphScale;\n    setGraphScale(nextScale);\n    setGraphTranslate({\n      x: pointerX - graphX * nextScale,\n      y: pointerY - graphY * nextScale,\n    });\n    setGraphHasInteracted(true);\n  };\n\n  useEffect(() =&gt; {\n    const sidebar = sidebarRef.current;\n    if (!sidebar) return;\n    const handleWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    sidebar.addEventListener(\"wheel\", handleWheel, { passive: false });\n    return () =&gt; sidebar.removeEventListener(\"wheel\", handleWheel);\n  }, []);\n\n  useEffect(() =&gt; {\n    const handleWindowWheel = (event) =&gt; {\n      if (!event.ctrlKey) return;\n      const sidebar = sidebarRef.current;\n      if (!sidebar) return;\n      if (!sidebar.contains(event.target)) return;\n      event.preventDefault();\n      event.stopPropagation();\n    };\n    window.addEventListener(\"wheel\", handleWindowWheel, {\n      passive: false,\n      capture: true,\n    });\n    return () =&gt; {\n      window.removeEventListener(\"wheel\", handleWindowWheel, {\n        capture: true,\n      });\n    };\n  }, []);\n\n  const handleGraphMouseDown = (event) =&gt; {\n    if (event.button !== 0) return;\n    const container = graphContainerRef.current;\n    if (!container) return;\n    const rect = container.getBoundingClientRect();\n    const { scale: s } = getSvgViewport(rect, graphLayout.width, graphLayout.height);\n    panStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startY: event.clientY,\n      tx: graphTranslate.x,\n      ty: graphTranslate.y,\n      viewportScale: s,\n    };\n    setGraphHasInteracted(true);\n  };\n\n  const handleResizerMouseDown = (event) =&gt; {\n    event.preventDefault();\n    resizeStateRef.current = {\n      active: true,\n      startX: event.clientX,\n      startWidth: sidebarWidth,\n    };\n    document.body.classList.add(\"is-resizing\");\n  };\n\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;aside\n        className=\"sidebar\"\n        style={{ width: &#96;${sidebarWidth}px&#96; }}\n        ref={sidebarRef}\n      &gt;\n        &lt;div className=\"sidebar-header\"&gt;\n          &lt;div className=\"sidebar-title-row\"&gt;\n            &lt;div&gt;\n              &lt;h1&gt;Chat Tree&lt;/h1&gt;\n              &lt;p &gt;\n                {treeList.length} {treeList.length === 1 ? \"tree\" : \"trees\"}\n              &lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div className=\"sidebar-actions\"&gt;\n              &lt;button\n                type=\"button\"\n                className=\"collapse-tree-button\"\n                onClick={() =&gt; setIsTreeListCollapsed((prev) =&gt; !prev)}\n                title={isTreeListCollapsed ? \"Show all trees\" : \"Show only active tree\"}\n              &gt;\n                {isTreeListCollapsed ? \"Show all\" : \"Only active\"}\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"new-tree-button\"\n                onClick={createNewTree}\n              &gt;\n                New tree\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div className=\"tree-list\"&gt;\n            {visibleTreeList.map((tree) =&gt; {\n              const nodeCount = Object.keys(tree.nodesById || {}).length;\n              const isActive = tree.id === activeTreeId;\n              return (\n                &lt;div\n                  key={tree.id}\n                  className={&#96;tree-switch-row ${isActive ? \"active\" : \"\"}&#96;}\n                &gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"tree-switch\"\n                    onClick={() =&gt; setActiveTreeId(tree.id)}\n                  &gt;\n                    &lt;span className=\"tree-switch-title\"&gt;{tree.title}&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;div className=\"tree-switch-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"tree-actions-button\"\n                      aria-label=\"Tree options\"\n                      title=\"Options\"\n                      onClick={(e) =&gt; openTreeMenu(tree.id, e)}\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"6\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"1.8\" /&gt;\n                        &lt;circle cx=\"18\" cy=\"12\" r=\"1.8\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                    &lt;span className=\"tree-switch-meta\"&gt;\n                      {nodeCount} {nodeCount === 1 ? \"node\" : \"nodes\"}\n                    &lt;/span&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n\n          &lt;div className=\"view-toggle\"&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"graph\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"graph\")}\n              aria-label=\"Graph view\"\n              title=\"Graph view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;circle cx=\"6\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"18\" cy=\"6\" r=\"2.5\" /&gt;\n                &lt;circle cx=\"12\" cy=\"18\" r=\"2.5\" /&gt;\n                &lt;path d=\"M8 6h8M7.5 7.5l3.5 8M16.5 7.5l-3.5 8\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className={treeView === \"list\" ? \"active\" : \"\"}\n              onClick={() =&gt; setTreeView(\"list\")}\n              aria-label=\"List view\"\n              title=\"List view\"\n            &gt;\n              &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                &lt;path d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n              &lt;/svg&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        {treeView === \"graph\" ? (\n          &lt;div\n            className=\"tree-graph\"\n            ref={graphContainerRef}\n            onWheel={handleGraphWheel}\n            onMouseDown={handleGraphMouseDown}\n          &gt;\n            &lt;svg\n              width=\"100%\"\n              height=\"100%\"\n              viewBox={&#96;0 0 ${graphLayout.width} ${graphLayout.height}&#96;}\n              preserveAspectRatio=\"xMidYMin meet\"\n            &gt;\n              &lt;g\n                transform={&#96;translate(${graphTranslate.x} ${graphTranslate.y}) scale(${graphScale})&#96;}\n              &gt;\n                {graphLayout.edges.map((edge) =&gt; {\n                  const from = graphLayout.positions[edge.from];\n                  const to = graphLayout.positions[edge.to];\n                  if (!from || !to) return null;\n                  return (\n                    &lt;line\n                      key={&#96;${edge.from}-${edge.to}&#96;}\n                      x1={from.x}\n                      y1={from.y}\n                      x2={to.x}\n                      y2={to.y}\n                      className=\"graph-edge\"\n                    /&gt;\n                  );\n                })}\n                {Object.entries(graphLayout.positions).map(([nodeId, pos]) =&gt; {\n                  const node = nodesById[nodeId];\n                  if (!node) return null;\n                  const words = (node.title || \"\").split(\" \").filter(Boolean);\n                  const isPending = node?.requestStatus === \"pending\";\n                  const isReady = node?.hasUnread;\n                  return (\n                    &lt;g\n                      key={nodeId}\n                      className={&#96;graph-node ${nodeId === activeNodeId ? \"active\" : \"\"\n                        } ${hoveredBranchNodeId === nodeId ? \"branch-hover\" : \"\"}&#96;}\n                      onClick={() =&gt; setActiveNodeId(nodeId)}\n                      onMouseEnter={() =&gt; setHoveredBranchNodeId(nodeId)}\n                      onMouseLeave={() =&gt; setHoveredBranchNodeId(null)}\n                    &gt;\n                      &lt;circle cx={pos.x} cy={pos.y} r=\"34\" /&gt;\n                      {isPending &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge pending\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      {!isPending &amp;&amp; isReady &amp;&amp; (\n                        &lt;circle\n                          className=\"graph-node-badge ready\"\n                          cx={pos.x + 22}\n                          cy={pos.y - 22}\n                          r=\"6\"\n                        /&gt;\n                      )}\n                      &lt;text x={pos.x} y={pos.y} textAnchor=\"middle\"&gt;\n                        {words.length &gt; 1 ? (\n                          &lt;&gt;\n                            &lt;tspan x={pos.x} dy=\"-6\"&gt;\n                              {words[0]}\n                            &lt;/tspan&gt;\n                            &lt;tspan x={pos.x} dy=\"14\"&gt;\n                              {words.slice(1).join(\" \")}\n                            &lt;/tspan&gt;\n                          &lt;/&gt;\n                        ) : (\n                          &lt;tspan x={pos.x} dy=\"4\"&gt;\n                            {words[0]}\n                          &lt;/tspan&gt;\n                        )}\n                      &lt;/text&gt;\n                    &lt;/g&gt;\n                  );\n                })}\n              &lt;/g&gt;\n            &lt;/svg&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"tree\"&gt;{renderTree(\"root\")}&lt;/div&gt;\n        )}\n      &lt;/aside&gt;\n      &lt;div className=\"sidebar-resizer\" onMouseDown={handleResizerMouseDown} /&gt;\n      &lt;main className=\"chat\"&gt;\n        &lt;div className=\"chat-frame\"&gt;\n          {isEmptyThread ? (\n            &lt;div className=\"chat-empty\"&gt;\n              &lt;h1 className=\"chat-empty-title\"&gt;Where should we begin?&lt;/h1&gt;\n              {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;div className=\"chat-input chat-input--empty\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={2}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;&gt;\n              &lt;header className=\"chat-header\"&gt;\n                &lt;div&gt;\n                  &lt;h2&gt;{activeNode?.title ?? \"Root\"}&lt;/h2&gt;\n                  &lt;div className=\"chat-subhead\"&gt;\n                    &lt;span className=\"chat-meta\"&gt;\n                      {activeNode.messages.length} messages\n                    &lt;/span&gt;\n                    {parentNodeId &amp;&amp; parentNode &amp;&amp; (\n                      &lt;button\n                        type=\"button\"\n                        className=\"teleport-button\"\n                        onClick={teleportToParentHighlight}\n                        title={&#96;Jump back to the highlight in \"${parentNode.title}\" that created this branch&#96;}\n                        aria-label=\"Jump to parent highlight\"\n                      &gt;\n                        &lt;span className=\"teleport-button-label\"&gt;\n                          Jump to parent highlight\n                        &lt;/span&gt;\n                        &lt;span className=\"teleport-button-parent\"&gt;\n                          {parentNode.title}\n                        &lt;/span&gt;\n                      &lt;/button&gt;\n                    )}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n                {shouldShowContext &amp;&amp; (\n                  &lt;div className=\"chat-header-actions\"&gt;\n                    &lt;button\n                      type=\"button\"\n                      className=\"context-button\"\n                      onClick={() =&gt; setIsContextModalOpen(true)}\n                      aria-label=\"View AI context\"\n                      title=\"View AI context\"\n                    &gt;\n                      &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                        &lt;circle cx=\"12\" cy=\"12\" r=\"9\" /&gt;\n                        &lt;path d=\"M12 10.5v6\" /&gt;\n                        &lt;path d=\"M12 7.2h.01\" /&gt;\n                      &lt;/svg&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/header&gt;\n              &lt;section\n                className=\"chat-area\"\n                ref={chatAreaRef}\n                onMouseUp={handleSelection}\n              &gt;\n                {activeNode.messages.map((message, index) =&gt; (\n                  &lt;div\n                    key={&#96;${message.role}-${index}&#96;}\n                    className={&#96;message ${message.role}&#96;}\n                    data-message-index={index}\n                  &gt;\n                    &lt;div className=\"message-role\"&gt;\n                      {message.role === \"user\" ? \"You\" : assistantLabel}\n                    &lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;ReactMarkdown\n                        remarkPlugins={[\n                          remarkBranchHighlights,\n                          remarkLatexDelimiters,\n                          remarkGfm,\n                          remarkMath,\n                          remarkBreaks,\n                        ]}\n                        rehypePlugins={[rehypeKatex]}\n                        urlTransform={(url) =&gt; url}\n                        components={markdownComponents}\n                      &gt;\n                        {message.content}\n                      &lt;/ReactMarkdown&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                ))}\n                {isLoading &amp;&amp; (\n                  &lt;div className=\"message assistant message--thinking\"&gt;\n                    &lt;div className=\"message-role\"&gt;{assistantLabel}&lt;/div&gt;\n                    &lt;div className=\"message-content\"&gt;\n                      &lt;span className=\"thinking\"&gt;Thinking...&lt;/span&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n                {error &amp;&amp; &lt;div className=\"error-banner\"&gt;{error}&lt;/div&gt;}\n              &lt;/section&gt;\n              &lt;footer className=\"chat-input\"&gt;\n                &lt;div className=\"composer\"&gt;\n                  &lt;textarea\n                    ref={inputRef}\n                    placeholder=\"Ask anything\"\n                    value={draft}\n                    onChange={(event) =&gt; {\n                      setDraft(event.target.value);\n                      resizeInput(event.target);\n                    }}\n                    onKeyDown={handleComposerKeyDown}\n                    rows={3}\n                  /&gt;\n                  &lt;button\n                    type=\"button\"\n                    className=\"send-button\"\n                    onClick={() =&gt; handleSend(draft)}\n                    disabled={isLoading || !draft.trim()}\n                    aria-label=\"Send message\"\n                    title=\"Send\"\n                  &gt;\n                    &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                      &lt;path d=\"M22 2L11 13\" /&gt;\n                      &lt;path d=\"M22 2l-7 20-4-9-9-4 20-7z\" /&gt;\n                    &lt;/svg&gt;\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/footer&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/main&gt;\n      {shouldShowContext &amp;&amp; isContextModalOpen &amp;&amp; (\n        &lt;div\n          className=\"modal-overlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"AI context\"\n          onClick={() =&gt; setIsContextModalOpen(false)}\n        &gt;\n          &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n            &lt;div className=\"modal-header\"&gt;\n              &lt;div className=\"modal-title\"&gt;AI context&lt;/div&gt;\n              &lt;button\n                type=\"button\"\n                className=\"modal-close\"\n                onClick={() =&gt; setIsContextModalOpen(false)}\n                aria-label=\"Close\"\n              &gt;\n                &lt;svg viewBox=\"0 0 24 24\" aria-hidden=\"true\"&gt;\n                  &lt;path d=\"M6 6l12 12M18 6L6 18\" /&gt;\n                &lt;/svg&gt;\n              &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div className=\"modal-body\"&gt;\n              &lt;pre className=\"context-preview\"&gt;\n                {buildHiddenContextForNode(activeNodeId, nodesById) || \"No context.\"}\n              &lt;/pre&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {selectionPopover.visible &amp;&amp; selectionPopover.rect &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"selection-popover\"\n          data-placement={selectionPopover.placement}\n          style={{\n            top: &#96;${selectionPopover.rect.top}px&#96;,\n            left: &#96;${selectionPopover.rect.left}px&#96;,\n          }}\n        &gt;\n          &lt;div className=\"selection-title\"&gt;New branch&lt;/div&gt;\n          &lt;textarea\n            placeholder=\"Ask anything about selection\"\n            value={selectionPopover.draft}\n            onChange={(event) =&gt;\n              setSelectionPopover((prev) =&gt; ({\n                ...prev,\n                draft: event.target.value,\n              }))\n            }\n            onKeyDown={handleBranchKeyDown}\n            rows={3}\n          /&gt;\n          &lt;div className=\"selection-actions\"&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; {\n                setSelectionPopover({\n                  visible: false,\n                  text: \"\",\n                  rect: null,\n                  draft: \"\",\n                  placement: \"above\",\n                  messageIndex: null,\n                  nodeId: null,\n                  treeId: null,\n                });\n                if (tempHighlight) {\n                  updateNodeMessages(tempHighlight.treeId, tempHighlight.nodeId, (messages) =&gt;\n                    messages.map((m, i) =&gt; {\n                      if (i !== tempHighlight.messageIndex || typeof m?.content !== \"string\") return m;\n                      return {\n                        ...m,\n                        content: removeTempHighlightById(m.content, tempHighlight.tempId),\n                      };\n                    }),\n                  );\n                  setTempHighlight(null);\n                }\n                window.getSelection()?.removeAllRanges?.();\n              }}\n            &gt;\n              Cancel\n            &lt;/button&gt;\n            &lt;button\n              type=\"button\"\n              className=\"primary\"\n              onClick={handleBranchSend}\n              disabled={!selectionPopover.draft.trim()}\n            &gt;\n              Create branch\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      {treeMenu.visible &amp;&amp; treeMenu.rect &amp;&amp; treeMenu.treeId &amp;&amp; (\n        &lt;div\n          ref={treeMenuRef}\n          className=\"tree-menu-popover\"\n          style={{\n            top: &#96;${treeMenu.rect.top}px&#96;,\n            left: &#96;${treeMenu.rect.left}px&#96;,\n          }}\n          role=\"dialog\"\n          aria-label=\"Tree options\"\n        &gt;\n          {treeMenu.mode === \"rename\" ? (\n            &lt;&gt;\n              &lt;div className=\"tree-menu-title\"&gt;Rename tree&lt;/div&gt;\n              &lt;input\n                className=\"tree-menu-input\"\n                value={treeMenu.draft}\n                onChange={(e) =&gt;\n                  setTreeMenu((prev) =&gt; ({ ...prev, draft: e.target.value }))\n                }\n                placeholder=\"Tree name\"\n                autoFocus\n              /&gt;\n              &lt;div className=\"tree-menu-actions\"&gt;\n                &lt;button type=\"button\" onClick={closeTreeMenu}&gt;\n                  Cancel\n                &lt;/button&gt;\n                &lt;button\n                  type=\"button\"\n                  className=\"primary\"\n                  onClick={() =&gt; {\n                    const nextTitle = (treeMenu.draft || \"\").trim();\n                    if (!nextTitle) return;\n                    updateTree(treeMenu.treeId, (tree) =&gt; ({\n                      ...tree,\n                      title: nextTitle,\n                      updatedAt: Date.now(),\n                    }));\n                    closeTreeMenu();\n                  }}\n                  disabled={!treeMenu.draft.trim()}\n                &gt;\n                  Save\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/&gt;\n          ) : (\n            &lt;&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item\"\n                onClick={() =&gt;\n                  setTreeMenu((prev) =&gt; ({\n                    ...prev,\n                    mode: \"rename\",\n                    draft: treesById[prev.treeId]?.title ?? prev.draft ?? \"\",\n                  }))\n                }\n              &gt;\n                Rename\n              &lt;/button&gt;\n              &lt;button\n                type=\"button\"\n                className=\"tree-menu-item danger\"\n                onClick={() =&gt; deleteTree(treeMenu.treeId)}\n              &gt;\n                Delete\n              &lt;/button&gt;\n            &lt;/&gt;\n          )}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `/Users/cosmo/Documents/projects/trees/src/App.jsx`

Lint results

Lint errors for `src/App.jsx`


| Message | Range | Severity |
|-------|-------|----------|
| 'summarizeTitle' est déclaré mais sa valeur n'est jamais lue. | 26:7-26:21 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---

Updated the assistant label to display `GPT-...` when the model starts with `gpt` by normalizing the model name in `src/App.jsx`.

If you want other model prefixes normalized too, tell me which ones.

---

